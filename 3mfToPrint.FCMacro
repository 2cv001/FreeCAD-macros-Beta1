# -*- coding: utf-8 -*-
"""
Macro FreeCAD multilingue : export 3MF/STL avec contr√¥le de tessellation,
conservation des param√®tres du slicer, ouverture automatique du slicer,
et d√©clenchement de commandes externes (domotique).
S'il y a deux objets dan sle 3mf source, ne garde que le premier
"""

import math, os, zipfile, shutil, subprocess, re, fnmatch, xml.etree.ElementTree as ET
import configparser, ast, platform, time
import FreeCAD, FreeCADGui, Mesh, MeshPart
from PySide import QtGui, QtCore

# -------------------------
# Constantes et configuration
# -------------------------
INI_FILE = os.path.join(os.path.dirname(__file__), "3mfToPrint.ini")
CENTER_X, CENTER_Y, CENTER_Z = 120, 120, 2.5

if platform.system() == "Windows":
    DEFAULT_SLICER_EXE = r"C:\Program Files\QIDIStudio\qidi-studio.exe"
elif platform.system() == "Linux":
    DEFAULT_SLICER_EXE = "/usr/bin/qidi-studio"
else:
    DEFAULT_SLICER_EXE = ""

DEFAULT_LINEAR_DEFLECTION = 0.01
DEFAULT_ANGULAR_DEGREES = 3.0
DEFAULT_ANGULAR_DEFLECTION = DEFAULT_ANGULAR_DEGREES * math.pi / 180.0

EXTRA_COMMANDS = [
    #(["calc.exe"], "Ouvrir la calculatrice Windows ?", 0, False),
    #(["curl", "-u", "admin:motDePass", "--insecure",
    #  "http://IpDeLaPriseShelly/rpc/Switch.Set?id=0&on=true"],
    #  "Allumer la prise Shelly Gen2 ?", 0, False),
]


     
     

# Charge les commandes externes d√©finies dans le fichier ini
def load_extra_commands_from_ini(path=INI_FILE):
    cfg = configparser.ConfigParser()
    try:
        cfg.read(path, encoding="utf-8")
        if "extra_commands" in cfg and "EXTRA_COMMANDS" in cfg["extra_commands"]:
            return ast.literal_eval(cfg["extra_commands"]["EXTRA_COMMANDS"])
    except Exception as e:
        print("‚ö†Ô∏è Erreur lecture EXTRA_COMMANDS ini:", e)
    return []

# Fusion au d√©marrage : commandes ini avant celles cod√©es en dur
EXTRA_COMMANDS = load_extra_commands_from_ini(INI_FILE) + EXTRA_COMMANDS



# -------------------------
# Traductions multilingues
# -------------------------
TRANSLATIONS = {
    "fr": {
        # Titres
        "error_title": "Erreur",
        "warn_title": "Avertissement",
        "info_title": "Info",

        # Options UI
        "options_title": "Options d'export vers QidiStudio",
        "keep_params": "Conserver les param√®tres d'impression (profil du slicer)",
        "keep_positions": "Conserver les positions sur le plateau",
        "generate_stl": "En plus du .3mf, g√©n√©rer √©galement un STL",
        "launch_slicer": "Lancer le slicer",
        "browse": "Parcourir‚Ä¶",
        "linear_label": "Pr√©cision (LinearDeflection) entre 0.01 et 10. Haute qualit√© : 0.01",
        "angular_label": "Tol√©rance angulaire (AngularDeflection) en degr√©s (ex: 3)",
        "external_actions": "Actions externes √† ex√©cuter avant fermeture :",

        # Messages d'erreur / avertissement
        "error_no_doc": "‚ùå Aucun document ouvert dans FreeCAD.",
        "error_no_save": "‚ùå Le projet n'a pas encore √©t√© sauvegard√©.",
        "warn_no_selection": "‚ö†Ô∏è Aucun objet s√©lectionn√©.",
        "warn_multi_selection": "‚ö†Ô∏è S√©lection multiple non support√©e.",
        "error_write_ini": "‚ùå √âcriture impossible sur le fichier ini :",
        "error_export_3mf": "‚ùå Erreur lors de l'export 3MF :",
        "error_generate_stl": "‚ùå Erreur lors de la g√©n√©ration du STL :",
        "error_create_3mf": "‚ùå Erreur lors de la cr√©ation du 3MF final :",
        "error_replace_3mf": "‚ùå Impossible de remplacer le 3MF :",
        "error_launch_slicer": "‚ùå Erreur lors du lancement du slicer :",
        "error_external_cmd": "‚ùå Impossible d'ex√©cuter la commande externe :",
        "error_no_geom": "‚ùå Aucun fichier de g√©om√©trie d√©tect√© dans le 3MF export√©.",
        "error_invalid_slicer": "‚ùå Le chemin du slicer est invalide :",
        "warn_no_geom_vertices": "L'objet s√©lectionn√© n'a pas de g√©om√©trie 3D utilisable (par ex. un Sketch).",


        # Infos
        "info_cancel": "‚ö†Ô∏è Export annul√© par l‚Äôutilisateur.",
        "info_done": "‚úÖ Export termin√©. Le slicer n'a pas √©t√© lanc√© (option d√©coch√©e).",
        "info_export_fc": "‚úÖ Fichier g√©n√©r√© uniquement par FreeCAD :",
        "info_export_slicer": "‚úÖ Export avec r√©cup√©ration des param√®tres du slicer :",
        

        # Aides / tooltips
        "hint_linear": "Valeur plus petite = maillage plus fin.\nExemple : 0.01 = haute qualit√©, mais fichier lourd.\n"
                       "Exemple : 0.1 = adapt√© √† une imprimante FDM classique.",
        "hint_angular": "Tol√©rance angulaire en degr√©s.\nPetite valeur = plus de d√©tails, mais fichier plus lourd.",
        "hint_positions": "Conserve la position XY sur le plateau.\n‚ö†Ô∏è Le Z est toujours recalcul√© pour √©viter que l'objet soit sous le plateau.",
        "no_external_actions": "Pas encore de commandes utilisateurs ajout√©es.",
        "hint_external_actions": "Vous pouvez ajouter vos propres actions dans le fichier ini, section [extra_commands].\n"
                                 "Chaque commande peut √™tre configur√©e avec d√©lai et activation par case √† cocher.",
        "hint_keep_params": "Conserve les param√®tres du slicer (profil d'impression).",
        "hint_generate_stl": "G√©n√®re aussi un fichier STL en plus du 3MF.",
        "hint_launch_slicer": "Lance automatiquement le slicer apr√®s export si le chemin est valide.",
    },

    "en": {
        # Titles
        "error_title": "Error",
        "warn_title": "Warning",
        "info_title": "Info",

        # UI options
        "options_title": "Export options to QidiStudio",
        "keep_params": "Keep printing parameters (slicer profile)",
        "keep_positions": "Keep positions on the build plate",
        "generate_stl": "Also generate an STL along with the .3mf",
        "launch_slicer": "Launch slicer",
        "browse": "Browse‚Ä¶",
        "linear_label": "Precision (LinearDeflection) between 0.01 and 10. High quality: 0.01",
        "angular_label": "Angular tolerance (AngularDeflection) in degrees (e.g. 3)",
        "external_actions": "External actions to execute before closing:",

        # Error / warning messages
        "error_no_doc": "‚ùå No document open in FreeCAD.",
        "error_no_save": "‚ùå The project has not been saved yet.",
        "warn_no_selection": "‚ö†Ô∏è No object selected.",
        "warn_multi_selection": "‚ö†Ô∏è Multiple selection not supported.",
        "error_write_ini": "‚ùå Unable to write to ini file:",
        "error_export_3mf": "‚ùå Error during 3MF export:",
        "error_generate_stl": "‚ùå Error during STL generation:",
        "error_create_3mf": "‚ùå Error while creating final 3MF:",
        "error_replace_3mf": "‚ùå Unable to replace 3MF:",
        "error_launch_slicer": "‚ùå Error while launching slicer:",
        "error_external_cmd": "‚ùå Unable to execute external command:",
        "error_no_geom": "‚ùå No geometry file detected in exported 3MF.",
        "error_invalid_slicer": "‚ùå Invalid slicer path:",
        "warn_no_geom_vertices": "Selected object does not contain usable 3D geometry (e.g. a Sketch).",


        # Infos
        "info_cancel": "‚ö†Ô∏è Export cancelled by user.",
        "info_done": "‚úÖ Export finished. Slicer was not launched (option unchecked).",
        "info_export_fc": "‚úÖ File generated only by FreeCAD:",
        "info_export_slicer": "‚úÖ Export with slicer parameters recovered:",

        # Tooltips
        "hint_linear": "Smaller value = finer mesh.\nExample: 0.01 = high quality but heavy file.\n"
                       "Example: 0.1 = suitable for standard FDM printer.",
        "hint_angular": "Angular tolerance in degrees.\nSmaller value = more detail, but heavier file.",
        "hint_positions": "Keeps XY position on the build plate.\n‚ö†Ô∏è Z is always recalculated to avoid sinking below the plate.",
        "no_external_actions": "No user commands added yet.",
        "hint_external_actions": "You can add your own actions in the ini file, section [extra_commands].\n"
                                 "Each command can be configured with delay and checkbox activation.",
        "hint_keep_params": "Keeps slicer parameters (printing profile).",
        "hint_generate_stl": "Also generates an STL file along with the 3MF.",
        "hint_launch_slicer": "Automatically launches the slicer after export if the path is valid.",
    }
}


# D√©termine la langue de l‚Äôutilisateur √† partir de FreeCADGui
def get_user_language():
    try:
        locale = FreeCADGui.getLocale().lower()
        # Normalisation
        if locale.startswith("fr") or "french" in locale:
            return "fr"
        if locale.startswith("en") or "english" in locale:
            return "en"
        '''
        if locale.startswith("de") or "german" in locale:
            return "de"
        if locale.startswith("es") or "spanish" in locale:
            return "es"
        if locale.startswith("it") or "italian" in locale:
            return "it"
        '''    
        # Fallback
        return "en"
    except Exception:
        return "en"



# Traduit une cl√© donn√©e selon la langue utilisateur
def tr(key):
    lang = get_user_language()
    return TRANSLATIONS.get(lang, TRANSLATIONS["en"]).get(key, key)



# -------------------------
# Utilitaires UI / config
# -------------------------
# Affiche une bo√Æte de message d‚Äôinformation dans FreeCAD
def show_message(title, message):
    QtGui.QMessageBox.information(None, title, message)

# Charge la configuration (slicer, d√©flections) depuis le fichier ini
def load_config():
    cfg = {
        "slicer_exe": DEFAULT_SLICER_EXE,
        "linear_deflection": DEFAULT_LINEAR_DEFLECTION,
        "angular_deflection": DEFAULT_ANGULAR_DEFLECTION,
    }
    config = configparser.ConfigParser()
    if os.path.exists(INI_FILE):
        try:
            config.read(INI_FILE)
            if "Settings" in config:
                s = config["Settings"]
                if "slicer_exe" in s:
                    cfg["slicer_exe"] = s.get("slicer_exe", cfg["slicer_exe"])
                if "linear_deflection" in s:
                    cfg["linear_deflection"] = float(s.get("linear_deflection", cfg["linear_deflection"]))
                if "angular_deflection_deg" in s:
                    deg = float(s.get("angular_deflection_deg", DEFAULT_ANGULAR_DEGREES))
                    cfg["angular_deflection"] = deg * math.pi / 180.0
        except Exception as e:
            print("‚ö†Ô∏è Erreur lecture ini:", e)
    return cfg

# Sauvegarde les param√®tres (d√©flections, chemin slicer) dans le fichier ini
def save_settings(linear, angular_rad, slicer_path):
    angular_deg = None
    if angular_rad is not None:
        angular_deg = angular_rad * 180.0 / math.pi

    # Cr√©ation initiale avec commentaires si le fichier n'existe pas
    if not os.path.exists(INI_FILE):
        with open(INI_FILE, "w", encoding="utf-8") as f:
            f.write(
                "[Settings]\n"
                "# linear_deflection : pr√©cision lin√©aire (float)\n"
                "# angular_deflection_deg : tol√©rance angulaire en DEGR√âS (ex: 3.0)\n"
                "# slicer_exe : chemin vers l'ex√©cutable du slicer\n"
                f"linear_deflection = {linear}\n"
                f"angular_deflection_deg = {angular_deg}\n"
                f"slicer_exe = {slicer_path}\n\n"
                "[extra_commands]\n"
                "EXTRA_COMMANDS = [\n"
                "    ]\n"
            )
        return


    # Mise √† jour cibl√©e de [Settings] si le fichier existe d√©j√†
    with open(INI_FILE, "r", encoding="utf-8") as f:
        lines = f.readlines()

    new_lines = []
    in_settings = False
    for line in lines:
        if line.strip().startswith("[Settings]"):
            in_settings = True
            new_lines.append(line)
            continue
        if in_settings and line.strip().startswith("[") and not line.strip().startswith("[Settings]"):
            in_settings = False
        if in_settings:
            if line.strip().startswith("linear_deflection") and linear is not None:
                new_lines.append(f"linear_deflection = {linear}\n")
                continue
            if line.strip().startswith("angular_deflection_deg") and angular_deg is not None:
                new_lines.append(f"angular_deflection_deg = {angular_deg}\n")
                continue
            if line.strip().startswith("slicer_exe") and slicer_path is not None:
                new_lines.append(f"slicer_exe = {slicer_path}\n")
                continue
        new_lines.append(line)

    with open(INI_FILE, "w", encoding="utf-8") as f:
        f.writelines(new_lines)

# -------------------------
# Interface utilisateur
# -------------------------
# Affiche une bo√Æte de dialogue pour demander les options d‚Äôexport √† l‚Äôutilisateur
def ask_user_options(current_slicer, current_linear, current_angular):
    """Affiche bo√Æte de dialogue pour options export (positions, params, STL, slicer, deflection)."""
    dialog = QtGui.QDialog()
    dialog.setWindowTitle(tr("options_title"))
    dialog.setMinimumWidth(720)

    layout = QtGui.QVBoxLayout()

    # Cases principales
    chk_params = QtGui.QCheckBox(tr("keep_params"))
    chk_params.setToolTip(tr("hint_keep_params"))
    chk_params.setChecked(True)
    layout.addWidget(chk_params)

    chk_positions = QtGui.QCheckBox(tr("keep_positions"))
    chk_positions.setToolTip(tr("hint_positions"))
    chk_positions.setChecked(True)
    layout.addWidget(chk_positions)

    chk_stl = QtGui.QCheckBox(tr("generate_stl"))
    chk_stl.setToolTip(tr("hint_generate_stl"))
    chk_stl.setChecked(False)
    layout.addWidget(chk_stl)

    # Ligne combin√©e : case "Lancer le slicer" + champ chemin
    h_slicer = QtGui.QHBoxLayout()
    chk_launch = QtGui.QCheckBox(tr("launch_slicer"))
    chk_launch.setToolTip(tr("hint_launch_slicer"))
    chk_launch.setChecked(True)
    h_slicer.addWidget(chk_launch)

    edit_slicer = QtGui.QLineEdit(current_slicer or "")
    edit_slicer.setMinimumWidth(420)
    h_slicer.addWidget(edit_slicer, stretch=1)

    btn_browse = QtGui.QPushButton(tr("browse"))
    def browse():
        path, _ = QtGui.QFileDialog.getOpenFileName(dialog, tr("browse"))
        if path:
            edit_slicer.setText(path)
    btn_browse.clicked.connect(browse)
    h_slicer.addWidget(btn_browse)
    layout.addLayout(h_slicer)

    # Pr√©cision lin√©aire
    h_lin = QtGui.QHBoxLayout()
    lbl_lin = QtGui.QLabel(tr("linear_label"))
    lbl_lin.setMinimumWidth(420)
    h_lin.addWidget(lbl_lin)

    spin_lin = QtGui.QDoubleSpinBox()
    spin_lin.setToolTip(tr("hint_linear"))
    spin_lin.setRange(0.01, 10.0)
    spin_lin.setSingleStep(0.01)
    spin_lin.setDecimals(2)
    spin_lin.setMaximumWidth(80)
    try:
        spin_lin.setValue(round(float(current_linear), 2))
    except Exception:
        spin_lin.setValue(DEFAULT_LINEAR_DEFLECTION)
    h_lin.addWidget(spin_lin)
    h_lin.addStretch()
    layout.addLayout(h_lin)

    # Tol√©rance angulaire
    h_ang = QtGui.QHBoxLayout()
    lbl_ang = QtGui.QLabel(tr("angular_label"))
    lbl_ang.setMinimumWidth(420)
    h_ang.addWidget(lbl_ang)

    spin_ang = QtGui.QDoubleSpinBox()
    spin_ang.setToolTip(tr("hint_angular"))
    spin_ang.setRange(1.0, 90.0)
    spin_ang.setSingleStep(1.0)
    spin_ang.setDecimals(1)
    spin_ang.setMaximumWidth(80)
    try:
        deg = float(current_angular) * 180.0 / math.pi
        spin_ang.setValue(deg)
    except Exception:
        spin_ang.setValue(DEFAULT_ANGULAR_DEGREES)
    h_ang.addWidget(spin_ang)
    h_ang.addStretch()
    layout.addLayout(h_ang)

    # Cases pour les commandes externes
    extra_checks = []
    if EXTRA_COMMANDS:
        lbl_ext = QtGui.QLabel(tr("external_actions"))
        lbl_ext.setToolTip(tr("hint_external_actions") + f"\n\nFichier ini : {INI_FILE}")
        layout.addWidget(lbl_ext)
        for cmd, label, delay, default in EXTRA_COMMANDS:
            chk = QtGui.QCheckBox(label)
            chk.setChecked(default)
            layout.addWidget(chk)
            extra_checks.append((chk, cmd, delay))
    else:
        # üëâ Afficher un libell√© m√™me si aucune commande n'est d√©finie
        lbl_ext = QtGui.QLabel(tr("no_external_actions"))
        lbl_ext.setToolTip(tr("hint_external_actions") + f"\n\nFichier ini : {INI_FILE}")
        layout.addWidget(lbl_ext)


    # Boutons OK/Annuler
    btns = QtGui.QDialogButtonBox(QtGui.QDialogButtonBox.Ok | QtGui.QDialogButtonBox.Cancel)
    layout.addWidget(btns)
    dialog.setLayout(layout)

    btns.accepted.connect(dialog.accept)
    btns.rejected.connect(dialog.reject)

    if dialog.exec() == QtGui.QDialog.Accepted:
        linear_val = float(spin_lin.value())
        angular_deg = float(spin_ang.value())
        angular_rad = angular_deg * math.pi / 180.0
        return (
            chk_params.isChecked(),
            chk_positions.isChecked(),
            chk_stl.isChecked(),
            edit_slicer.text(),
            chk_launch.isChecked(),
            linear_val,
            angular_rad,
            [(chk.isChecked(), cmd, delay) for chk, cmd, delay in extra_checks]
        )
    else:
        return (None, None, None, None, None, None, None, [])

# -------------------------
# Fonctions de traitement 3MF / mesh
# -------------------------


def is_qidistudio(zip):
    # Ancien slicer Qidi (multi-objets)
    names = zip.namelist()
    return (
        "3D/_rels/3dmodel.model.rels" in names and
        "Metadata/model_settings.config" in names
    )

"""
def is_qidislicer(zip):
    # Slicer moderne Qidi (Cura-like)
    names = zip.namelist()
    return (
        "3D/3dmodel.model" in names and
        not any(n.startswith("3D/Objects/") for n in names) and
        "3D/_rels/3dmodel.model.rels" not in names
    )
"""

def is_qidislicer(zip_file):
    names = zip_file.namelist()
    if "3D/3dmodel.model" in names and not any(n.startswith("3D/Objects/") for n in names):
        try:
            text = zip_file.read("3D/3dmodel.model").decode("utf-8", errors="replace")
            print('fichier 3mf qidislicer d√©tect√©  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')
            return "<metadata name=\"slic3rpe:Version3mf\"" in text or "Application=QIDISlicer" in text

        except Exception:
            print('Ce n est pas un fichier 3mf bbbbbbbbbbbbbbbbbbbbbbbbbaaaa')
            return False

    return False


def is_slic3r_style(zip):
    """
    D√©tection des 3MF style Slic3r/Prusa/Orca :
    - Pr√©sence de plusieurs objets dans 3D/Objects/
    - Fichier principal 3D/3dmodel.model
    - Pas de Metadata sp√©cifique QidiStudio
    """
    names = zip.namelist()
    has_objects = any(n.startswith("3D/Objects/") and n.endswith(".model") for n in names)
    has_main_model = "3D/3dmodel.model" in names
    # On exclut QidiStudio qui a aussi Metadata/model_settings.config
    is_not_qidi = "Metadata/model_settings.config" not in names
    return has_objects and has_main_model and is_not_qidi


# Recherche le fichier de g√©om√©trie principal dans une archive 3MF
def find_geom_file_in_3mf(zip_path):
    with zipfile.ZipFile(zip_path, 'r') as z:
        rels_name = "_rels/.rels"
        if rels_name in z.namelist():
            try:
                rels_text = z.read(rels_name).decode("utf-8")
                root = ET.fromstring(rels_text)
                for rel in root:
                    if rel.tag.endswith("Relationship"):
                        rtype = rel.attrib.get("Type", "")
                        if rtype.endswith("3dmodel"):
                            target = rel.attrib.get("Target")
                            if target and target.startswith("/"):
                                target = target[1:]
                            if target in z.namelist():
                                return target
            except Exception:
                pass
        for name in z.namelist():
            if fnmatch.fnmatch(name, "3D/Objects/*.model"):
                return name
        if "3D/3dmodel.model" in z.namelist():
            return "3D/3dmodel.model"
    return None

# R√©initialise la transformation des items en les centrant sur un point donn√©
def reset_item_transform(model_data, center=(CENTER_X, CENTER_Y, CENTER_Z)):
    text = model_data.decode("utf-8")
    new_transform = f'transform="1 0 0 0 1 0 0 0 1 {center[0]} {center[1]} {center[2]}"'
    text = re.sub(r'(<item[^>]*?)\s+transform="[^"]+"', r'\1 ' + new_transform, text)
    return text.encode("utf-8")

# Exporte une s√©lection en STL avec param√®tres de tessellation    
def export_stl_with_deflection(selection, stl_path,
                               linear_deflection=DEFAULT_LINEAR_DEFLECTION,
                               angular_deflection=DEFAULT_ANGULAR_DEFLECTION):
    doc = FreeCAD.ActiveDocument
    temp_objs = []
    try:
        for obj in selection:
            mesh = MeshPart.meshFromShape(
                Shape=obj.Shape,
                LinearDeflection=float(linear_deflection),
                AngularDeflection=float(angular_deflection)
            )
            mobj = doc.addObject("Mesh::Feature", f"TempMeshSTL_{obj.Name}")
            mobj.Mesh = mesh
            temp_objs.append(mobj)
        doc.recompute()
        Mesh.export(temp_objs, stl_path)
    finally:
        for t in temp_objs:
            try: doc.removeObject(t.Name)
            except Exception: pass
        doc.recompute()

# Exporte une s√©lection en 3MF avec param√®tres de tessellation
def export_selection_with_deflection(selection, out_3mf_path,
                                     linear_deflection=DEFAULT_LINEAR_DEFLECTION,
                                     angular_deflection=DEFAULT_ANGULAR_DEFLECTION):
    doc = FreeCAD.ActiveDocument
    temp_objs = []
    try:
        for obj in selection:
            mesh = MeshPart.meshFromShape(
                Shape=obj.Shape,
                LinearDeflection=float(linear_deflection),
                AngularDeflection=float(angular_deflection))
            mobj = doc.addObject("Mesh::Feature", f"TempMesh_{obj.Name}")
            mobj.Mesh = mesh
            temp_objs.append(mobj)
        doc.recompute()
        Mesh.export(temp_objs, out_3mf_path)
    finally:
        for t in temp_objs:
            try: doc.removeObject(t.Name)
            except Exception: pass
        doc.recompute()


# Force uniquement la composante Z des transformations dans le mod√®le 3MF
def force_zmax_in_transform(model_data, zmax):
    """
    Remplace uniquement la composante Z (12e valeur) du transform des <item> dans 3dmodel.model.
    - Conserve X/Y et la matrice de rotation/√©chelle.
    - zmax est un float (hauteur max des vertex) calcul√© par recenter_vertices.

    Si plusieurs <item> existent, on les met tous √† jour.
    """
    try:
        text = model_data.decode("utf-8")

        def repl(m):
            nums = m.group(1).split()
            # transform = 12 nombres : 9 pour la matrice, 3 pour la translation (X, Y, Z)
            if len(nums) == 12:
                nums[-1] = f"{zmax}"
                return 'transform="' + " ".join(nums) + '"'
            # Si format inattendu, on ne modifie pas
            return m.group(0)

        # Met √† jour tous les transform="..."; count=0 = sans limite
        text = re.sub(r'transform="([^"]+)"', repl, text, count=0)
        return text.encode("utf-8")
    except Exception as e:
        print("‚ö†Ô∏è force_zmax_in_transform: √©chec, on garde le transform d'origine :", e)
        return model_data


# Recentre les sommets en XY et calcule le Zmax pour placement correct

def recenter_vertices(model_data):
    """
    Recentrage des vertex en X/Y et calcul du Zmax pour placement correct sur le plateau.
    Retourne : (donn√©es XML modifi√©es, zmax)
    """
    try:
        ET.register_namespace('', "http://schemas.microsoft.com/3dmanufacturing/core/2015/02")
        root = ET.fromstring(model_data.decode("utf-8"))
        ns = {"ns": "http://schemas.microsoft.com/3dmanufacturing/core/2015/02"}
        verts = root.findall(".//ns:vertex", ns)

        if not verts:
            # Aucun sommet trouv√© ‚Üí avertissement et retour inchang√©
            show_message(tr("warn_title"), tr("warn_no_geom_vertices"))
            return model_data, CENTER_Z

        xs = [float(v.attrib["x"]) for v in verts]
        ys = [float(v.attrib["y"]) for v in verts]
        zs = [float(v.attrib["z"]) for v in verts]

        # Calcul du centre XY et du Zmax
        xc, yc = (min(xs) + max(xs)) / 2.0, (min(ys) + max(ys)) / 2.0
        zmax = max(zs)

        # Recentrage XY
        for v in verts:
            v.attrib["x"] = str(float(v.attrib["x"]) - xc)
            v.attrib["y"] = str(float(v.attrib["y"]) - yc)

        return ET.tostring(root, encoding="utf-8", xml_declaration=False), zmax

    except Exception as e:
        print("‚ö†Ô∏è Erreur recentrage vertex :", e)
        return model_data, CENTER_Z

def clean_qidi_style(src_3mf, dst_3mf):
    """
    Nettoie un 3MF QidiSlicer moderne (Cura-like).
    - Garde uniquement le premier <object> et son <item> dans 3D/3dmodel.model
    - Supprime les autres objets et items
    - Nettoie Metadata/Slic3r_PE_model.config pour ne garder que l'objet conserv√©
    - Garantit la pr√©sence du fichier 3D/_rels/3dmodel.model.rels
    """

    model_path = "3D/3dmodel.model"
    rels_path = "3D/_rels/3dmodel.model.rels"
    config_path = "Metadata/Slic3r_PE_model.config"

    with zipfile.ZipFile(src_3mf, "r") as zin:
        # --- Nettoyage du 3dmodel.model ---
        model_xml = zin.read(model_path).decode("utf-8")
        root = ET.fromstring(model_xml)
        ns = {"m": "http://schemas.microsoft.com/3dmanufacturing/core/2015/02"}

        objects = root.findall("m:resources/m:object", ns)
        items = root.findall("m:build/m:item", ns)

        keep_object_id = None
        removed_ids = []

        if objects:
            keep_object_id = objects[0].attrib.get("id")

        # Supprimer les objets exc√©dentaires
        for obj in objects[1:]:
            removed_ids.append(obj.attrib.get("id"))
            root.find("m:resources", ns).remove(obj)

        # Supprimer les items exc√©dentaires
        for item in items:
            if item.attrib.get("objectid") != keep_object_id:
                removed_ids.append(item.attrib.get("objectid"))
                root.find("m:build", ns).remove(item)

        new_model_xml = ET.tostring(root, encoding="utf-8")

        # --- Nettoyage du Slic3r_PE_model.config ---
        if config_path in zin.namelist():
            cfg_xml = zin.read(config_path).decode("utf-8")
            cfg_root = ET.fromstring(cfg_xml)

            for obj in cfg_root.findall("object"):
                if obj.attrib.get("id") != keep_object_id:
                    removed_ids.append(obj.attrib.get("id"))
                    cfg_root.remove(obj)

            new_cfg_xml = ET.tostring(cfg_root, encoding="utf-8")
        else:
            new_cfg_xml = None

        # --- R√©√©criture du ZIP nettoy√© ---
        with zipfile.ZipFile(dst_3mf, "w", compression=zipfile.ZIP_DEFLATED) as zout:
            for item in zin.infolist():
                name = item.filename
                if name == model_path:
                    zout.writestr(name, new_model_xml)
                    continue
                if name == config_path and new_cfg_xml:
                    zout.writestr(name, new_cfg_xml)
                    continue
                zout.writestr(name, zin.read(name))

            # Garantir la pr√©sence du rels
            if rels_path not in zin.namelist():
                rels_content = """<?xml version='1.0' encoding='UTF-8'?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
 <Relationship Target="/3D/3dmodel.model" Id="rel0" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" />
</Relationships>
"""
                zout.writestr(rels_path, rels_content)

    print(f"‚úÖ Nettoyage QidiSlicer termin√©. Objet conserv√© id={keep_object_id}")
    if removed_ids:
        print(f"   Objets supprim√©s : {removed_ids}")
    else:
        print("   Aucun objet supprim√© (mono-objet d√©j√†).")
    print(f"   Fichier nettoy√© : {dst_3mf}")


def clean_multi_object_style(src_3mf, dst_3mf, mode="qidi"):
    """
    Nettoyage CHIRURGICAL d'un 3MF QidiStudio.
    Version corrig√©e + PATCH chemins :
    - Normalisation des chemins (strip + replace)
    - D√©tection correcte du parent (object id="X")
    - Suppression des objets exc√©dentaires
    - Suppression des items exc√©dentaires
    - Suppression des relations exc√©dentaires
    - Nettoyage complet de Metadata/model_settings.config
    """

    print("\n=== Nettoyage CHIRURGICAL QidiStudio ===")

    rels_path = "3D/_rels/3dmodel.model.rels"
    config_path = "Metadata/model_settings.config"
    model_path = "3D/3dmodel.model"

    with zipfile.ZipFile(src_3mf, "r") as zin:

        # --- 1) D√©tection des fichiers objets ---
        object_models = [
            n.strip().replace("\\", "/")
            for n in zin.namelist()
            if n.startswith("3D/Objects/") and n.endswith(".model")
        ]

        print(f"üìÅ Objets trouv√©s : {object_models}")

        if not object_models:
            print("‚ö†Ô∏è Aucun objet trouv√© ‚Üí fichier non conforme QidiStudio")
            return None, None

        keep_model = object_models[0]
        to_delete = object_models[1:]

        print(f"‚û°Ô∏è Objet conserv√© : {keep_model}")
        print(f"üóëÔ∏è Objets supprim√©s : {to_delete}")

        # --- 2) Nettoyage CHIRURGICAL du 3dmodel.model ---
        model_txt = zin.read(model_path).decode("utf-8")

        # D√©tection du parent r√©el
        parent_pattern = (
            rf'<object[^>]*id="(\d+)"[^>]*>[\s\S]*?'
            rf'<component[^>]*p:path="/{keep_model}"'
        )
        m = re.search(parent_pattern, model_txt)

        if not m:
            print("‚ùå Impossible de trouver l'objet parent dans 3dmodel.model")
            return None, keep_model

        keep_object_id = m.group(1)
        print(f"‚û°Ô∏è ID parent conserv√© : {keep_object_id}")

        # SUPPRESSION des <object> exc√©dentaires
        model_txt_before = model_txt
        model_txt = re.sub(
            rf'<object[^>]*id="(?!{keep_object_id}")([\s\S]*?)</object>',
            '',
            model_txt
        )
        if model_txt != model_txt_before:
            print("üóëÔ∏è Objets exc√©dentaires supprim√©s dans 3dmodel.model")

        # SUPPRESSION des <item> exc√©dentaires
        model_txt_before = model_txt
        model_txt = re.sub(
            rf'<item[^>]*objectid="(?!{keep_object_id}")([^"]*)"[^>]*/>',
            '',
            model_txt
        )
        if model_txt != model_txt_before:
            print("üóëÔ∏è Items exc√©dentaires supprim√©s dans <build>")

        # --- 3) Nettoyage du rels ---
        if rels_path in zin.namelist():
            rels_txt = zin.read(rels_path).decode("utf-8")
            rels_before = rels_txt

            rels_txt = re.sub(
                rf'<Relationship[^>]*Target="(?!/{keep_model}")([^"]*)"[^>]*/>',
                '',
                rels_txt
            )

            if rels_txt != rels_before:
                print("üóëÔ∏è Relations exc√©dentaires supprim√©es dans rels")

        # --- 4) Nettoyage complet du model_settings.config ---
        if config_path in zin.namelist():
            cfg_txt = zin.read(config_path).decode("utf-8")

            # SUPPRESSION <object id="...">
            cfg_before = cfg_txt
            cfg_txt = re.sub(
                rf'<object[^>]*id="(?!{keep_object_id}")([\s\S]*?)</object>',
                '',
                cfg_txt
            )
            if cfg_txt != cfg_before:
                print("üóëÔ∏è Objets exc√©dentaires supprim√©s dans model_settings.config")

            # SUPPRESSION <model_instance>
            cfg_before = cfg_txt
            cfg_txt = re.sub(
                rf'<model_instance>[\s\S]*?<metadata key="object_id" value="(?!{keep_object_id}")([\s\S]*?)</model_instance>',
                '',
                cfg_txt
            )
            if cfg_txt != cfg_before:
                print("üóëÔ∏è model_instance exc√©dentaires supprim√©s")

            # SUPPRESSION <assemble_item>
            cfg_before = cfg_txt
            cfg_txt = re.sub(
                rf'<assemble_item[^>]*object_id="(?!{keep_object_id}")([^"]*)"[^>]*/>',
                '',
                cfg_txt
            )
            if cfg_txt != cfg_before:
                print("üóëÔ∏è assemble_item exc√©dentaires supprim√©s")

        # --- 5) R√©√©criture du ZIP ---
        print("üì¶ R√©√©criture du fichier nettoy√©‚Ä¶")

        compression = zipfile.ZIP_STORED if mode == "qidi" else zipfile.ZIP_DEFLATED
        with zipfile.ZipFile(dst_3mf, "w", compression=compression) as zout:
            for item in zin.infolist():
                name = item.filename.strip().replace("\\", "/")

                # SUPPRESSION des fichiers objets exc√©dentaires
                if name.startswith("3D/Objects/") and name != keep_model:
                    print(f"üóëÔ∏è Suppression fichier : {name}")
                    continue

                if name == model_path:
                    zout.writestr(name, model_txt)
                    continue

                if name == rels_path:
                    zout.writestr(name, rels_txt)
                    continue

                if name == config_path:
                    zout.writestr(name, cfg_txt)
                    continue

                zout.writestr(name, zin.read(item.filename))

    print("‚úÖ Nettoyage CHIRURGICAL termin√©.")
    print(f"‚û°Ô∏è Objet final conserv√© : {keep_model} (id={keep_object_id})")
    print(f"‚û°Ô∏è Fichier nettoy√© : {dst_3mf}")

    return keep_object_id, keep_model




def replace_mesh_in_model_xml(old_model_xml_bytes, new_model_xml_bytes):
    """
    Remplace uniquement le <mesh> dans le mod√®le Qidi.
    Conserve :
      - le root <model> d'origine
      - les namespaces (dont slic3rpe)
      - les m√©tadonn√©es (dont Application=QIDISlicer-1.2.5)
      - les <resources>, <build>, <item>, transforms, etc.

    old_model_xml_bytes : contenu du 3dmodel.model Qidi
    new_model_xml_bytes : contenu du 3dmodel.model FreeCAD recentr√©
    """

    # D√©codage robuste
    old_text = old_model_xml_bytes.decode("utf-8", errors="replace")
    new_text = new_model_xml_bytes.decode("utf-8", errors="replace")

    # Parsing XML
    old_root = ET.fromstring(old_text)
    new_root = ET.fromstring(new_text)

    # Namespace principal
    ns_uri = old_root.tag.split("}")[0].strip("{") if "}" in old_root.tag else ""
    ns = {"m": ns_uri} if ns_uri else {}

    # Trouver les <mesh>
    old_mesh = old_root.find(".//m:mesh", ns) if ns else old_root.find(".//mesh")
    new_mesh = new_root.find(".//m:mesh", ns) if ns else new_root.find(".//mesh")

    if old_mesh is None or new_mesh is None:
        print("‚ö†Ô∏è Impossible de trouver <mesh> dans l'un des fichiers.")
        return old_model_xml_bytes

    # Remplacer le contenu du <mesh> d'origine
    for child in list(old_mesh):
        old_mesh.remove(child)
    for child in list(new_mesh):
        old_mesh.append(child)

    # Re-s√©rialisation
    xml_bytes = ET.tostring(old_root, encoding="utf-8")
    xml_decl = b'<?xml version="1.0" encoding="UTF-8"?>\n'

    if not xml_bytes.startswith(b"<?xml"):
        xml_bytes = xml_decl + xml_bytes

    return xml_bytes



def inject_geometry_into_qidi_3mf(old_3mf_path, new_3mf_path, new_model_xml_bytes):
    """
    Construit un nouveau 3MF Qidi en rempla√ßant uniquement le <mesh> dans 3D/3dmodel.model.
    Conserve :
      - [Content_Types].xml
      - _rels/.rels
      - Metadata/*
      - namespaces
      - Application=QIDISlicer-1.2.5
      - transforms
    """

    with zipfile.ZipFile(old_3mf_path, "r") as zin, \
         zipfile.ZipFile(new_3mf_path, "w", compression=zipfile.ZIP_DEFLATED) as zout:

        for info in zin.infolist():
            name = info.filename
            data = zin.read(name)

            # On remplace uniquement 3D/3dmodel.model
            if name == "3D/3dmodel.model":
                merged = replace_mesh_in_model_xml(data, new_model_xml_bytes)
                zout.writestr(name, merged)
                continue

            # Tous les autres fichiers sont recopi√©s tels quels
            zout.writestr(name, data)


# -------------------------
# Routine principale
# -------------------------
# Routine principale : exporte la s√©lection en 3MF/STL, injecte g√©om√©trie, 
# lance slicer et commandes externes
# -------------------------


def export_replace_geometry():
    """
    Routine principale :
    - Exporte la s√©lection en 3MF/STL (FreeCAD)
    - Injecte la g√©om√©trie dans un ancien 3MF (si pr√©sent)
      * en conservant la structure OPC, les m√©tadonn√©es et les namespaces
      * en rempla√ßant uniquement la g√©om√©trie (<mesh>) pour QidiSlicer
    - Conserve ou non les param√®tres du slicer
    - Lance le slicer
    - Ex√©cute les commandes externes
    """

    print(">>> NOUVELLE EXECUTION DE LA MACRO <<<")

    # ------------------------------------------------------------
    # 1) V√©rifications initiales
    # ------------------------------------------------------------
    cfg = load_config()
    doc = FreeCAD.ActiveDocument
    if not doc:
        show_message(tr("error_title"), tr("error_no_doc"))
        return

    fcstd_path = doc.FileName
    if not fcstd_path:
        show_message(tr("error_title"), tr("error_no_save"))
        return

    base_name = os.path.splitext(fcstd_path)[0]
    fc_3mf = base_name + ".3mf"
    old_3mf_backup = base_name + ".old.3mf"

    # Sauvegarde de l'ancien 3MF
    if os.path.exists(fc_3mf):
        shutil.move(fc_3mf, old_3mf_backup)

    # V√©rification de la s√©lection
    selection = [
        obj for obj in FreeCADGui.Selection.getSelection()
        if hasattr(obj, "Shape") and obj.Shape is not None
    ]
    if not selection:
        show_message(tr("warn_title"), tr("warn_no_selection"))
        return
    if len(selection) > 1:
        show_message(tr("warn_title"), tr("warn_multi_selection"))
        return

    # ------------------------------------------------------------
    # 2) Pr√©f√©rences + bo√Æte de dialogue
    # ------------------------------------------------------------
    slicer_path_pref = cfg.get("slicer_exe", DEFAULT_SLICER_EXE)
    linear_pref = cfg.get("linear_deflection", DEFAULT_LINEAR_DEFLECTION)
    angular_pref = cfg.get("angular_deflection", DEFAULT_ANGULAR_DEFLECTION)

    while True:
        (keep_params, keep_positions, generate_stl,
         slicer_path, launch_slicer,
         linear_value, angular_value, extra_cmds) = ask_user_options(
            slicer_path_pref, linear_pref, angular_pref
        )

        if slicer_path is None and launch_slicer is None:
            show_message(tr("info_title"), tr("info_cancel"))
            if os.path.exists(old_3mf_backup) and not os.path.exists(fc_3mf):
                shutil.move(old_3mf_backup, fc_3mf)
            return

        if launch_slicer and slicer_path and not os.path.exists(slicer_path):
            show_message(tr("error_title"), f"{tr('error_invalid_slicer')}\n{slicer_path}")
            continue

        break

    save_settings(linear=linear_value, angular_rad=angular_value, slicer_path=slicer_path)

    # ------------------------------------------------------------
    # 3) Export FreeCAD ‚Üí 3MF
    # ------------------------------------------------------------
    try:
        export_selection_with_deflection(
            selection, fc_3mf,
            linear_deflection=linear_value,
            angular_deflection=angular_value
        )
    except Exception as e:
        show_message(tr("error_title"), f"{tr('error_export_3mf')} {e}")
        if os.path.exists(old_3mf_backup) and not os.path.exists(fc_3mf):
            shutil.move(old_3mf_backup, fc_3mf)
        return

    # Export STL si demand√©
    if generate_stl:
        try:
            export_stl_with_deflection(
                selection, base_name + ".stl",
                linear_deflection=linear_value,
                angular_deflection=angular_value
            )
        except Exception as e:
            show_message(tr("error_title"), f"{tr('error_generate_stl')} {e}")

    # ------------------------------------------------------------
    # 4) Injection g√©om√©trie si ancien 3MF
    # ------------------------------------------------------------
    if os.path.exists(fc_3mf) and os.path.exists(old_3mf_backup):

        cleaned_old_3mf = base_name + ".cleaned.3mf"
        keep_model = None

        # D√©tection du slicer source
        with zipfile.ZipFile(old_3mf_backup, "r") as zin:
            if is_qidistudio(zin):
                print("   üîé Slicer d√©tect√© : QidiStudio")
                keep_object_id, keep_model = clean_multi_object_style(old_3mf_backup, cleaned_old_3mf, mode="qidi")


            elif is_qidislicer(zin):
                print("   üîé Slicer d√©tect√© : QidiSlicer")
                clean_qidi_style(old_3mf_backup, cleaned_old_3mf)
                keep_model = None

            elif is_slic3r_style(zin):
                print("   üîé Slicer d√©tect√© : Slic3r/Orca")
                keep_object_id, keep_model = clean_multi_object_style(old_3mf_backup, cleaned_old_3mf, mode="slic3r")


            else:
                print("   üîé Slicer d√©tect√© : inconnu ‚Üí copie brute")
                shutil.copy(old_3mf_backup, cleaned_old_3mf)
                keep_model = "3D/Objects/object_1.model"

        old_3mf = cleaned_old_3mf

        # G√©om√©trie FreeCAD
        geom_entry = find_geom_file_in_3mf(fc_3mf)
        if not geom_entry:
            show_message(tr("error_title"), tr("error_no_geom"))
            return

        with zipfile.ZipFile(fc_3mf, 'r') as fc_zip:
            geom_data = fc_zip.read(geom_entry)

        geom_data_centered, zmax = recenter_vertices(geom_data)

        # Reconstruction ‚Üí fichier NEUF
        tmp_new = base_name + ".new.3mf"

        with zipfile.ZipFile(old_3mf, 'r') as old_zip, \
             zipfile.ZipFile(tmp_new, 'w', compression=zipfile.ZIP_DEFLATED) as new_zip:

            names = old_zip.namelist()
            has_objects = any(n.startswith("3D/Objects/") for n in names)

            for item in old_zip.infolist():
                name = item.filename
                data = old_zip.read(name)

                # --------------------------------------------------------
                # CAS A : Multi-objets (Slic3r/Orca/QidiStudio)
                # --------------------------------------------------------
                if has_objects:
                    if name == keep_model:
                        new_zip.writestr(name, geom_data_centered)
                        print(f"   ‚úÖ Objet inject√© : {keep_model}")
                        continue

                    elif name.startswith("3D/Objects/") and name.endswith(".model"):
                        continue

                    if name.endswith("3dmodel.model"):
                        if keep_positions:
                            data = force_zmax_in_transform(data, zmax)
                        else:
                            data = reset_item_transform(data, center=(CENTER_X, CENTER_Y, zmax))
                        new_zip.writestr(name, data)
                        continue

                    if not keep_params and name.startswith("Metadata/"):
                        continue

                    new_zip.writestr(name, data)
                    continue

                # --------------------------------------------------------
                # CAS B : QidiSlicer mono-objet
                # --------------------------------------------------------
                else:
                    new_zip.close()
                    inject_geometry_into_qidi_3mf(old_3mf, tmp_new, geom_data_centered)
                    break

        # Remplacement final
        if os.path.exists(fc_3mf):
            os.remove(fc_3mf)
        shutil.move(tmp_new, fc_3mf)

        if os.path.exists(old_3mf):
            os.remove(old_3mf)

        print("‚úÖ Export avec r√©cup√©ration des param√®tres du slicer :", fc_3mf)

    else:
        print("‚úÖ Fichier g√©n√©r√© uniquement par FreeCAD :", fc_3mf)

    # ------------------------------------------------------------
    # 5) Lancement du slicer
    # ------------------------------------------------------------
    if launch_slicer and slicer_path and os.path.exists(slicer_path):
        try:
            time.sleep(0.2)
            subprocess.Popen(f'"{slicer_path}" "{fc_3mf}"', shell=True)
        except Exception as e:
            show_message(tr("error_title"), f"{tr('error_launch_slicer')} {e}")
    else:
        if not launch_slicer:
            show_message(tr("info_title"), tr("info_done"))

    # ------------------------------------------------------------
    # 6) Commandes externes
    # ------------------------------------------------------------
    for checked, cmd, delay in extra_cmds:
        if checked:
            try:
                if delay > 0:
                    time.sleep(delay)
                subprocess.Popen(cmd)
            except Exception as e:
                show_message(tr("error_title"), f"{tr('error_external_cmd')} {e}")




export_replace_geometry()
