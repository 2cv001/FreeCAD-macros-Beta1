# -*- coding: utf-8 -*-
"""
Macro FreeCAD : export 3MF avec contr√¥le de tessellation (LinearDeflection / AngularDeflection),
remplacement de la g√©om√©trie dans un 3MF existant, options UI et sauvegarde dans 3mfToPrint.ini.
"""

import math
import os
import zipfile
import shutil
import subprocess
import re
import fnmatch
import xml.etree.ElementTree as ET
import configparser, ast
import platform
import time

import FreeCAD
import FreeCADGui
import Mesh
import MeshPart
from PySide import QtGui, QtCore

# -------------------------
# Multilangues
# -------------------------
# R√©cup√®re la langue choisie dans les pr√©f√©rences FreeCAD
lang_pref = FreeCAD.ParamGet("User parameter:BaseApp/Preferences/General").GetString("Language")
# Conversion en code court
lang_map = {
    "French": "fr",
    "English": "en",
    "German": "de",
    "Spanish": "es"
}
lang_code = lang_map.get(lang_pref, "fr")  # fallback fran√ßais

TRANSLATIONS = {
    "fr": {
        "dlg_title": "Options d'export vers QidiStudio",
        "chk_params": "Conserver les param√®tres d'impression (profil du slicer)",
        "chk_positions": "Conserver les positions sur le plateau",
        "chk_stl": "G√©n√©rer √©galement un STL ?",
        "chk_launch": "Lancer le slicer",
        "browse": "Parcourir‚Ä¶",
        "linear_label": "Pr√©cision (LinearDeflection) entre 0.01 et 10. Haute qualit√© : 0.01",
        "angular_label": "Tol√©rance angulaire (AngularDeflection) en degr√©s (ex: 3)",
        "extra_label": "Actions externes √† ex√©cuter avant fermeture :",
        "msg_no_doc": "‚ùå Aucun document ouvert dans FreeCAD.",
        "msg_no_save": "‚ùå Le projet n'a pas encore √©t√© sauvegard√©.",
        "msg_no_sel": "‚ö†Ô∏è Aucun objet s√©lectionn√©.",
        "msg_multi_sel": "‚ö†Ô∏è S√©lection multiple non support√©e.",
        "msg_export_cancel": "‚ö†Ô∏è Export annul√© par l‚Äôutilisateur.",
        "msg_export_done": "‚úÖ Export termin√©. Le slicer n'a pas √©t√© lanc√© (option d√©coch√©e).",
    },
    "en": {
        "dlg_title": "Export options to QidiStudio",
        "chk_params": "Keep print parameters (slicer profile)",
        "chk_positions": "Keep positions on the build plate",
        "chk_stl": "Also generate an STL?",
        "chk_launch": "Launch slicer",
        "browse": "Browse‚Ä¶",
        "linear_label": "Precision (LinearDeflection) between 0.01 and 10. High quality: 0.01",
        "angular_label": "Angular tolerance (AngularDeflection) in degrees (e.g. 3)",
        "extra_label": "External actions to execute before closing:",
        "msg_no_doc": "‚ùå No document open in FreeCAD.",
        "msg_no_save": "‚ùå Project has not been saved yet.",
        "msg_no_sel": "‚ö†Ô∏è No object selected.",
        "msg_multi_sel": "‚ö†Ô∏è Multiple selection not supported.",
        "msg_export_cancel": "‚ö†Ô∏è Export cancelled by user.",
        "msg_export_done": "‚úÖ Export finished. Slicer was not launched (option unchecked).",
    }
}

tr = TRANSLATIONS.get(lang_code, TRANSLATIONS["fr"])

# -------------------------
# Constantes et configuration
# -------------------------
INI_FILE = os.path.join(os.path.dirname(__file__), "3mfToPrint.ini")
print('INI_FILE ', INI_FILE )
CENTER_X = 120
CENTER_Y = 120
CENTER_Z = 2.5   # valeur par d√©faut Qidi

if platform.system() == "Windows":
    DEFAULT_SLICER_EXE = r"C:\Program Files\QIDIStudio\qidi-studio.exe"
elif platform.system() == "Linux":
    DEFAULT_SLICER_EXE = "/usr/bin/qidi-studio"
else:
    DEFAULT_SLICER_EXE = ""

DEFAULT_LINEAR_DEFLECTION = 0.01
DEFAULT_ANGULAR_DEGREES = 3.0
DEFAULT_ANGULAR_DEFLECTION = DEFAULT_ANGULAR_DEGREES * math.pi / 180.0

EXTRA_COMMANDS = [
     (["calc.exe"], 
     "Ouvrir la calculatrice Windows ?", 
     0, 
     False),
]

# -------------------------
# Utilitaires UI / config
# -------------------------
def show_message(title, message):
    QtGui.QMessageBox.information(None, title, message)

def load_config():
    cfg = {
        "slicer_exe": DEFAULT_SLICER_EXE,
        "linear_deflection": DEFAULT_LINEAR_DEFLECTION,
        "angular_deflection": DEFAULT_ANGULAR_DEFLECTION,
    }
    config = configparser.ConfigParser()
    if os.path.exists(INI_FILE):
        try:
            config.read(INI_FILE)
            if "Settings" in config:
                s = config["Settings"]
                if "slicer_exe" in s:
                    cfg["slicer_exe"] = s.get("slicer_exe", cfg["slicer_exe"])
                if "linear_deflection" in s:
                    cfg["linear_deflection"] = float(s.get("linear_deflection", cfg["linear_deflection"]))
                if "angular_deflection_deg" in s:
                    deg = float(s.get("angular_deflection_deg", DEFAULT_ANGULAR_DEGREES))
                    cfg["angular_deflection"] = deg * math.pi / 180.0
        except Exception as e:
            print("‚ö†Ô∏è Erreur lecture ini:", e)
    return cfg
    
def load_extra_commands_from_ini(path=INI_FILE):
    cfg = configparser.ConfigParser()
    try:
        cfg.read(path, encoding="utf-8")
        if "extra_commands" in cfg and "EXTRA_COMMANDS" in cfg["extra_commands"]:
            return ast.literal_eval(cfg["extra_commands"]["EXTRA_COMMANDS"])
    except Exception as e:
        print("‚ö†Ô∏è Erreur lecture EXTRA_COMMANDS ini:", e)
    return []

EXTRA_COMMANDS = load_extra_commands_from_ini(INI_FILE) + EXTRA_COMMANDS

def save_settings(linear=None, angular_rad=None, slicer_path=None):
    angular_deg = None
    if angular_rad is not None:
        angular_deg = angular_rad * 180.0 / math.pi
    if not os.path.exists(INI_FILE):
        with open(INI_FILE, "w", encoding="utf-8") as f:
            f.write(
                "[Settings]\n"
                "# linear_deflection : pr√©cision lin√©aire (float)\n"
                "# angular_deflection_deg : tol√©rance angulaire en DEGR√âS (ex: 3.0)\n"
                f"linear_deflection = {linear if linear is not None else DEFAULT_LINEAR_DEFLECTION}\n"
                f"angular_deflection_deg = {angular_deg if angular_deg is not None else DEFAULT_ANGULAR_DEGREES}\n"
                f"slicer_exe = {slicer_path if slicer_path else ''}\n\n"
                "[extra_commands]\n"
                "EXTRA_COMMANDS = [\n"
                "# IMPORTANT :\n"
                "# - Les valeurs doivent √™tre indent√©es (au moins un espace ou une tabulation).\n"
                "# - Exemple correct :\n"
                "#     ([\"calc.exe\"], \"Ouvrir la calculatrice Windows ?\", 0, False),\n"
                "#     ([\"curl\", \"https://pijeedom/core/api/jeeApi.php?apikey=...\", \"--insecure\"], \"Turn on Q1Pro ?\", 0, True)\n"
                "# Placez ici vos commandes :\n"
                "\n"
                "\n"
                "    ]\n"
            )
        print("‚úÖ Fichier ini cr√©√© avec commentaires :", INI_FILE)
        return
    with open(INI_FILE, "r", encoding="utf-8") as f:
        lines = f.readlines()
    new_lines = []
    in_settings = False
    for line in lines:
        if line.strip().startswith("[Settings]"):
            in_settings = True
            new_lines.append(line)
            continue
        if in_settings and line.strip().startswith("[") and not line.strip().startswith("[Settings]"):
            in_settings = False
        if in_settings:
            if line.strip().startswith("linear_deflection") and linear is not None:
                new_lines.append(f"linear_deflection = {linear}\n")
                continue
            if line.strip().startswith("angular_deflection_deg") and angular_deg is not None:
                new_lines.append(f"angular_deflection_deg = {angular_deg}\n")
                continue
            if line.strip().startswith("slicer_exe") and slicer_path is not None:
                new_lines.append(f"slicer_exe = {slicer_path}\n")
                continue
        new_lines.append(line)
    with open(INI_FILE, "w", encoding="utf-8") as f:
        f.writelines(new_lines)
    print("‚úÖ Mise √† jour ini :", INI_FILE,
          "linear=", linear, "angular_deg=", angular_deg, "slicer_exe=", slicer_path)


def ask_user_options(current_slicer, current_linear, current_angular):
    dialog = QtGui.QDialog()
    dialog.setWindowTitle(tr["dlg_title"])
    dialog.setMinimumWidth(720)

    layout = QtGui.QVBoxLayout()

    # Cases principales
    chk_params = QtGui.QCheckBox(tr["chk_params"])
    chk_params.setChecked(True)
    layout.addWidget(chk_params)

    chk_positions = QtGui.QCheckBox(tr["chk_positions"])
    chk_positions.setChecked(True)
    layout.addWidget(chk_positions)

    # Nouvelle case : g√©n√©rer STL
    chk_stl = QtGui.QCheckBox(tr["chk_stl"])
    chk_stl.setChecked(False)
    layout.addWidget(chk_stl)

    # Ligne combin√©e : case "Lancer le slicer" + champ chemin
    h_slicer = QtGui.QHBoxLayout()
    chk_launch = QtGui.QCheckBox(tr["chk_launch"])
    chk_launch.setChecked(True)
    h_slicer.addWidget(chk_launch)

    edit_slicer = QtGui.QLineEdit(current_slicer or "")
    edit_slicer.setMinimumWidth(420)
    h_slicer.addWidget(edit_slicer, stretch=1)

    btn_browse = QtGui.QPushButton(tr["browse"])
    def browse():
        path, _ = QtGui.QFileDialog.getOpenFileName(dialog, tr["browse"])
        if path:
            edit_slicer.setText(path)
    btn_browse.clicked.connect(browse)
    h_slicer.addWidget(btn_browse)

    layout.addLayout(h_slicer)

    # Pr√©cision lin√©aire
    h_lin = QtGui.QHBoxLayout()
    lbl_lin = QtGui.QLabel(tr["linear_label"])
    lbl_lin.setMinimumWidth(420)
    h_lin.addWidget(lbl_lin)

    spin_lin = QtGui.QDoubleSpinBox()
    spin_lin.setRange(0.01, 10.0)
    spin_lin.setSingleStep(0.01)
    spin_lin.setDecimals(2)
    spin_lin.setMaximumWidth(80)
    try:
        spin_lin.setValue(round(float(current_linear), 2))
    except Exception:
        spin_lin.setValue(DEFAULT_LINEAR_DEFLECTION)
    h_lin.addWidget(spin_lin)
    h_lin.addStretch()
    layout.addLayout(h_lin)

    # Tol√©rance angulaire
    h_ang = QtGui.QHBoxLayout()
    lbl_ang = QtGui.QLabel(tr["angular_label"])
    lbl_ang.setMinimumWidth(420)
    h_ang.addWidget(lbl_ang)

    spin_ang = QtGui.QDoubleSpinBox()
    spin_ang.setRange(1.0, 90.0)
    spin_ang.setSingleStep(1.0)
    spin_ang.setDecimals(1)
    spin_ang.setMaximumWidth(80)
    try:
        deg = float(current_angular) * 180.0 / math.pi
        spin_ang.setValue(deg)
    except Exception:
        spin_ang.setValue(DEFAULT_ANGULAR_DEGREES)
    h_ang.addWidget(spin_ang)
    h_ang.addStretch()
    layout.addLayout(h_ang)

    # Cases pour les commandes externes
    extra_checks = []
    if EXTRA_COMMANDS:
        layout.addWidget(QtGui.QLabel(tr["extra_label"]))
    for cmd, label, delay, default in EXTRA_COMMANDS:
        chk = QtGui.QCheckBox(label)
        chk.setChecked(default)
        layout.addWidget(chk)
        extra_checks.append((chk, cmd, delay))

    # Boutons OK/Annuler
    btns = QtGui.QDialogButtonBox(QtGui.QDialogButtonBox.Ok | QtGui.QDialogButtonBox.Cancel)
    layout.addWidget(btns)
    dialog.setLayout(layout)

    btns.accepted.connect(dialog.accept)
    btns.rejected.connect(dialog.reject)

    if dialog.exec() == QtGui.QDialog.Accepted:
        linear_val = float(spin_lin.value())
        angular_deg = float(spin_ang.value())
        angular_rad = angular_deg * math.pi / 180.0
        return (
            chk_params.isChecked(),
            chk_positions.isChecked(),
            chk_stl.isChecked(),
            edit_slicer.text(),
            chk_launch.isChecked(),
            linear_val,
            angular_rad,
            [(chk.isChecked(), cmd, delay) for chk, cmd, delay in extra_checks]
        )
    else:
        return (None, None, None, None, None, None, None, [])

def find_geom_file_in_3mf(three_mf_path):
    """Retourne le nom du fichier de g√©om√©trie principal dans un 3MF.
    Cherche dans le zip un fichier sous '3D/Objects/' ou '3D/3dmodel.model'."""
    try:
        with zipfile.ZipFile(three_mf_path, 'r') as zf:
            for name in zf.namelist():
                # Fichiers de g√©om√©trie typiques
                if name.startswith("3D/Objects/") and name.endswith(".model"):
                    return name
                if name.endswith("3dmodel.model"):
                    return name
    except Exception as e:
        print("‚ö†Ô∏è Erreur lecture 3MF:", e)
    return None




def recenter_vertices(model_data, center=(CENTER_X, CENTER_Y, CENTER_Z)):
    """Recentre les sommets d'un fichier .model (XML) autour du centre donn√©.
    Retourne les donn√©es modifi√©es (bytes)."""
    try:
        root = ET.fromstring(model_data)
        # Les sommets sont dans des balises <vertex x=".." y=".." z=".."/>
        vertices = root.findall(".//vertex")
        if not vertices:
            return model_data  # rien √† modifier

        xs = [float(v.attrib["x"]) for v in vertices]
        ys = [float(v.attrib["y"]) for v in vertices]
        zs = [float(v.attrib["z"]) for v in vertices]

        # Calcul du barycentre
        cx = sum(xs) / len(xs)
        cy = sum(ys) / len(ys)
        cz = sum(zs) / len(zs)

        dx = center[0] - cx
        dy = center[1] - cy
        dz = center[2] - cz

        # Application du d√©calage
        for v in vertices:
            v.set("x", str(float(v.attrib["x"]) + dx))
            v.set("y", str(float(v.attrib["y"]) + dy))
            v.set("z", str(float(v.attrib["z"]) + dz))

        return ET.tostring(root, encoding="utf-8")
    except Exception as e:
        print("‚ö†Ô∏è Erreur recenter_vertices:", e)
        return model_data

def reset_item_transform(model_data, center=(CENTER_X, CENTER_Y, CENTER_Z)):
    """R√©initialise la transformation d'un item .model pour le replacer au centre donn√©.
    Retourne les donn√©es modifi√©es (bytes)."""
    try:
        root = ET.fromstring(model_data)
        # Les matrices de transformation sont dans des balises <transform ...>
        transforms = root.findall(".//transform")
        for t in transforms:
            # On force une translation vers le centre et on remet la rotation √† l'identit√©
            t.set("translation", f"{center[0]} {center[1]} {center[2]}")
            t.set("rotation", "0 0 0 1")  # quaternion identit√©
        return ET.tostring(root, encoding="utf-8")
    except Exception as e:
        print("‚ö†Ô∏è Erreur reset_item_transform:", e)
        return model_data



def export_selection_with_deflection(selection, out_3mf_path,
                                     linear_deflection=DEFAULT_LINEAR_DEFLECTION,
                                     angular_deflection=DEFAULT_ANGULAR_DEFLECTION):
    """Exporte la s√©lection FreeCAD en 3MF avec d√©flection donn√©e.
    Entr√©es: selection (objets FreeCAD), fc_3mf (str chemin), 
    linear_deflection (float), angular_deflection (float).
    Sorties: fichier .3mf g√©n√©r√©."""
    doc = FreeCAD.ActiveDocument
    temp_objs = []
    try:
        for obj in selection:
            mesh = MeshPart.meshFromShape(
                Shape=obj.Shape,
                LinearDeflection=float(linear_deflection),
                AngularDeflection=float(angular_deflection)
            )
            mobj = doc.addObject("Mesh::Feature", f"TempMesh_{obj.Name}")
            mobj.Mesh = mesh
            temp_objs.append(mobj)
        doc.recompute()
        Mesh.export(temp_objs, out_3mf_path)
    finally:
        for t in temp_objs:
            try:
                doc.removeObject(t.Name)
            except Exception:
                pass
        doc.recompute()


def export_replace_geometry():
    """Routine principale: exporte projet FreeCAD en .3mf, 
    remplace g√©om√©trie Qidi par celle de FreeCAD,
    applique options (recentrage, positions, params), lance slicer et 
    commandes externes. Peut aussi g√©n√©rer un STL si demand√©."""
    cfg = load_config()
    doc = FreeCAD.ActiveDocument
    if not doc:
        show_message("Erreur", tr["msg_no_doc"])
        return

    fcstd_path = doc.FileName
    if not fcstd_path:
        show_message("Erreur", tr["msg_no_save"])
        return

    base_name = os.path.splitext(fcstd_path)[0]
    fc_3mf = base_name + ".3mf"
    old_3mf = base_name + ".old.3mf"

    if os.path.exists(fc_3mf):
        try:
            shutil.move(fc_3mf, old_3mf)
        except Exception:
            pass

    selection = FreeCADGui.Selection.getSelection()
    if not selection:
        show_message("Avertissement", tr["msg_no_sel"])
        return
    if len(selection) > 1:
        show_message("Avertissement", tr["msg_multi_sel"])
        return

    slicer_path_pref = cfg.get("slicer_exe", DEFAULT_SLICER_EXE)
    linear_pref = cfg.get("linear_deflection", DEFAULT_LINEAR_DEFLECTION)
    angular_pref = cfg.get("angular_deflection", DEFAULT_ANGULAR_DEFLECTION)

    keep_params, keep_positions, generate_stl, slicer_path, launch_slicer, linear_value, angular_value, extra_cmds = \
        ask_user_options(slicer_path_pref, linear_pref, angular_pref)

    if slicer_path is None and launch_slicer is None:
        show_message("Info", tr["msg_export_cancel"])
        if os.path.exists(old_3mf) and not os.path.exists(fc_3mf):
            try:
                shutil.move(old_3mf, fc_3mf)
            except Exception:
                pass
        return

    save_settings(linear=linear_value, angular_rad=angular_value)
    print("‚úÖ Valeurs sauvegard√©es :", linear_value, angular_value)

    try:
        export_selection_with_deflection(selection, fc_3mf,
                                         linear_deflection=linear_value,
                                         angular_deflection=angular_value)
    except Exception as e:
        show_message("Erreur", f"‚ùå Erreur lors de l'export 3MF : {e}")
        if os.path.exists(old_3mf) and not os.path.exists(fc_3mf):
            try:
                shutil.move(old_3mf, fc_3mf)
            except Exception:
                pass
        return

    print("Exportation FreeCAD termin√©e :", fc_3mf)

    # üîß G√©n√©ration STL si demand√©
    if generate_stl:
        stl_path = base_name + ".stl"
        try:
            Mesh.export(selection, stl_path)
            print("‚úÖ STL g√©n√©r√© :", stl_path)
        except Exception as e:
            show_message("Erreur", f"‚ùå Erreur lors de la g√©n√©ration du STL : {e}")

    # --- suite logique de remplacement g√©om√©trie ---
    if os.path.exists(old_3mf):
        geom_entry = find_geom_file_in_3mf(fc_3mf)
        if not geom_entry:
            show_message("Erreur", "‚ùå Aucun fichier de g√©om√©trie d√©tect√© dans le 3MF export√©.")
            return
        with zipfile.ZipFile(fc_3mf, 'r') as fc_zip:
            geom_data = fc_zip.read(geom_entry)

        tmp_new = base_name + ".new.3mf"

        try:
            with zipfile.ZipFile(old_3mf, 'r') as old_zip, zipfile.ZipFile(tmp_new, 'w') as new_zip:
                for item in old_zip.infolist():
                    data = old_zip.read(item.filename)
                    if item.filename.startswith("3D/Objects/") and item.filename.endswith(".model"):
                        geom_data_centered = recenter_vertices(geom_data)
                        new_zip.writestr(item.filename, geom_data_centered)
                    elif item.filename.endswith("3dmodel.model"):
                        if not keep_positions:
                            data = reset_item_transform(data, center=(CENTER_X, CENTER_Y, CENTER_Z))
                        new_zip.writestr(item.filename, data)
                    elif not keep_params and item.filename.startswith("Metadata/"):
                        continue
                    else:
                        new_zip.writestr(item, data)
        except Exception as e:
            show_message("Erreur", f"‚ùå Erreur lors de la cr√©ation du 3MF final : {e}")
            return

        try:
            if os.path.exists(fc_3mf):
                os.remove(fc_3mf)
        except Exception:
            pass
        try:
            shutil.move(tmp_new, fc_3mf)
        except Exception as e:
            show_message("Erreur", f"‚ùå Impossible de remplacer le 3MF : {e}")
            return
        try:
            if os.path.exists(old_3mf):
                os.remove(old_3mf)
        except Exception:
            pass

        print("‚úÖ G√©om√©trie FreeCAD inject√©e et options appliqu√©es :", fc_3mf)

        if launch_slicer and slicer_path and os.path.exists(slicer_path):
            try:
                subprocess.Popen([slicer_path, fc_3mf])
            except Exception as e:
                show_message("Erreur", f"‚ùå Erreur lors du lancement du slicer : {e}")
        else:
            if not launch_slicer:
                show_message("Info", tr["msg_export_done"])

        if slicer_path and os.path.exists(slicer_path):
            try:
                save_settings(slicer_path=slicer_path)
            except Exception:
                pass
    else:
        print("‚úÖ Fichier g√©n√©r√© uniquement par FreeCAD :", fc_3mf)

    for checked, cmd, delay in extra_cmds:
        if checked:
            try:
                if delay > 0:
                    time.sleep(delay)
                subprocess.Popen(cmd)
                print("‚úÖ Commande externe ex√©cut√©e :", cmd[0])
            except Exception as e:
                show_message("Erreur", f"‚ùå Impossible d'ex√©cuter la commande externe : {e}")


# Lancement automatique
if __name__ == "__main__":
    export_replace_geometry()
