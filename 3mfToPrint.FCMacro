# -*- coding: utf-8 -*-
"""
Macro FreeCAD multilingue : export 3MF/STL avec contr√¥le de tessellation,
conservation des param√®tres du slicer, ouverture automatique du slicer,
et d√©clenchement de commandes externes (domotique).
"""

import math, os, zipfile, shutil, subprocess, re, fnmatch, xml.etree.ElementTree as ET
import configparser, ast, platform, time
import FreeCAD, FreeCADGui, Mesh, MeshPart
from PySide import QtGui, QtCore

# -------------------------
# Constantes et configuration
# -------------------------
INI_FILE = os.path.join(os.path.dirname(__file__), "3mfToPrint.ini")
CENTER_X, CENTER_Y, CENTER_Z = 120, 120, 2.5

if platform.system() == "Windows":
    DEFAULT_SLICER_EXE = r"C:\Program Files\QIDIStudio\qidi-studio.exe"
elif platform.system() == "Linux":
    DEFAULT_SLICER_EXE = "/usr/bin/qidi-studio"
else:
    DEFAULT_SLICER_EXE = ""

DEFAULT_LINEAR_DEFLECTION = 0.01
DEFAULT_ANGULAR_DEGREES = 3.0
DEFAULT_ANGULAR_DEFLECTION = DEFAULT_ANGULAR_DEGREES * math.pi / 180.0

EXTRA_COMMANDS = [
    #(["calc.exe"], "Ouvrir la calculatrice Windows ?", 0, False),
    #(["curl", "-u", "admin:motDePass", "--insecure",
    #  "http://IpDeLaPriseShelly/rpc/Switch.Set?id=0&on=true"],
    #  "Allumer la prise Shelly Gen2 ?", 0, False),
]


     
     

# Charge les commandes externes d√©finies dans le fichier ini
def load_extra_commands_from_ini(path=INI_FILE):
    cfg = configparser.ConfigParser()
    try:
        cfg.read(path, encoding="utf-8")
        if "extra_commands" in cfg and "EXTRA_COMMANDS" in cfg["extra_commands"]:
            return ast.literal_eval(cfg["extra_commands"]["EXTRA_COMMANDS"])
    except Exception as e:
        print("‚ö†Ô∏è Erreur lecture EXTRA_COMMANDS ini:", e)
    return []

# Fusion au d√©marrage : commandes ini avant celles cod√©es en dur
EXTRA_COMMANDS = load_extra_commands_from_ini(INI_FILE) + EXTRA_COMMANDS



# -------------------------
# Traductions multilingues
# -------------------------
TRANSLATIONS = {
    "fr": {
        # Titres
        "error_title": "Erreur",
        "warn_title": "Avertissement",
        "info_title": "Info",

        # Options UI
        "options_title": "Options d'export vers QidiStudio",
        "keep_params": "Conserver les param√®tres d'impression (profil du slicer)",
        "keep_positions": "Conserver les positions sur le plateau",
        "generate_stl": "En plus du .3mf, g√©n√©rer √©galement un STL",
        "launch_slicer": "Lancer le slicer",
        "browse": "Parcourir‚Ä¶",
        "linear_label": "Pr√©cision (LinearDeflection) entre 0.01 et 10. Haute qualit√© : 0.01",
        "angular_label": "Tol√©rance angulaire (AngularDeflection) en degr√©s (ex: 3)",
        "external_actions": "Actions externes √† ex√©cuter avant fermeture :",

        # Messages d'erreur / avertissement
        "error_no_doc": "‚ùå Aucun document ouvert dans FreeCAD.",
        "error_no_save": "‚ùå Le projet n'a pas encore √©t√© sauvegard√©.",
        "warn_no_selection": "‚ö†Ô∏è Aucun objet s√©lectionn√©.",
        "warn_multi_selection": "‚ö†Ô∏è S√©lection multiple non support√©e.",
        "error_write_ini": "‚ùå √âcriture impossible sur le fichier ini :",
        "error_export_3mf": "‚ùå Erreur lors de l'export 3MF :",
        "error_generate_stl": "‚ùå Erreur lors de la g√©n√©ration du STL :",
        "error_create_3mf": "‚ùå Erreur lors de la cr√©ation du 3MF final :",
        "error_replace_3mf": "‚ùå Impossible de remplacer le 3MF :",
        "error_launch_slicer": "‚ùå Erreur lors du lancement du slicer :",
        "error_external_cmd": "‚ùå Impossible d'ex√©cuter la commande externe :",
        "error_no_geom": "‚ùå Aucun fichier de g√©om√©trie d√©tect√© dans le 3MF export√©.",
        "error_invalid_slicer": "‚ùå Le chemin du slicer est invalide :",

        # Infos
        "info_cancel": "‚ö†Ô∏è Export annul√© par l‚Äôutilisateur.",
        "info_done": "‚úÖ Export termin√©. Le slicer n'a pas √©t√© lanc√© (option d√©coch√©e).",
        "info_export_fc": "‚úÖ Fichier g√©n√©r√© uniquement par FreeCAD :",
        "info_export_slicer": "‚úÖ Export avec r√©cup√©ration des param√®tres du slicer :",

        # Aides / tooltips
        "hint_linear": "Valeur plus petite = maillage plus fin.\nExemple : 0.01 = haute qualit√©, mais fichier lourd.\n"
                       "Exemple : 0.1 = adapt√© √† une imprimante FDM classique.",
        "hint_angular": "Tol√©rance angulaire en degr√©s.\nPetite valeur = plus de d√©tails, mais fichier plus lourd.",
        "hint_positions": "Conserve la position XY sur le plateau.\n‚ö†Ô∏è Le Z est toujours recalcul√© pour √©viter que l'objet soit sous le plateau.",
        "no_external_actions": "Pas encore de commandes utilisateurs ajout√©es.",
        "hint_external_actions": "Vous pouvez ajouter vos propres actions dans le fichier ini, section [extra_commands].\n"
                                 "Chaque commande peut √™tre configur√©e avec d√©lai et activation par case √† cocher.",
        "hint_keep_params": "Conserve les param√®tres du slicer (profil d'impression).",
        "hint_generate_stl": "G√©n√®re aussi un fichier STL en plus du 3MF.",
        "hint_launch_slicer": "Lance automatiquement le slicer apr√®s export si le chemin est valide.",
    },

    "en": {
        # Titles
        "error_title": "Error",
        "warn_title": "Warning",
        "info_title": "Info",

        # UI options
        "options_title": "Export options to QidiStudio",
        "keep_params": "Keep printing parameters (slicer profile)",
        "keep_positions": "Keep positions on the build plate",
        "generate_stl": "Also generate an STL along with the .3mf",
        "launch_slicer": "Launch slicer",
        "browse": "Browse‚Ä¶",
        "linear_label": "Precision (LinearDeflection) between 0.01 and 10. High quality: 0.01",
        "angular_label": "Angular tolerance (AngularDeflection) in degrees (e.g. 3)",
        "external_actions": "External actions to execute before closing:",

        # Error / warning messages
        "error_no_doc": "‚ùå No document open in FreeCAD.",
        "error_no_save": "‚ùå The project has not been saved yet.",
        "warn_no_selection": "‚ö†Ô∏è No object selected.",
        "warn_multi_selection": "‚ö†Ô∏è Multiple selection not supported.",
        "error_write_ini": "‚ùå Unable to write to ini file:",
        "error_export_3mf": "‚ùå Error during 3MF export:",
        "error_generate_stl": "‚ùå Error during STL generation:",
        "error_create_3mf": "‚ùå Error while creating final 3MF:",
        "error_replace_3mf": "‚ùå Unable to replace 3MF:",
        "error_launch_slicer": "‚ùå Error while launching slicer:",
        "error_external_cmd": "‚ùå Unable to execute external command:",
        "error_no_geom": "‚ùå No geometry file detected in exported 3MF.",
        "error_invalid_slicer": "‚ùå Invalid slicer path:",

        # Infos
        "info_cancel": "‚ö†Ô∏è Export cancelled by user.",
        "info_done": "‚úÖ Export finished. Slicer was not launched (option unchecked).",
        "info_export_fc": "‚úÖ File generated only by FreeCAD:",
        "info_export_slicer": "‚úÖ Export with slicer parameters recovered:",

        # Tooltips
        "hint_linear": "Smaller value = finer mesh.\nExample: 0.01 = high quality but heavy file.\n"
                       "Example: 0.1 = suitable for standard FDM printer.",
        "hint_angular": "Angular tolerance in degrees.\nSmaller value = more detail, but heavier file.",
        "hint_positions": "Keeps XY position on the build plate.\n‚ö†Ô∏è Z is always recalculated to avoid sinking below the plate.",
        "no_external_actions": "No user commands added yet.",
        "hint_external_actions": "You can add your own actions in the ini file, section [extra_commands].\n"
                                 "Each command can be configured with delay and checkbox activation.",
        "hint_keep_params": "Keeps slicer parameters (printing profile).",
        "hint_generate_stl": "Also generates an STL file along with the 3MF.",
        "hint_launch_slicer": "Automatically launches the slicer after export if the path is valid.",
    }
}


# D√©termine la langue de l‚Äôutilisateur √† partir de FreeCADGui
def get_user_language():
    try:
        locale = FreeCADGui.getLocale().lower()
        # Normalisation
        if locale.startswith("fr") or "french" in locale:
            return "fr"
        if locale.startswith("en") or "english" in locale:
            return "en"
        '''
        if locale.startswith("de") or "german" in locale:
            return "de"
        if locale.startswith("es") or "spanish" in locale:
            return "es"
        if locale.startswith("it") or "italian" in locale:
            return "it"
        '''    
        # Fallback
        return "en"
    except Exception:
        return "en"



# Traduit une cl√© donn√©e selon la langue utilisateur
def tr(key):
    lang = get_user_language()
    return TRANSLATIONS.get(lang, TRANSLATIONS["en"]).get(key, key)



# -------------------------
# Utilitaires UI / config
# -------------------------
# Affiche une bo√Æte de message d‚Äôinformation dans FreeCAD
def show_message(title, message):
    QtGui.QMessageBox.information(None, title, message)

# Charge la configuration (slicer, d√©flections) depuis le fichier ini
def load_config():
    cfg = {
        "slicer_exe": DEFAULT_SLICER_EXE,
        "linear_deflection": DEFAULT_LINEAR_DEFLECTION,
        "angular_deflection": DEFAULT_ANGULAR_DEFLECTION,
    }
    config = configparser.ConfigParser()
    if os.path.exists(INI_FILE):
        try:
            config.read(INI_FILE)
            if "Settings" in config:
                s = config["Settings"]
                if "slicer_exe" in s:
                    cfg["slicer_exe"] = s.get("slicer_exe", cfg["slicer_exe"])
                if "linear_deflection" in s:
                    cfg["linear_deflection"] = float(s.get("linear_deflection", cfg["linear_deflection"]))
                if "angular_deflection_deg" in s:
                    deg = float(s.get("angular_deflection_deg", DEFAULT_ANGULAR_DEGREES))
                    cfg["angular_deflection"] = deg * math.pi / 180.0
        except Exception as e:
            print("‚ö†Ô∏è Erreur lecture ini:", e)
    return cfg

# Sauvegarde les param√®tres (d√©flections, chemin slicer) dans le fichier ini
def save_settings(linear, angular_rad, slicer_path):
    angular_deg = None
    if angular_rad is not None:
        angular_deg = angular_rad * 180.0 / math.pi

    # Cr√©ation initiale avec commentaires si le fichier n'existe pas
    if not os.path.exists(INI_FILE):
        with open(INI_FILE, "w", encoding="utf-8") as f:
            f.write(
                "[Settings]\n"
                "# linear_deflection : pr√©cision lin√©aire (float)\n"
                "# angular_deflection_deg : tol√©rance angulaire en DEGR√âS (ex: 3.0)\n"
                "# slicer_exe : chemin vers l'ex√©cutable du slicer\n"
                f"linear_deflection = {linear}\n"
                f"angular_deflection_deg = {angular_deg}\n"
                f"slicer_exe = {slicer_path}\n\n"
                "[extra_commands]\n"
                "EXTRA_COMMANDS = [\n"
                "    ]\n"
            )
        return


    # Mise √† jour cibl√©e de [Settings] si le fichier existe d√©j√†
    with open(INI_FILE, "r", encoding="utf-8") as f:
        lines = f.readlines()

    new_lines = []
    in_settings = False
    for line in lines:
        if line.strip().startswith("[Settings]"):
            in_settings = True
            new_lines.append(line)
            continue
        if in_settings and line.strip().startswith("[") and not line.strip().startswith("[Settings]"):
            in_settings = False
        if in_settings:
            if line.strip().startswith("linear_deflection") and linear is not None:
                new_lines.append(f"linear_deflection = {linear}\n")
                continue
            if line.strip().startswith("angular_deflection_deg") and angular_deg is not None:
                new_lines.append(f"angular_deflection_deg = {angular_deg}\n")
                continue
            if line.strip().startswith("slicer_exe") and slicer_path is not None:
                new_lines.append(f"slicer_exe = {slicer_path}\n")
                continue
        new_lines.append(line)

    with open(INI_FILE, "w", encoding="utf-8") as f:
        f.writelines(new_lines)

# -------------------------
# Interface utilisateur
# -------------------------
# Affiche une bo√Æte de dialogue pour demander les options d‚Äôexport √† l‚Äôutilisateur
def ask_user_options(current_slicer, current_linear, current_angular):
    """Affiche bo√Æte de dialogue pour options export (positions, params, STL, slicer, deflection)."""
    dialog = QtGui.QDialog()
    dialog.setWindowTitle(tr("options_title"))
    dialog.setMinimumWidth(720)

    layout = QtGui.QVBoxLayout()

    # Cases principales
    chk_params = QtGui.QCheckBox(tr("keep_params"))
    chk_params.setToolTip(tr("hint_keep_params"))
    chk_params.setChecked(True)
    layout.addWidget(chk_params)

    chk_positions = QtGui.QCheckBox(tr("keep_positions"))
    chk_positions.setToolTip(tr("hint_positions"))
    chk_positions.setChecked(True)
    layout.addWidget(chk_positions)

    chk_stl = QtGui.QCheckBox(tr("generate_stl"))
    chk_stl.setToolTip(tr("hint_generate_stl"))
    chk_stl.setChecked(False)
    layout.addWidget(chk_stl)

    # Ligne combin√©e : case "Lancer le slicer" + champ chemin
    h_slicer = QtGui.QHBoxLayout()
    chk_launch = QtGui.QCheckBox(tr("launch_slicer"))
    chk_launch.setToolTip(tr("hint_launch_slicer"))
    chk_launch.setChecked(True)
    h_slicer.addWidget(chk_launch)

    edit_slicer = QtGui.QLineEdit(current_slicer or "")
    edit_slicer.setMinimumWidth(420)
    h_slicer.addWidget(edit_slicer, stretch=1)

    btn_browse = QtGui.QPushButton(tr("browse"))
    def browse():
        path, _ = QtGui.QFileDialog.getOpenFileName(dialog, tr("browse"))
        if path:
            edit_slicer.setText(path)
    btn_browse.clicked.connect(browse)
    h_slicer.addWidget(btn_browse)
    layout.addLayout(h_slicer)

    # Pr√©cision lin√©aire
    h_lin = QtGui.QHBoxLayout()
    lbl_lin = QtGui.QLabel(tr("linear_label"))
    lbl_lin.setMinimumWidth(420)
    h_lin.addWidget(lbl_lin)

    spin_lin = QtGui.QDoubleSpinBox()
    spin_lin.setToolTip(tr("hint_linear"))
    spin_lin.setRange(0.01, 10.0)
    spin_lin.setSingleStep(0.01)
    spin_lin.setDecimals(2)
    spin_lin.setMaximumWidth(80)
    try:
        spin_lin.setValue(round(float(current_linear), 2))
    except Exception:
        spin_lin.setValue(DEFAULT_LINEAR_DEFLECTION)
    h_lin.addWidget(spin_lin)
    h_lin.addStretch()
    layout.addLayout(h_lin)

    # Tol√©rance angulaire
    h_ang = QtGui.QHBoxLayout()
    lbl_ang = QtGui.QLabel(tr("angular_label"))
    lbl_ang.setMinimumWidth(420)
    h_ang.addWidget(lbl_ang)

    spin_ang = QtGui.QDoubleSpinBox()
    spin_ang.setToolTip(tr("hint_angular"))
    spin_ang.setRange(1.0, 90.0)
    spin_ang.setSingleStep(1.0)
    spin_ang.setDecimals(1)
    spin_ang.setMaximumWidth(80)
    try:
        deg = float(current_angular) * 180.0 / math.pi
        spin_ang.setValue(deg)
    except Exception:
        spin_ang.setValue(DEFAULT_ANGULAR_DEGREES)
    h_ang.addWidget(spin_ang)
    h_ang.addStretch()
    layout.addLayout(h_ang)

    # Cases pour les commandes externes
    extra_checks = []
    if EXTRA_COMMANDS:
        lbl_ext = QtGui.QLabel(tr("external_actions"))
        lbl_ext.setToolTip(tr("hint_external_actions") + f"\n\nFichier ini : {INI_FILE}")
        layout.addWidget(lbl_ext)
        for cmd, label, delay, default in EXTRA_COMMANDS:
            chk = QtGui.QCheckBox(label)
            chk.setChecked(default)
            layout.addWidget(chk)
            extra_checks.append((chk, cmd, delay))
    else:
        # üëâ Afficher un libell√© m√™me si aucune commande n'est d√©finie
        lbl_ext = QtGui.QLabel(tr("no_external_actions"))
        lbl_ext.setToolTip(tr("hint_external_actions") + f"\n\nFichier ini : {INI_FILE}")
        layout.addWidget(lbl_ext)


    # Boutons OK/Annuler
    btns = QtGui.QDialogButtonBox(QtGui.QDialogButtonBox.Ok | QtGui.QDialogButtonBox.Cancel)
    layout.addWidget(btns)
    dialog.setLayout(layout)

    btns.accepted.connect(dialog.accept)
    btns.rejected.connect(dialog.reject)

    if dialog.exec() == QtGui.QDialog.Accepted:
        linear_val = float(spin_lin.value())
        angular_deg = float(spin_ang.value())
        angular_rad = angular_deg * math.pi / 180.0
        return (
            chk_params.isChecked(),
            chk_positions.isChecked(),
            chk_stl.isChecked(),
            edit_slicer.text(),
            chk_launch.isChecked(),
            linear_val,
            angular_rad,
            [(chk.isChecked(), cmd, delay) for chk, cmd, delay in extra_checks]
        )
    else:
        return (None, None, None, None, None, None, None, [])

# -------------------------
# Fonctions de traitement 3MF / mesh
# -------------------------
# Recherche le fichier de g√©om√©trie principal dans une archive 3MF
def find_geom_file_in_3mf(zip_path):
    with zipfile.ZipFile(zip_path, 'r') as z:
        rels_name = "_rels/.rels"
        if rels_name in z.namelist():
            try:
                rels_text = z.read(rels_name).decode("utf-8")
                root = ET.fromstring(rels_text)
                for rel in root:
                    if rel.tag.endswith("Relationship"):
                        rtype = rel.attrib.get("Type", "")
                        if rtype.endswith("3dmodel"):
                            target = rel.attrib.get("Target")
                            if target and target.startswith("/"):
                                target = target[1:]
                            if target in z.namelist():
                                return target
            except Exception:
                pass
        for name in z.namelist():
            if fnmatch.fnmatch(name, "3D/Objects/*.model"):
                return name
        if "3D/3dmodel.model" in z.namelist():
            return "3D/3dmodel.model"
    return None

# R√©initialise la transformation des items en les centrant sur un point donn√©
def reset_item_transform(model_data, center=(CENTER_X, CENTER_Y, CENTER_Z)):
    text = model_data.decode("utf-8")
    new_transform = f'transform="1 0 0 0 1 0 0 0 1 {center[0]} {center[1]} {center[2]}"'
    text = re.sub(r'(<item[^>]*?)\s+transform="[^"]+"', r'\1 ' + new_transform, text)
    return text.encode("utf-8")

# Exporte une s√©lection en STL avec param√®tres de tessellation    
def export_stl_with_deflection(selection, stl_path,
                               linear_deflection=DEFAULT_LINEAR_DEFLECTION,
                               angular_deflection=DEFAULT_ANGULAR_DEFLECTION):
    doc = FreeCAD.ActiveDocument
    temp_objs = []
    try:
        for obj in selection:
            mesh = MeshPart.meshFromShape(
                Shape=obj.Shape,
                LinearDeflection=float(linear_deflection),
                AngularDeflection=float(angular_deflection)
            )
            mobj = doc.addObject("Mesh::Feature", f"TempMeshSTL_{obj.Name}")
            mobj.Mesh = mesh
            temp_objs.append(mobj)
        doc.recompute()
        Mesh.export(temp_objs, stl_path)
    finally:
        for t in temp_objs:
            try: doc.removeObject(t.Name)
            except Exception: pass
        doc.recompute()

# Exporte une s√©lection en 3MF avec param√®tres de tessellation
def export_selection_with_deflection(selection, out_3mf_path,
                                     linear_deflection=DEFAULT_LINEAR_DEFLECTION,
                                     angular_deflection=DEFAULT_ANGULAR_DEFLECTION):
    doc = FreeCAD.ActiveDocument
    temp_objs = []
    try:
        for obj in selection:
            mesh = MeshPart.meshFromShape(
                Shape=obj.Shape,
                LinearDeflection=float(linear_deflection),
                AngularDeflection=float(angular_deflection))
            mobj = doc.addObject("Mesh::Feature", f"TempMesh_{obj.Name}")
            mobj.Mesh = mesh
            temp_objs.append(mobj)
        doc.recompute()
        Mesh.export(temp_objs, out_3mf_path)
    finally:
        for t in temp_objs:
            try: doc.removeObject(t.Name)
            except Exception: pass
        doc.recompute()


# Force uniquement la composante Z des transformations dans le mod√®le 3MF
def force_zmax_in_transform(model_data, zmax):
    """
    Remplace uniquement la composante Z (12e valeur) du transform des <item> dans 3dmodel.model.
    - Conserve X/Y et la matrice de rotation/√©chelle.
    - zmax est un float (hauteur max des vertex) calcul√© par recenter_vertices.

    Si plusieurs <item> existent, on les met tous √† jour.
    """
    try:
        text = model_data.decode("utf-8")

        def repl(m):
            nums = m.group(1).split()
            # transform = 12 nombres : 9 pour la matrice, 3 pour la translation (X, Y, Z)
            if len(nums) == 12:
                nums[-1] = f"{zmax}"
                return 'transform="' + " ".join(nums) + '"'
            # Si format inattendu, on ne modifie pas
            return m.group(0)

        # Met √† jour tous les transform="..."; count=0 = sans limite
        text = re.sub(r'transform="([^"]+)"', repl, text, count=0)
        return text.encode("utf-8")
    except Exception as e:
        print("‚ö†Ô∏è force_zmax_in_transform: √©chec, on garde le transform d'origine :", e)
        return model_data


# Recentre les sommets en XY et calcule le Zmax pour placement correct
def recenter_vertices(model_data):
    """
    Recentrage des vertex en X/Y et calcul du Zmax pour placement correct sur le plateau.
    Retourne : (donn√©es XML modifi√©es, zmax)
    """
    try:
        ET.register_namespace('', "http://schemas.microsoft.com/3dmanufacturing/core/2015/02")
        root = ET.fromstring(model_data.decode("utf-8"))
        ns = {"ns": "http://schemas.microsoft.com/3dmanufacturing/core/2015/02"}
        verts = root.findall(".//ns:vertex", ns)

        xs = [float(v.attrib["x"]) for v in verts]
        ys = [float(v.attrib["y"]) for v in verts]
        zs = [float(v.attrib["z"]) for v in verts]

        # Calcul du centre XY et du Zmax
        xc, yc = (min(xs) + max(xs)) / 2.0, (min(ys) + max(ys)) / 2.0
        zmax = max(zs)

        # Recentrage XY
        for v in verts:
            v.attrib["x"] = str(float(v.attrib["x"]) - xc)
            v.attrib["y"] = str(float(v.attrib["y"]) - yc)

        return ET.tostring(root, encoding="utf-8", xml_declaration=False), zmax
    except Exception as e:
        print("‚ö†Ô∏è Erreur recentrage vertex :", e)
        return model_data, CENTER_Z

# -------------------------
# Routine principale
# -------------------------
# Routine principale : exporte la s√©lection en 3MF/STL, injecte g√©om√©trie, 
# lance slicer et commandes externes

    
def export_replace_geometry():
    cfg = load_config()
    doc = FreeCAD.ActiveDocument
    if not doc:
        show_message(tr("error_title"), tr("error_no_doc"))
        return

    fcstd_path = doc.FileName
    if not fcstd_path:
        show_message(tr("error_title"), tr("error_no_save"))
        return

    base_name = os.path.splitext(fcstd_path)[0]
    fc_3mf = base_name + ".3mf"
    old_3mf = base_name + ".old.3mf"

    # Sauvegarde de l'ancien 3MF si pr√©sent
    if os.path.exists(fc_3mf):
        try:
            shutil.move(fc_3mf, old_3mf)
        except Exception:
            pass

    # V√©rification de la s√©lection
    selection = FreeCADGui.Selection.getSelection()
    selection = [obj for obj in selection if hasattr(obj, "Shape") and obj.Shape is not None]

    if not selection:
        show_message(tr("warn_title"), tr("warn_no_selection"))
        return
    if len(selection) > 1:
        show_message(tr("warn_title"), tr("warn_multi_selection"))
        return

    # Chargement des pr√©f√©rences
    slicer_path_pref = cfg.get("slicer_exe", DEFAULT_SLICER_EXE)
    linear_pref = cfg.get("linear_deflection", DEFAULT_LINEAR_DEFLECTION)
    angular_pref = cfg.get("angular_deflection", DEFAULT_ANGULAR_DEFLECTION)

    # üîé Boucle de dialogue avec contr√¥le du chemin slicer
    while True:
        keep_params, keep_positions, generate_stl, slicer_path, launch_slicer, linear_value, angular_value, extra_cmds = \
            ask_user_options(slicer_path_pref, linear_pref, angular_pref)

        # Si l‚Äôutilisateur annule ‚Üí sortie
        if slicer_path is None and launch_slicer is None:
            show_message(tr("info_title"), tr("info_cancel"))
            if os.path.exists(old_3mf) and not os.path.exists(fc_3mf):
                try:
                    shutil.move(old_3mf, fc_3mf)
                except Exception:
                    pass
            return

        # ‚ö†Ô∏è V√©rification du chemin slicer uniquement si lancement demand√©
        if launch_slicer and slicer_path and not os.path.exists(slicer_path):
            show_message(tr("error_title"), f"{tr('error_invalid_slicer')}\n{slicer_path}")
            # ‚Üí on reboucle pour redemander les options
            continue

        # ‚úÖ Si on arrive ici, le chemin est valide ou le lancement du slicer est d√©coch√©
        break

    # Sauvegarde des param√®tres choisis
    save_settings(linear=linear_value, angular_rad=angular_value, slicer_path=slicer_path)
    print("‚öôÔ∏è Param√®tres sauvegard√©s, on continue l‚Äôexport‚Ä¶")
   
    
    # Export initial FreeCAD ‚Üí 3MF
    try:
        export_selection_with_deflection(selection, fc_3mf,
                                         linear_deflection=linear_value,
                                         angular_deflection=angular_value)
    except Exception as e:
        show_message(tr("error_title"), f"{tr('error_export_3mf')} {e}")
        if os.path.exists(old_3mf) and not os.path.exists(fc_3mf):
            try:
                shutil.move(old_3mf, fc_3mf)
            except Exception:
                pass
        return

    # G√©n√©ration STL si demand√©
    if generate_stl:
        stl_path = base_name + ".stl"
        try:
            export_stl_with_deflection(selection, stl_path,
                                       linear_deflection=linear_value,
                                       angular_deflection=angular_value)
        except Exception as e:
            show_message(tr("error_title"), f"{tr('error_generate_stl')} {e}")

    # Injection g√©om√©trie si ancien 3MF
    if os.path.exists(old_3mf):
        geom_entry = find_geom_file_in_3mf(fc_3mf)
        if not geom_entry:
            show_message(tr("error_title"), tr("error_no_geom"))
            return
        with zipfile.ZipFile(fc_3mf, 'r') as fc_zip:
            geom_data = fc_zip.read(geom_entry)

        # üîé √âtape cl√© : recentrage XY et calcul du Zmax
        geom_data_centered, zmax = recenter_vertices(geom_data)

        tmp_new = base_name + ".new.3mf"

        try:
            with zipfile.ZipFile(old_3mf, 'r') as old_zip, zipfile.ZipFile(tmp_new, 'w') as new_zip:
                for item in old_zip.infolist():
                    data = old_zip.read(item.filename)

                    # Injection de la g√©om√©trie recentr√©e
                    if item.filename.startswith("3D/Objects/") and item.filename.endswith(".model"):
                        new_zip.writestr(item.filename, geom_data_centered)

                    # Ajustement du transform
                    elif item.filename.endswith("3dmodel.model"):
                        if keep_positions:
                            # ‚ö†Ô∏è On conserve X/Y existants mais on force Z = zmax
                            data = force_zmax_in_transform(data, zmax)
                        else:
                            # ‚ö†Ô∏è On recalcule compl√®tement X/Y/Z
                            data = reset_item_transform(data, center=(CENTER_X, CENTER_Y, zmax))
                        new_zip.writestr(item.filename, data)

                    # Suppression √©ventuelle des Metadata si demand√©
                    elif not keep_params and item.filename.startswith("Metadata/"):
                        continue

                    else:
                        new_zip.writestr(item, data)
        except Exception as e:
            show_message(tr("error_title"), f"{tr('error_create_3mf')} {e}")
            return

        # Remplacement du fichier final
        try:
            if os.path.exists(fc_3mf):
                os.remove(fc_3mf)
        except Exception:
            pass
        try:
            shutil.move(tmp_new, fc_3mf)
        except Exception as e:
            show_message(tr("error_title"), f"{tr('error_replace_3mf')} {e}")
            return
        try:
            if os.path.exists(old_3mf):
                os.remove(old_3mf)
        except Exception:
            pass
        print("‚úÖ Export avec r√©cup√©ration des param√®tres du slicer :", fc_3mf)
        # Lancement du slicer si demand√©
        if launch_slicer and slicer_path and os.path.exists(slicer_path):
            try:
                subprocess.Popen([slicer_path, fc_3mf])
            except Exception as e:
                show_message(tr("error_title"), f"{tr('error_launch_slicer')} {e}")
        else:
            if not launch_slicer:
                show_message(tr("info_title"), tr("info_done"))
        # Sauvegarde du chemin du slicer
        if slicer_path and os.path.exists(slicer_path):
            try:
                save_settings(linear=linear_value, angular_rad=angular_value, slicer_path=slicer_path)
            except Exception as e:
                save_settings(linear=linear_value, angular_rad=angular_value, slicer_path=slicer_path)
     
    else:
        print("‚úÖ Fichier g√©n√©r√© uniquement par FreeCAD :", fc_3mf)
        if launch_slicer and slicer_path and os.path.exists(slicer_path):
            try:
                subprocess.Popen([slicer_path, fc_3mf])
            except Exception as e:
                show_message(tr("error_title"), f"{tr('error_launch_slicer')} {e}")
        else:
            if not launch_slicer:
                show_message(tr("info_title"), tr("info_done"))

    # Ex√©cution des commandes externes
    for checked, cmd, delay in extra_cmds:
        if checked:
            try:
                if delay > 0:
                    time.sleep(delay)
                subprocess.Popen(cmd)
            except Exception as e:
                show_message(tr("error_title"), f"{tr('error_external_cmd')} {e}")

# Lancement automatique
if __name__ == "__main__":
    export_replace_geometry()
