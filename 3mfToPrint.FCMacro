# -*- coding: utf-8 -*-
"""
Macro FreeCAD multilingue : export 3MF/STL avec contr√¥le de tessellation,
conservation des param√®tres du slicer, ouverture automatique du slicer,
et d√©clenchement de commandes externes (domotique).
"""

import math, os, zipfile, shutil, subprocess, re, fnmatch, xml.etree.ElementTree as ET
import configparser, ast, platform, time
import FreeCAD, FreeCADGui, Mesh, MeshPart
from PySide import QtGui, QtCore

# -------------------------
# Constantes et configuration
# -------------------------
INI_FILE = os.path.join(os.path.dirname(__file__), "3mfToPrint.ini")
CENTER_X, CENTER_Y, CENTER_Z = 120, 120, 2.5

if platform.system() == "Windows":
    DEFAULT_SLICER_EXE = r"C:\Program Files\QIDIStudio\qidi-studio.exe"
elif platform.system() == "Linux":
    DEFAULT_SLICER_EXE = "/usr/bin/qidi-studio"
else:
    DEFAULT_SLICER_EXE = ""

DEFAULT_LINEAR_DEFLECTION = 0.01
DEFAULT_ANGULAR_DEGREES = 3.0
DEFAULT_ANGULAR_DEFLECTION = DEFAULT_ANGULAR_DEGREES * math.pi / 180.0

EXTRA_COMMANDS = [
    #(["calc.exe"], "Ouvrir la calculatrice Windows ?", 0, False),   
     ]

def load_extra_commands_from_ini(path=INI_FILE):
    """Charge EXTRA_COMMANDS depuis le fichier ini si pr√©sent."""
    cfg = configparser.ConfigParser()
    try:
        cfg.read(path, encoding="utf-8")
        if "extra_commands" in cfg and "EXTRA_COMMANDS" in cfg["extra_commands"]:
            return ast.literal_eval(cfg["extra_commands"]["EXTRA_COMMANDS"])
    except Exception as e:
        print("‚ö†Ô∏è Erreur lecture EXTRA_COMMANDS ini:", e)
    return []

# Fusion au d√©marrage : commandes ini avant celles cod√©es en dur
EXTRA_COMMANDS = load_extra_commands_from_ini(INI_FILE) + EXTRA_COMMANDS



# -------------------------
# Traductions multilingues
# -------------------------
TRANSLATIONS = {
    "fr": {
        "options_title": "Options d'export vers QidiStudio",
        "keep_params": "Conserver les param√®tres d'impression (profil du slicer)",
        "keep_positions": "Conserver les positions sur le plateau",
        "generate_stl": "En plus du .3mf, g√©n√©rer √©galement un STL",
        "launch_slicer": "Lancer le slicer",
        "browse": "Parcourir‚Ä¶",
        "linear_label": "Pr√©cision (LinearDeflection) entre 0.01 et 10. Haute qualit√© : 0.01",
        "angular_label": "Tol√©rance angulaire (AngularDeflection) en degr√©s (ex: 3)",
        "external_actions": "Actions externes √† ex√©cuter avant fermeture :",
        "error_no_doc": "‚ùå Aucun document ouvert dans FreeCAD.",
        "error_no_save": "‚ùå Le projet n'a pas encore √©t√© sauvegard√©.",
        "warn_no_selection": "‚ö†Ô∏è Aucun objet s√©lectionn√©.",
        "warn_multi_selection": "‚ö†Ô∏è S√©lection multiple non support√©e.",
        "info_cancel": "‚ö†Ô∏è Export annul√© par l‚Äôutilisateur.",
        "info_done": "‚úÖ Export termin√©. Le slicer n'a pas √©t√© lanc√© (option d√©coch√©e).",
        "hint_linear": "Valeur plus petite = maillage plus fin.\nExemple : 0.01 = haute qualit√©, mais fichier lourd.\n"
                             "Exemple : 0.1 = adapt√© √† une imprimante FDM classique.",
        "hint_angular": "Tol√©rance angulaire en degr√©s.\nPetite valeur = plus de d√©tails, mais fichier plus lourd.",
        "hint_positions": "Conserve la position XY sur le plateau.\n‚ö†Ô∏è Le Z est toujours recalcul√© pour √©viter que l'objet soit sous le plateau.",
        "external_actions": "Actions externes √† ex√©cuter avant fermeture :",
        "no_external_actions": "Pas encore de commandes utilisateurs ajout√©es.",
        "hint_external_actions": "Vous pouvez ajouter vos propres actions dans le fichier ini, section [extra_commands].\n"
                             "Chaque commande peut √™tre configur√©e avec d√©lai et activation par case √† cocher.",
        "hint_keep_params": "Conserve les param√®tres du slicer (profil d'impression).",
        "hint_generate_stl": "G√©n√®re aussi un fichier STL en plus du 3MF.",
        "hint_launch_slicer": "Lance automatiquement le slicer apr√®s export si le chemin est valide.",

    },
    "en": {
        "options_title": "Export options to QidiStudio",
        "keep_params": "Keep printing parameters (slicer profile)",
        "keep_positions": "Keep positions on the build plate",
        "generate_stl": "Also generate an STL along with the .3mf",
        "launch_slicer": "Launch slicer",
        "browse": "Browse‚Ä¶",
        "linear_label": "Precision (LinearDeflection) between 0.01 and 10. High quality: 0.01",
        "angular_label": "Angular tolerance (AngularDeflection) in degrees (e.g. 3)",
        "external_actions": "External actions to execute before closing:",
        "error_no_doc": "‚ùå No document open in FreeCAD.",
        "error_no_save": "‚ùå The project has not been saved yet.",
        "warn_no_selection": "‚ö†Ô∏è No object selected.",
        "warn_multi_selection": "‚ö†Ô∏è Multiple selection not supported.",
        "info_cancel": "‚ö†Ô∏è Export cancelled by user.",
        "info_done": "‚úÖ Export finished. Slicer was not launched (option unchecked).",
        "hint_linear": "Smaller value = finer mesh.\nExample: 0.01 = high quality but heavy file.\n"
                             "Example: 0.1 = suitable for standard FDM printer.",
        "hint_angular": "Angular tolerance in degrees.\nSmaller value = more detail, but heavier file.",
        "hint_positions": "Keeps XY position on the build plate.\n‚ö†Ô∏è Z is always recalculated to avoid sinking below the plate.",
        "external_actions": "External actions to execute before closing:",
        "hint_external_actions": "You can add your own actions in the ini file, section [extra_commands].\n"
                             "Each command can be configured with delay and checkbox activation.",  
        "hint_keep_params": "Keeps slicer parameters (printing profile).",
        "hint_generate_stl": "Also generates an STL file along with the 3MF.",
        "hint_launch_slicer": "Automatically launches the slicer after export if the path is valid.",

 
   }
}

def get_user_language():
    try:
        locale = FreeCADGui.getLocale().lower()
        # Normalisation
        if locale.startswith("fr") or "french" in locale:
            return "fr"
        if locale.startswith("en") or "english" in locale:
            return "en"
        '''
        if locale.startswith("de") or "german" in locale:
            return "de"
        if locale.startswith("es") or "spanish" in locale:
            return "es"
        if locale.startswith("it") or "italian" in locale:
            return "it"
        '''    
        # Fallback
        return "en"
    except Exception:
        return "en"




def tr(key):
    lang = get_user_language()
    return TRANSLATIONS.get(lang, TRANSLATIONS["en"]).get(key, key)



# -------------------------
# Utilitaires UI / config
# -------------------------
def show_message(title, message):
    QtGui.QMessageBox.information(None, title, message)

def load_config():
    cfg = {
        "slicer_exe": DEFAULT_SLICER_EXE,
        "linear_deflection": DEFAULT_LINEAR_DEFLECTION,
        "angular_deflection": DEFAULT_ANGULAR_DEFLECTION,
    }
    config = configparser.ConfigParser()
    if os.path.exists(INI_FILE):
        try:
            config.read(INI_FILE)
            if "Settings" in config:
                s = config["Settings"]
                if "slicer_exe" in s:
                    cfg["slicer_exe"] = s.get("slicer_exe", cfg["slicer_exe"])
                if "linear_deflection" in s:
                    cfg["linear_deflection"] = float(s.get("linear_deflection", cfg["linear_deflection"]))
                if "angular_deflection_deg" in s:
                    deg = float(s.get("angular_deflection_deg", DEFAULT_ANGULAR_DEGREES))
                    cfg["angular_deflection"] = deg * math.pi / 180.0
        except Exception as e:
            print("‚ö†Ô∏è Erreur lecture ini:", e)
    return cfg

def save_settings(linear=None, angular_rad=None, slicer_path=None):
    angular_deg = None
    if angular_rad is not None:
        angular_deg = angular_rad * 180.0 / math.pi

    # Cr√©ation initiale avec commentaires si le fichier n'existe pas
    if not os.path.exists(INI_FILE):
        with open(INI_FILE, "w", encoding="utf-8") as f:
            f.write(
                "[Settings]\n"
                "# linear_deflection : pr√©cision lin√©aire (float)\n"
                "# angular_deflection_deg : tol√©rance angulaire en DEGR√âS (ex: 3.0)\n"
                "# slicer_exe : chemin vers l'ex√©cutable du slicer\n"
                f"linear_deflection = {linear if linear is not None else DEFAULT_LINEAR_DEFLECTION}\n"
                f"angular_deflection_deg = {angular_deg if angular_deg is not None else DEFAULT_ANGULAR_DEGREES}\n"
                f"slicer_exe = {slicer_path if slicer_path else ''}\n\n"
                "[extra_commands]\n"
                "EXTRA_COMMANDS = [\n"
                "# IMPORTANT :\n"
                "# - Les valeurs doivent √™tre indent√©es (au moins un espace ou une tabulation).\n"
                "# - Exemple correct :\n"
                "#     ([\"calc.exe\"], \"Ouvrir la calculatrice Windows ?\", 0, False),\n"
                "#     ([\"curl\", \"https://pijeedom/core/api/jeeApi.php?apikey=...\", \"--insecure\"], \"Turn on Q1Pro ?\", 10, True)\n"
                "#   ‚Üí Ici la commande sera ex√©cut√©e apr√®s 10 secondes si la case est coch√©e.\n"
                "# Placez ici vos commandes personnalis√©es :\n"
                "\n"
                "    ]\n"
            )
        return

    # Mise √† jour cibl√©e de [Settings] si le fichier existe d√©j√†
    with open(INI_FILE, "r", encoding="utf-8") as f:
        lines = f.readlines()

    new_lines = []
    in_settings = False
    for line in lines:
        if line.strip().startswith("[Settings]"):
            in_settings = True
            new_lines.append(line)
            continue
        if in_settings and line.strip().startswith("[") and not line.strip().startswith("[Settings]"):
            in_settings = False
        if in_settings:
            if line.strip().startswith("linear_deflection") and linear is not None:
                new_lines.append(f"linear_deflection = {linear}\n")
                continue
            if line.strip().startswith("angular_deflection_deg") and angular_deg is not None:
                new_lines.append(f"angular_deflection_deg = {angular_deg}\n")
                continue
            if line.strip().startswith("slicer_exe") and slicer_path is not None:
                new_lines.append(f"slicer_exe = {slicer_path}\n")
                continue
        new_lines.append(line)

    with open(INI_FILE, "w", encoding="utf-8") as f:
        f.writelines(new_lines)

# -------------------------
# Interface utilisateur
# -------------------------
def ask_user_options(current_slicer, current_linear, current_angular):
    """Affiche bo√Æte de dialogue pour options export (positions, params, STL, slicer, deflection)."""
    dialog = QtGui.QDialog()
    dialog.setWindowTitle(tr("options_title"))
    dialog.setMinimumWidth(720)

    layout = QtGui.QVBoxLayout()

    # Cases principales
    chk_params = QtGui.QCheckBox(tr("keep_params"))
    chk_params.setToolTip(tr("hint_keep_params"))
    chk_params.setChecked(True)
    layout.addWidget(chk_params)

    chk_positions = QtGui.QCheckBox(tr("keep_positions"))
    chk_positions.setToolTip(tr("hint_positions"))
    chk_positions.setChecked(True)
    layout.addWidget(chk_positions)

    chk_stl = QtGui.QCheckBox(tr("generate_stl"))
    chk_stl.setToolTip(tr("hint_generate_stl"))
    chk_stl.setChecked(False)
    layout.addWidget(chk_stl)

    # Ligne combin√©e : case "Lancer le slicer" + champ chemin
    h_slicer = QtGui.QHBoxLayout()
    chk_launch = QtGui.QCheckBox(tr("launch_slicer"))
    chk_launch.setToolTip(tr("hint_launch_slicer"))
    chk_launch.setChecked(True)
    h_slicer.addWidget(chk_launch)

    edit_slicer = QtGui.QLineEdit(current_slicer or "")
    edit_slicer.setMinimumWidth(420)
    h_slicer.addWidget(edit_slicer, stretch=1)

    btn_browse = QtGui.QPushButton(tr("browse"))
    def browse():
        path, _ = QtGui.QFileDialog.getOpenFileName(dialog, tr("browse"))
        if path:
            edit_slicer.setText(path)
    btn_browse.clicked.connect(browse)
    h_slicer.addWidget(btn_browse)
    layout.addLayout(h_slicer)

    # Pr√©cision lin√©aire
    h_lin = QtGui.QHBoxLayout()
    lbl_lin = QtGui.QLabel(tr("linear_label"))
    lbl_lin.setMinimumWidth(420)
    h_lin.addWidget(lbl_lin)

    spin_lin = QtGui.QDoubleSpinBox()
    spin_lin.setToolTip(tr("hint_linear"))
    spin_lin.setRange(0.01, 10.0)
    spin_lin.setSingleStep(0.01)
    spin_lin.setDecimals(2)
    spin_lin.setMaximumWidth(80)
    try:
        spin_lin.setValue(round(float(current_linear), 2))
    except Exception:
        spin_lin.setValue(DEFAULT_LINEAR_DEFLECTION)
    h_lin.addWidget(spin_lin)
    h_lin.addStretch()
    layout.addLayout(h_lin)

    # Tol√©rance angulaire
    h_ang = QtGui.QHBoxLayout()
    lbl_ang = QtGui.QLabel(tr("angular_label"))
    lbl_ang.setMinimumWidth(420)
    h_ang.addWidget(lbl_ang)

    spin_ang = QtGui.QDoubleSpinBox()
    spin_ang.setToolTip(tr("hint_angular"))
    spin_ang.setRange(1.0, 90.0)
    spin_ang.setSingleStep(1.0)
    spin_ang.setDecimals(1)
    spin_ang.setMaximumWidth(80)
    try:
        deg = float(current_angular) * 180.0 / math.pi
        spin_ang.setValue(deg)
    except Exception:
        spin_ang.setValue(DEFAULT_ANGULAR_DEGREES)
    h_ang.addWidget(spin_ang)
    h_ang.addStretch()
    layout.addLayout(h_ang)

    # Cases pour les commandes externes
    extra_checks = []
    if EXTRA_COMMANDS:
        lbl_ext = QtGui.QLabel(tr("external_actions"))
        lbl_ext.setToolTip(tr("hint_external_actions") + f"\n\nFichier ini : {INI_FILE}")
        layout.addWidget(lbl_ext)
        for cmd, label, delay, default in EXTRA_COMMANDS:
            chk = QtGui.QCheckBox(label)
            chk.setChecked(default)
            layout.addWidget(chk)
            extra_checks.append((chk, cmd, delay))
    else:
        # üëâ Afficher un libell√© m√™me si aucune commande n'est d√©finie
        lbl_ext = QtGui.QLabel(tr("no_external_actions"))
        lbl_ext.setToolTip(tr("hint_external_actions") + f"\n\nFichier ini : {INI_FILE}")
        layout.addWidget(lbl_ext)


    # Boutons OK/Annuler
    btns = QtGui.QDialogButtonBox(QtGui.QDialogButtonBox.Ok | QtGui.QDialogButtonBox.Cancel)
    layout.addWidget(btns)
    dialog.setLayout(layout)

    btns.accepted.connect(dialog.accept)
    btns.rejected.connect(dialog.reject)

    if dialog.exec() == QtGui.QDialog.Accepted:
        linear_val = float(spin_lin.value())
        angular_deg = float(spin_ang.value())
        angular_rad = angular_deg * math.pi / 180.0
        return (
            chk_params.isChecked(),
            chk_positions.isChecked(),
            chk_stl.isChecked(),
            edit_slicer.text(),
            chk_launch.isChecked(),
            linear_val,
            angular_rad,
            [(chk.isChecked(), cmd, delay) for chk, cmd, delay in extra_checks]
        )
    else:
        return (None, None, None, None, None, None, None, [])

# -------------------------
# Fonctions de traitement 3MF / mesh
# -------------------------
def find_geom_file_in_3mf(zip_path):
    with zipfile.ZipFile(zip_path, 'r') as z:
        rels_name = "_rels/.rels"
        if rels_name in z.namelist():
            try:
                rels_text = z.read(rels_name).decode("utf-8")
                root = ET.fromstring(rels_text)
                for rel in root:
                    if rel.tag.endswith("Relationship"):
                        rtype = rel.attrib.get("Type", "")
                        if rtype.endswith("3dmodel"):
                            target = rel.attrib.get("Target")
                            if target and target.startswith("/"):
                                target = target[1:]
                            if target in z.namelist():
                                return target
            except Exception:
                pass
        for name in z.namelist():
            if fnmatch.fnmatch(name, "3D/Objects/*.model"):
                return name
        if "3D/3dmodel.model" in z.namelist():
            return "3D/3dmodel.model"
    return None

def reset_item_transform(model_data, center=(CENTER_X, CENTER_Y, CENTER_Z)):
    text = model_data.decode("utf-8")
    new_transform = f'transform="1 0 0 0 1 0 0 0 1 {center[0]} {center[1]} {center[2]}"'
    text = re.sub(r'(<item[^>]*?)\s+transform="[^"]+"', r'\1 ' + new_transform, text)
    return text.encode("utf-8")
    
def export_stl_with_deflection(selection, stl_path,
                               linear_deflection=DEFAULT_LINEAR_DEFLECTION,
                               angular_deflection=DEFAULT_ANGULAR_DEFLECTION):
    doc = FreeCAD.ActiveDocument
    temp_objs = []
    try:
        for obj in selection:
            mesh = MeshPart.meshFromShape(
                Shape=obj.Shape,
                LinearDeflection=float(linear_deflection),
                AngularDeflection=float(angular_deflection)
            )
            mobj = doc.addObject("Mesh::Feature", f"TempMeshSTL_{obj.Name}")
            mobj.Mesh = mesh
            temp_objs.append(mobj)
        doc.recompute()
        Mesh.export(temp_objs, stl_path)
    finally:
        for t in temp_objs:
            try: doc.removeObject(t.Name)
            except Exception: pass
        doc.recompute()

def export_selection_with_deflection(selection, out_3mf_path,
                                     linear_deflection=DEFAULT_LINEAR_DEFLECTION,
                                     angular_deflection=DEFAULT_ANGULAR_DEFLECTION):
    doc = FreeCAD.ActiveDocument
    temp_objs = []
    try:
        for obj in selection:
            mesh = MeshPart.meshFromShape(
                Shape=obj.Shape,
                LinearDeflection=float(linear_deflection),
                AngularDeflection=float(angular_deflection))
            mobj = doc.addObject("Mesh::Feature", f"TempMesh_{obj.Name}")
            mobj.Mesh = mesh
            temp_objs.append(mobj)
        doc.recompute()
        Mesh.export(temp_objs, out_3mf_path)
    finally:
        for t in temp_objs:
            try: doc.removeObject(t.Name)
            except Exception: pass
        doc.recompute()


def force_zmax_in_transform(model_data, zmax):
    """
    Remplace uniquement la composante Z (12e valeur) du transform des <item> dans 3dmodel.model.
    - Conserve X/Y et la matrice de rotation/√©chelle.
    - zmax est un float (hauteur max des vertex) calcul√© par recenter_vertices.

    Si plusieurs <item> existent, on les met tous √† jour.
    """
    try:
        text = model_data.decode("utf-8")

        def repl(m):
            nums = m.group(1).split()
            # transform = 12 nombres : 9 pour la matrice, 3 pour la translation (X, Y, Z)
            if len(nums) == 12:
                nums[-1] = f"{zmax}"
                return 'transform="' + " ".join(nums) + '"'
            # Si format inattendu, on ne modifie pas
            return m.group(0)

        # Met √† jour tous les transform="..."; count=0 = sans limite
        text = re.sub(r'transform="([^"]+)"', repl, text, count=0)
        return text.encode("utf-8")
    except Exception as e:
        print("‚ö†Ô∏è force_zmax_in_transform: √©chec, on garde le transform d'origine :", e)
        return model_data



def recenter_vertices(model_data):
    """
    Recentrage des vertex en X/Y et calcul du Zmax pour placement correct sur le plateau.
    Retourne : (donn√©es XML modifi√©es, zmax)
    """
    try:
        ET.register_namespace('', "http://schemas.microsoft.com/3dmanufacturing/core/2015/02")
        root = ET.fromstring(model_data.decode("utf-8"))
        ns = {"ns": "http://schemas.microsoft.com/3dmanufacturing/core/2015/02"}
        verts = root.findall(".//ns:vertex", ns)

        xs = [float(v.attrib["x"]) for v in verts]
        ys = [float(v.attrib["y"]) for v in verts]
        zs = [float(v.attrib["z"]) for v in verts]

        # Calcul du centre XY et du Zmax
        xc, yc = (min(xs) + max(xs)) / 2.0, (min(ys) + max(ys)) / 2.0
        zmax = max(zs)

        # Recentrage XY
        for v in verts:
            v.attrib["x"] = str(float(v.attrib["x"]) - xc)
            v.attrib["y"] = str(float(v.attrib["y"]) - yc)

        return ET.tostring(root, encoding="utf-8", xml_declaration=False), zmax
    except Exception as e:
        print("‚ö†Ô∏è Erreur recentrage vertex :", e)
        return model_data, CENTER_Z

# -------------------------
# Routine principale
# -------------------------
def export_replace_geometry():
    cfg = load_config()
    doc = FreeCAD.ActiveDocument
    if not doc:
        show_message("Erreur", tr("error_no_doc"))
        return

    fcstd_path = doc.FileName
    if not fcstd_path:
        show_message("Erreur", tr("error_no_save"))
        return

    base_name = os.path.splitext(fcstd_path)[0]
    fc_3mf = base_name + ".3mf"
    old_3mf = base_name + ".old.3mf"

    # Sauvegarde de l'ancien 3MF si pr√©sent
    if os.path.exists(fc_3mf):
        try:
            shutil.move(fc_3mf, old_3mf)
        except Exception:
            pass

    # V√©rification de la s√©lection
    selection = FreeCADGui.Selection.getSelection()
    
    # Filtrer la s√©lection : ne garder que les objets avec un Shape
    selection = [obj for obj in selection if hasattr(obj, "Shape") and obj.Shape is not None]

    # Si aucun objet exportable
    if not selection:
        show_message("Avertissement", "‚ö†Ô∏è Aucun objet exportable (Shape manquant).")
        return

    # Si plusieurs objets exportables ‚Üí non support√©
    if len(selection) > 1:
        show_message("Avertissement", tr("warn_multi_selection"))
        return

    
    
    if not selection:
        show_message("Avertissement", tr("warn_no_selection"))
        return
    if len(selection) > 1:
        show_message("Avertissement", tr("warn_multi_selection"))
        return

    # Chargement des pr√©f√©rences
    slicer_path_pref = cfg.get("slicer_exe", DEFAULT_SLICER_EXE)
    linear_pref = cfg.get("linear_deflection", DEFAULT_LINEAR_DEFLECTION)
    angular_pref = cfg.get("angular_deflection", DEFAULT_ANGULAR_DEFLECTION)

    # Bo√Æte de dialogue utilisateur
    keep_params, keep_positions, generate_stl, slicer_path, launch_slicer, linear_value, angular_value, extra_cmds = \
        ask_user_options(slicer_path_pref, linear_pref, angular_pref)

    if slicer_path is None and launch_slicer is None:
        show_message("Info", tr("info_cancel"))
        if os.path.exists(old_3mf) and not os.path.exists(fc_3mf):
            try:
                shutil.move(old_3mf, fc_3mf)
            except Exception:
                pass
        return

    # Sauvegarde des param√®tres choisis
    save_settings(linear=linear_value, angular_rad=angular_value)

    # Export initial FreeCAD ‚Üí 3MF
    try:
        export_selection_with_deflection(selection, fc_3mf,
                                         linear_deflection=linear_value,
                                         angular_deflection=angular_value)
    except Exception as e:
        show_message("Erreur", f"‚ùå Erreur lors de l'export 3MF : {e}")
        if os.path.exists(old_3mf) and not os.path.exists(fc_3mf):
            try:
                shutil.move(old_3mf, fc_3mf)
            except Exception:
                pass
        return

    # G√©n√©ration STL si demand√©
    if generate_stl:
        stl_path = base_name + ".stl"
        try:
            export_stl_with_deflection(selection, stl_path,
                                       linear_deflection=linear_value,
                                       angular_deflection=angular_value)
        except Exception as e:
            show_message("Erreur", f"‚ùå Erreur lors de la g√©n√©ration du STL : {e}")

    # Injection g√©om√©trie si ancien 3MF
    if os.path.exists(old_3mf):
        geom_entry = find_geom_file_in_3mf(fc_3mf)
        if not geom_entry:
            show_message("Erreur", "‚ùå Aucun fichier de g√©om√©trie d√©tect√© dans le 3MF export√©.")
            return
        with zipfile.ZipFile(fc_3mf, 'r') as fc_zip:
            geom_data = fc_zip.read(geom_entry)

        # üîé √âtape cl√© : recentrage XY et calcul du Zmax
        geom_data_centered, zmax = recenter_vertices(geom_data)

        tmp_new = base_name + ".new.3mf"

        try:
            with zipfile.ZipFile(old_3mf, 'r') as old_zip, zipfile.ZipFile(tmp_new, 'w') as new_zip:
                for item in old_zip.infolist():
                    data = old_zip.read(item.filename)

                    # Injection de la g√©om√©trie recentr√©e
                    if item.filename.startswith("3D/Objects/") and item.filename.endswith(".model"):
                        new_zip.writestr(item.filename, geom_data_centered)

                    # Ajustement du transform
                    elif item.filename.endswith("3dmodel.model"):
                        if keep_positions:
                            # ‚ö†Ô∏è On conserve X/Y existants mais on force Z = zmax
                            data = force_zmax_in_transform(data, zmax)
                        else:
                            # ‚ö†Ô∏è On recalcule compl√®tement X/Y/Z
                            data = reset_item_transform(data, center=(CENTER_X, CENTER_Y, zmax))
                        new_zip.writestr(item.filename, data)

                    # Suppression √©ventuelle des Metadata si demand√©
                    elif not keep_params and item.filename.startswith("Metadata/"):
                        continue

                    else:
                        new_zip.writestr(item, data)
        except Exception as e:
            show_message("Erreur", f"‚ùå Erreur lors de la cr√©ation du 3MF final : {e}")
            return

        # Remplacement du fichier final
        try:
            if os.path.exists(fc_3mf):
                os.remove(fc_3mf)
        except Exception:
            pass
        try:
            shutil.move(tmp_new, fc_3mf)
        except Exception as e:
            show_message("Erreur", f"‚ùå Impossible de remplacer le 3MF : {e}")
            return
        try:
            if os.path.exists(old_3mf):
                os.remove(old_3mf)
        except Exception:
            pass

        # Lancement du slicer si demand√©
        if launch_slicer and slicer_path and os.path.exists(slicer_path):
            try:
                subprocess.Popen([slicer_path, fc_3mf])
            except Exception as e:
                show_message("Erreur", f"‚ùå Erreur lors du lancement du slicer : {e}")
        else:
            if not launch_slicer:
                show_message("Info", tr("info_done"))
        # Sauvegarde du chemin du slicer
        if slicer_path and os.path.exists(slicer_path):
            try:
                save_settings(slicer_path=slicer_path)
            except Exception:
                pass
    else:
        print("‚úÖ Fichier g√©n√©r√© uniquement par FreeCAD :", fc_3mf)
        if launch_slicer and slicer_path and os.path.exists(slicer_path):
            try:
                subprocess.Popen([slicer_path, fc_3mf])
            except Exception as e:
                show_message("Erreur", f"‚ùå Erreur lors du lancement du slicer : {e}")
        else:
            if not launch_slicer:
                show_message("Info", tr("info_done"))



    # Ex√©cution des commandes externes
    for checked, cmd, delay in extra_cmds:
        if checked:
            try:
                if delay > 0:
                    time.sleep(delay)
                subprocess.Popen(cmd)
            except Exception as e:
                show_message("Erreur", f"‚ùå Impossible d'ex√©cuter la commande externe : {e}")

# Lancement automatique
if __name__ == "__main__":
    export_replace_geometry()
