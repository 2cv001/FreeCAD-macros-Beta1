

# -*- coding: utf-8 -*-
"""
Macro FreeCAD multilingue : export 3MF/STL avec contr√¥le de tessellation,
conservation des param√®tres du slicer, ouverture automatique du slicer,
et d√©clenchement de commandes externes (domotique).
S'il y a deux objets dans le 3mf source, ne garde que le premier

Variables contenant le nom des fichiers :
fc_3mf : test.3mf si le projet est test.FCStd
    AVANT EXPORT FREECAD
    C'est le fichier g√©n√©r√© par le slicer avec les param√®tre impression.
    S'il existe au lancement de la macro, fc_3mf_existed_at_start = True   
    APRES EXPORT FREECAD
    Ecras√© par FreeCAD au moment de l'export, il contient alors la g√©om√©trie mais pas les param√®tres d'impression

old_3mf_backup : Ex test.old.3mf
    Sauvegarde du fichier du slicer avant export, il contient les param√®tres impression
    Cr√©√© (copi√© de fc_3mf) au d√©but de la macro si fc_3mf existe. 
 
    fc_3mf (avant export)
        ‚Üì copie
    old_3mf_backup  ‚Üê contient les param√®tres d'impression si fc_3mf les a
        ‚Üì export FreeCAD
    fc_3mf (apr√®s export) ‚Üê contient la g√©om√©trie FreeCAD, pas les param√®tres impression
        ‚Üì injection
    fc_3mf (final) ‚Üê g√©om√©trie FreeCAD + position Qidi
    
tmp_new
    fichier provisoir qui sert √† construire le fichier 3mf d√©ficnitif
    
slicer_source 
    contient le nom du slicer source. D√©fini dans prepare_environment()
slicer_target
    contient le nom du slicer cible. D√©fini juste apr√®s la boite de dialogue principale
fc_3mf_existed_at_start
    comme son nom l'indique

 
"""

import math, os, zipfile, shutil, subprocess, re, fnmatch, xml.etree.ElementTree as ET
import configparser, ast, platform, time
import FreeCAD, FreeCADGui, Mesh, MeshPart
from PySide import QtGui, QtCore
from typing import Dict, Optional

# -------------------------
# Constantes et configuration
# -------------------------
INI_FILE = os.path.join(os.path.dirname(__file__), "3mfToPrint.ini")
CENTER_X, CENTER_Y, CENTER_Z = 120, 120, 2.5

if platform.system() == "Windows":
    DEFAULT_SLICER_EXE = r"C:\Program Files\QIDIStudio\qidi-studio.exe"
elif platform.system() == "Linux":
    DEFAULT_SLICER_EXE = "/usr/bin/qidi-studio"
else:
    DEFAULT_SLICER_EXE = ""

DEFAULT_LINEAR_DEFLECTION = 0.01
DEFAULT_ANGULAR_DEGREES = 3.0
DEFAULT_ANGULAR_DEFLECTION = DEFAULT_ANGULAR_DEGREES * math.pi / 180.0

EXTRA_COMMANDS = [
    #(["calc.exe"], "Ouvrir la calculatrice Windows ?", 0, False),
    #(["curl", "-u", "admin:motDePass", "--insecure",
    #  "http://IpDeLaPriseShelly/rpc/Switch.Set?id=0&on=true"],
    #  "Allumer la prise Shelly Gen2 ?", 0, False),
]


     
     

# Charge les commandes externes d√©finies dans le fichier ini
def load_extra_commands_from_ini(path=INI_FILE):
    cfg = configparser.ConfigParser()
    try:
        cfg.read(path, encoding="utf-8")
        if "extra_commands" in cfg and "EXTRA_COMMANDS" in cfg["extra_commands"]:
            return ast.literal_eval(cfg["extra_commands"]["EXTRA_COMMANDS"])
    except Exception as e:
        print("‚ö†Ô∏è Erreur lecture EXTRA_COMMANDS ini:", e)
    return []

# Fusion au d√©marrage : commandes ini avant celles cod√©es en dur
EXTRA_COMMANDS = load_extra_commands_from_ini(INI_FILE) + EXTRA_COMMANDS



# -------------------------
# Traductions multilingues
# -------------------------
TRANSLATIONS = {
    "fr": {
        # Titres
        "error_title": "Erreur",
        "warn_title": "Avertissement",
        "info_title": "Info",
        
        # Buttons
        #"btn_keep": "Conserver", 
        "btn_delete": "Ok", 
        "btn_cancel": "Annuler",

        # Options UI
        "options_title": "Options d'export vers QidiStudio",
        "keep_params": "Conserver les param√®tres d'impression (profil du slicer)",
        "keep_positions": "Conserver les positions sur le plateau",
        "generate_stl": "En plus du .3mf, g√©n√©rer √©galement un STL",
        "launch_slicer": "Lancer le slicer",
        "browse": "Parcourir‚Ä¶",
        "linear_label": "Pr√©cision (LinearDeflection) entre 0.01 et 10. Haute qualit√© : 0.01",
        "angular_label": "Tol√©rance angulaire (AngularDeflection) en degr√©s (ex: 3)",
        "external_actions": "Actions externes √† ex√©cuter avant fermeture :",

        # Messages d'erreur / avertissement
        "error_no_doc": "‚ùå Aucun document ouvert dans FreeCAD.",
        "error_no_save": "‚ùå Le projet n'a pas encore √©t√© sauvegard√©.",
        "warn_no_selection": "‚ö†Ô∏è Aucun objet s√©lectionn√©.",
        "warn_multi_selection": "‚ö†Ô∏è S√©lection multiple non support√©e.",
        "error_write_ini": "‚ùå √âcriture impossible sur le fichier ini :",
        "error_export_3mf": "‚ùå Erreur lors de l'export 3MF :",
        "error_generate_stl": "‚ùå Erreur lors de la g√©n√©ration du STL :",
        "error_create_3mf": "‚ùå Erreur lors de la cr√©ation du 3MF final :",
        "error_replace_3mf": "‚ùå Impossible de remplacer le 3MF :",
        "error_launch_slicer": "‚ùå Erreur lors du lancement du slicer :",
        "error_external_cmd": "‚ùå Impossible d'ex√©cuter la commande externe :",
        "error_no_geom": "‚ùå Aucun fichier de g√©om√©trie d√©tect√© dans le 3MF export√©.",
        "error_invalid_slicer": "‚ùå Le chemin du slicer est invalide :",
        "warn_no_geom_vertices": "L'objet s√©lectionn√© n'a pas de g√©om√©trie 3D utilisable (par ex. un Sketch).",
        "warn_incompatible_slicer_dialog":
            "Le fichier 3MF d‚Äôorigine provient de : {source}\n"
            "Le slicer cible s√©lectionn√© est :       {target}\n\n"
            "Ces slicers ne sont pas identiques.\n"
            "Continuer en effa√ßant le fichier 3mf, sans r√©cup√©ration des param√®tres d'impression ?",
        "warn_empty_plate":
            "‚ö†Ô∏è Le fichier 3MF du slicer ne contient aucun objet et ne peut servir de base.\n"
            "Cela arrive souvent apr√®s une suppression dans le slicer.\n\n"
            "Que souhaitez-vous faire ?\n\n"
            "‚Ä¢ Restaurer l'ancien fichier 3MF du slicer\n"
            "‚Ä¢ Supprimer le 3MF export√© par FreeCAD et repartir comme un nouveau projet\n"
            "‚Ä¢ Annuler",
        "btn_restore_old_3mf": "Restaurer l'ancien 3MF",
        "btn_reset_new_project": "Repartir √† z√©ro",




        # Infos
        "info_cancel": "‚ö†Ô∏è Export annul√© par l‚Äôutilisateur.",
        "info_done": "‚úÖ Export termin√©. Le slicer n'a pas √©t√© lanc√© (option d√©coch√©e).",
        "info_export_fc": "‚úÖ Fichier g√©n√©r√© uniquement par FreeCAD :",
        "info_export_slicer": "‚úÖ Export avec r√©cup√©ration des param√®tres du slicer :",
        

        # Aides / tooltips
        "hint_linear": "Valeur plus petite = maillage plus fin.\nExemple : 0.01 = haute qualit√©, mais fichier lourd.\n"
                       "Exemple : 0.1 = adapt√© √† une imprimante FDM classique.",
        "hint_angular": "Tol√©rance angulaire en degr√©s.\nPetite valeur = plus de d√©tails, mais fichier plus lourd.",
        "hint_positions": "Conserve la position XY sur le plateau.\n‚ö†Ô∏è Le Z est toujours recalcul√© pour √©viter que l'objet soit sous le plateau.",
        "no_external_actions": "Pas encore de commandes utilisateurs ajout√©es.",
        "hint_external_actions": "Vous pouvez ajouter vos propres actions dans le fichier ini, section [extra_commands].\n"
                                 "Chaque commande peut √™tre configur√©e avec d√©lai et activation par case √† cocher.",
        "hint_keep_params": "Conserve les param√®tres du slicer (profil d'impression).",
        "hint_generate_stl": "G√©n√®re aussi un fichier STL en plus du 3MF.",
        "hint_launch_slicer": "Lance automatiquement le slicer apr√®s export si le chemin est valide.",
        "ini_file_label": "Fichier ini :",

    },

    "en": {
        # Titles
        "error_title": "Error",
        "warn_title": "Warning",
        "info_title": "Info",
        
        
        # Buttons
        #"btn_keep": "Keep",
        "btn_delete": "Ok",
        "btn_cancel": "Cancel",   

        # UI options
        "options_title": "Export options for QidiStudio",
        "keep_params": "Keep print settings (slicer profile)",
        "keep_positions": "Keep positions on the build plate",
        "generate_stl": "Also generate an STL along with the 3MF",
        "launch_slicer": "Launch slicer",
        "browse": "Browse‚Ä¶",
        "linear_label": "Precision (LinearDeflection) between 0.01 and 10. High quality: 0.01",
        "angular_label": "Angular tolerance (AngularDeflection) in degrees (e.g. 3)",
        "external_actions": "External actions to execute before closing:",

        # Error / warning messages
        "error_no_doc": "‚ùå No document open in FreeCAD.",
        "error_no_save": "‚ùå The project has not been saved yet.",
        "warn_no_selection": "‚ö†Ô∏è No object selected.",
        "warn_multi_selection": "‚ö†Ô∏è Multiple selection not supported.",
        "error_write_ini": "‚ùå Unable to write to the ini file:",
        "error_export_3mf": "‚ùå Error during 3MF export:",
        "error_generate_stl": "‚ùå Error during STL generation:",
        "error_create_3mf": "‚ùå Error while creating the final 3MF:",
        "error_replace_3mf": "‚ùå Unable to replace the 3MF:",
        "error_launch_slicer": "‚ùå Error while launching slicer:",
        "error_external_cmd": "‚ùå Unable to execute external command:",
        "error_no_geom": "‚ùå No geometry file detected in exported 3MF.",
        "error_invalid_slicer": "‚ùå Invalid slicer path:",
        "warn_no_geom_vertices": "Selected object does not contain usable 3D geometry (e.g. a Sketch).",
        "warn_incompatible_slicer_dialog":
            "The original 3MF file was created by: {source}\n"
            "The selected target slicer is:        {target}\n\n"
            "These slicers are not identical.\n"
            "Continue by deleting the 3MF file, without recovering the print settings?\n\n",
                    
        "warn_empty_plate":
            "‚ö†Ô∏è The slicer's 3MF file contains no objects and cannot be used as a base.\n"
            "This often happens after deleting objects inside the slicer.\n\n"
            "What would you like to do?\n\n"
            "‚Ä¢ Restore the previous 3MF file from the slicer\n"
            "‚Ä¢ Delete the 3MF exported by FreeCAD and start a new project\n"
            "‚Ä¢ Cancel",
        "btn_restore_old_3mf": "Restore previous 3MF",
        "btn_reset_new_project": "Start a new project",




        # Infos
        "info_cancel": "‚ö†Ô∏è Export cancelled by user.",
        "info_done": "‚úÖ Export finished. Slicer was not launched (option unchecked).",
        "info_export_fc": "‚úÖ File generated only by FreeCAD:",
        "info_export_slicer": "‚úÖ Export with slicer settings recovered:",

        # Tooltips
        "hint_linear": "Smaller value = finer mesh.\nExample: 0.01 = high quality but heavy file.\n"
                       "Example: 0.1 = suitable for standard FDM printer.",
        "hint_angular": "Angular tolerance in degrees.\nSmaller value = more detail, but heavier file.",
        "hint_positions": "Keeps XY position on the build plate.\n‚ö†Ô∏è  Z is always recalculated to prevent"
            "the object from going below the build plate.",
        "no_external_actions": "No user commands added yet.",
        "hint_external_actions": "You can add your own actions in the ini file, section [extra_commands].\n"
                                 "Each command can be configured with delay and checkbox activation.",
        "hint_keep_params": "Keeps slicer parameters (printing profile).",
        "hint_generate_stl": "Also generates an STL file along with the 3MF.",
        "hint_launch_slicer": "Automatically launches the slicer after export if the path is valid.",
        "ini_file_label": "INI file:",

    }
}


# D√©termine la langue de l‚Äôutilisateur √† partir de FreeCADGui
def get_user_language():
    try:
        locale = FreeCADGui.getLocale().lower()
        # Normalisation
        if locale.startswith("fr") or "french" in locale:
            return "fr"
        if locale.startswith("en") or "english" in locale:
            return "en"
        '''
        if locale.startswith("de") or "german" in locale:
            return "de"
        if locale.startswith("es") or "spanish" in locale:
            return "es"
        if locale.startswith("it") or "italian" in locale:
            return "it"
        '''    
        # Fallback
        return "en"
    except Exception:
        return "en"



# Traduit une cl√© donn√©e selon la langue utilisateur
def tr(key):
    lang = get_user_language()
    return TRANSLATIONS.get(lang, TRANSLATIONS["en"]).get(key, key)



# -------------------------
# Utilitaires UI / config
# -------------------------
# Affiche une bo√Æte de message d‚Äôinformation dans FreeCAD
def show_message(title, message):
    QtGui.QMessageBox.information(None, title, message)

# Charge la configuration (slicer, d√©flections) depuis le fichier ini
def load_config():
    cfg = {
        "slicer_exe": DEFAULT_SLICER_EXE,
        "linear_deflection": DEFAULT_LINEAR_DEFLECTION,
        "angular_deflection": DEFAULT_ANGULAR_DEFLECTION,
    }
    config = configparser.ConfigParser()
    if os.path.exists(INI_FILE):
        try:
            config.read(INI_FILE)
            if "Settings" in config:
                s = config["Settings"]
                if "slicer_exe" in s:
                    cfg["slicer_exe"] = s.get("slicer_exe", cfg["slicer_exe"])
                if "linear_deflection" in s:
                    cfg["linear_deflection"] = float(s.get("linear_deflection", cfg["linear_deflection"]))
                if "angular_deflection_deg" in s:
                    deg = float(s.get("angular_deflection_deg", DEFAULT_ANGULAR_DEGREES))
                    cfg["angular_deflection"] = deg * math.pi / 180.0
        except Exception as e:
            print("‚ö†Ô∏è Erreur lecture ini:", e)
    return cfg

# Sauvegarde les param√®tres (d√©flections, chemin slicer) dans le fichier ini
def save_settings(linear, angular_rad, slicer_path):
    angular_deg = None
    if angular_rad is not None:
        angular_deg = angular_rad * 180.0 / math.pi

    # Cr√©ation initiale avec commentaires si le fichier n'existe pas
    if not os.path.exists(INI_FILE):
        with open(INI_FILE, "w", encoding="utf-8") as f:
            f.write(
                "[Settings]\n"
                "# linear_deflection : pr√©cision lin√©aire (float)\n"
                "# angular_deflection_deg : tol√©rance angulaire en DEGR√âS (ex: 3.0)\n"
                "# slicer_exe : chemin vers l'ex√©cutable du slicer\n"
                f"linear_deflection = {linear}\n"
                f"angular_deflection_deg = {angular_deg}\n"
                f"slicer_exe = {slicer_path}\n\n"
                "[extra_commands]\n"
                "EXTRA_COMMANDS = [\n"
                "    ]\n"
            )
        return


    # Mise √† jour cibl√©e de [Settings] si le fichier existe d√©j√†
    with open(INI_FILE, "r", encoding="utf-8") as f:
        lines = f.readlines()

    new_lines = []
    in_settings = False
    for line in lines:
        if line.strip().startswith("[Settings]"):
            in_settings = True
            new_lines.append(line)
            continue
        if in_settings and line.strip().startswith("[") and not line.strip().startswith("[Settings]"):
            in_settings = False
        if in_settings:
            if line.strip().startswith("linear_deflection") and linear is not None:
                new_lines.append(f"linear_deflection = {linear}\n")
                continue
            if line.strip().startswith("angular_deflection_deg") and angular_deg is not None:
                new_lines.append(f"angular_deflection_deg = {angular_deg}\n")
                continue
            if line.strip().startswith("slicer_exe") and slicer_path is not None:
                new_lines.append(f"slicer_exe = {slicer_path}\n")
                continue
        new_lines.append(line)

    with open(INI_FILE, "w", encoding="utf-8") as f:
        f.writelines(new_lines)

# -------------------------
# Interface utilisateur
# -------------------------
# Affiche une bo√Æte de dialogue pour demander les options d‚Äôexport √† l‚Äôutilisateur
def ask_user_options(current_slicer, current_linear, current_angular):
    """Affiche bo√Æte de dialogue pour options export (positions, params, STL, slicer, deflection)."""
    dialog = QtGui.QDialog()
    dialog.setWindowTitle(tr("options_title"))
    dialog.setMinimumWidth(720)

    layout = QtGui.QVBoxLayout()

    # Cases principales
    chk_params = QtGui.QCheckBox(tr("keep_params"))
    chk_params.setToolTip(tr("hint_keep_params"))
    chk_params.setChecked(True)
    layout.addWidget(chk_params)

    chk_positions = QtGui.QCheckBox(tr("keep_positions"))
    chk_positions.setToolTip(tr("hint_positions"))
    chk_positions.setChecked(True)
    layout.addWidget(chk_positions)

    chk_stl = QtGui.QCheckBox(tr("generate_stl"))
    chk_stl.setToolTip(tr("hint_generate_stl"))
    chk_stl.setChecked(False)
    layout.addWidget(chk_stl)

    # Ligne combin√©e : case "Lancer le slicer" + champ chemin
    h_slicer = QtGui.QHBoxLayout()
    chk_launch = QtGui.QCheckBox(tr("launch_slicer"))
    chk_launch.setToolTip(tr("hint_launch_slicer"))
    chk_launch.setChecked(True)
    h_slicer.addWidget(chk_launch)

    edit_slicer = QtGui.QLineEdit(current_slicer or "")
    edit_slicer.setMinimumWidth(420)
    h_slicer.addWidget(edit_slicer, stretch=1)

    btn_browse = QtGui.QPushButton(tr("browse"))
    def browse():
        path, _ = QtGui.QFileDialog.getOpenFileName(dialog, tr("browse"))
        if path:
            edit_slicer.setText(path)
    btn_browse.clicked.connect(browse)
    h_slicer.addWidget(btn_browse)
    layout.addLayout(h_slicer)

    # Pr√©cision lin√©aire
    h_lin = QtGui.QHBoxLayout()
    lbl_lin = QtGui.QLabel(tr("linear_label"))
    lbl_lin.setMinimumWidth(420)
    h_lin.addWidget(lbl_lin)

    spin_lin = QtGui.QDoubleSpinBox()
    spin_lin.setToolTip(tr("hint_linear"))
    spin_lin.setRange(0.01, 10.0)
    spin_lin.setSingleStep(0.01)
    spin_lin.setDecimals(2)
    spin_lin.setMaximumWidth(80)
    try:
        spin_lin.setValue(round(float(current_linear), 2))
    except Exception:
        spin_lin.setValue(DEFAULT_LINEAR_DEFLECTION)
    h_lin.addWidget(spin_lin)
    h_lin.addStretch()
    layout.addLayout(h_lin)

    # Tol√©rance angulaire
    h_ang = QtGui.QHBoxLayout()
    lbl_ang = QtGui.QLabel(tr("angular_label"))
    lbl_ang.setMinimumWidth(420)
    h_ang.addWidget(lbl_ang)

    spin_ang = QtGui.QDoubleSpinBox()
    spin_ang.setToolTip(tr("hint_angular"))
    spin_ang.setRange(1.0, 90.0)
    spin_ang.setSingleStep(1.0)
    spin_ang.setDecimals(1)
    spin_ang.setMaximumWidth(80)
    try:
        deg = float(current_angular) * 180.0 / math.pi
        spin_ang.setValue(deg)
    except Exception:
        spin_ang.setValue(DEFAULT_ANGULAR_DEGREES)
    h_ang.addWidget(spin_ang)
    h_ang.addStretch()
    layout.addLayout(h_ang)

    # Cases pour les commandes externes
    extra_checks = []
    if EXTRA_COMMANDS:
        lbl_ext = QtGui.QLabel(tr("external_actions"))
        lbl_ext.setToolTip(tr("hint_external_actions") + f"\n\n{tr('ini_file_label')} {INI_FILE}")
        layout.addWidget(lbl_ext)
        for cmd, label, delay, default in EXTRA_COMMANDS:
            chk = QtGui.QCheckBox(label)
            chk.setChecked(default)
            layout.addWidget(chk)
            extra_checks.append((chk, cmd, delay))
    else:
        # üëâ Afficher un libell√© m√™me si aucune commande n'est d√©finie
        lbl_ext = QtGui.QLabel(tr("no_external_actions"))
        lbl_ext.setToolTip(tr("hint_external_actions") + f"\n\nFichier ini : {INI_FILE}")
        layout.addWidget(lbl_ext)


    # Boutons OK/Annuler
    btns = QtGui.QDialogButtonBox(QtGui.QDialogButtonBox.Ok | QtGui.QDialogButtonBox.Cancel)
    layout.addWidget(btns)
    dialog.setLayout(layout)

    btns.accepted.connect(dialog.accept)
    btns.rejected.connect(dialog.reject)

    if dialog.exec() == QtGui.QDialog.Accepted:
        linear_val = float(spin_lin.value())
        angular_deg = float(spin_ang.value())
        angular_rad = angular_deg * math.pi / 180.0
        return (
            chk_params.isChecked(),
            chk_positions.isChecked(),
            chk_stl.isChecked(),
            edit_slicer.text(),
            chk_launch.isChecked(),
            linear_val,
            angular_rad,
            [(chk.isChecked(), cmd, delay) for chk, cmd, delay in extra_checks]
        )
    else:
        return (None, None, None, None, None, None, None, [])

# -------------------------
# Fonctions de traitement 3MF / mesh
# -------------------------

def detect_slicer_target_from_path(path):
    if not path:
        return None

    p = path.lower()

    # QidiStudio
    #if "qidistudio" in p:
        #return "qidistudio"

    # QidiSlicer (moderne, fork Prusa)
    if "qidislicer" in p:
        return "qidislicer"
        
    # QidiStudio / Orca 
    if any(x in p.lower() for x in ("qidistudio", "orca", "bambu", "creality")):
        return "qidistudio"

    # Prusa / Orca / Bambu / SuperSlicer
    #if any(x in p for x in ("orca", "prusa", "bambu", "super")):
    if any(x in p for x in ("prusa", "super")):
        return "slic3r"
        
        

    # Cura
    if "cura" in p:
        return "cura"

    return "unknown"






# ------------------------------------------------------------
# Analyse du fichier 3MF (nb objets et slicer)
# ------------------------------------------------------------
def analyse_fichier_3mf(file_path: str) -> Dict[str, Optional[str]]:
    """
    Analyse un fichier 3MF et retourne :
    - le nombre d'objets 3D (en filtrant les objets vides)
    - le logiciel d'export (FreeCAD, PrusaSlicer, QidiSlicer, Cura, etc.)
    Orcaslicer est d√©tect√© comme bambu car c'est un fork direct
    """
    result = {
        'nombre_objets': None,
        'logiciel': None
    }
    
    if not os.path.exists(file_path):
        result = {
        'nombre_objets': 'noFile',
        'logiciel': 'noFile'
            }
        print ('analyse_fichier_3mf : pas de fichier', file_path)
        return result   
    
    # ------------------------------------------------------------
    # Normalisation du nom du logiciel
    # ------------------------------------------------------------
    def normaliser_logiciel(nom: str) -> str:
        if not nom:
            return "Inconnu"

        txt = nom.strip()
        lower = txt.lower()

        # Table de correspondance
        MAPPINGS = {
            "qidistudio": "qidistudio",
            "qidislicer": "qidislicer",
            "prusaslicer": "prusaslicer",
            "bambu": "qidistudio", ########### en fait orca est d√©tect√© comme bambu car signature bambu
            "orca": "qidistudio", ########### Car m√™me traitement que qidistudio
            "creality": "qidistudio",
            "cura": "cura",
            "freecad": "freecad",
        }

        # Recherche automatique
        for key, value in MAPPINGS.items():
            if key in lower:
                return value

        # Sinon : retirer la version si pr√©sente
        if "-" in txt:
            return txt.split("-")[0]

        return txt
        
    with zipfile.ZipFile(file_path, 'r') as z:

        # ------------------------------------------------------------
        # 1. Compter les objets 3D (en filtrant les objets vides)
        # ------------------------------------------------------------
        with z.open('3D/3dmodel.model') as f:
            model = ET.parse(f)
            ns = {'m': 'http://schemas.microsoft.com/3dmanufacturing/core/2015/02'}

            objects = model.findall('.//m:object', ns)

            objets_valides = []
            for obj in objects:
                has_mesh = obj.find('.//m:mesh', ns) is not None
                has_components = obj.find('.//m:components', ns) is not None
                if has_mesh or has_components:
                    objets_valides.append(obj)

            # Si aucun objet valide ‚Üí fallback FreeCAD (mesh unique)
            if objets_valides:
                result['nombre_objets'] = len(objets_valides)
            else:
                meshes = model.findall('.//m:mesh', ns)
                result['nombre_objets'] = len(meshes) if meshes else 1

        # ------------------------------------------------------------
        # 2. D√©tecter le logiciel d'export
        # ------------------------------------------------------------
        logiciel_trouve = False

        metadata_file = '3D/3dmodel.model'

        with z.open(metadata_file) as f:
            metadata = ET.parse(f)
            root = metadata.getroot()
            ns = {'m': 'http://schemas.microsoft.com/3dmanufacturing/core/2015/02'}

            # --------------------------------------------------------
            # 2.a D√©tection classique <Creator> / <Application>
            # --------------------------------------------------------
           



            # 2.bis D√©tection QIDIStudio via m√©tadonn√©es "QIDIStudio:*"
            if not logiciel_trouve:
                metas = root.findall('.//metadata') + root.findall('.//m:metadata', ns)
                for meta in metas:
                    name = meta.get('name', '').lower()
                    if name.startswith("qidistudio:"):
                        result['logiciel'] = "qidistudio"
                        logiciel_trouve = True
                        break

            # --------------------------------------------------------
            # 2.b D√©tection Cura via namespace
            # --------------------------------------------------------
            if not logiciel_trouve:
                for k, v in root.attrib.items():
                    if "ultimaker.com/xml/cura" in v.lower():
                        result['logiciel'] = "Ultimaker Cura"
                        logiciel_trouve = True
                        break
                        
            # --------------------------------------------------------
            # 2.c D√©tection Cura via m√©tadonn√©es "cura:*"
            # --------------------------------------------------------
            if not logiciel_trouve:
                # 1) m√©tadonn√©es AVEC namespace
                metas = root.findall('.//m:metadata', ns)

                # 2) m√©tadonn√©es SANS namespace
                metas += root.findall('.//metadata')
                for meta in metas:
                    name = meta.get('name', '').lower()
                    if name.startswith("cura:"):
                        result['logiciel'] = "cura"
                        logiciel_trouve = True
                        break

            # --------------------------------------------------------
            # 2.d D√©tection via <metadata name="Application">
            # --------------------------------------------------------
            if not logiciel_trouve:
                creator = metadata.find('.//Creator') or metadata.find('.//Application')
                if creator is None:
                    for meta in root.findall('.//m:metadata', ns):
                        if meta.get('name', '').lower() == 'application':
                            creator = meta
                            break

                if creator is None:
                    for meta in root.findall('.//metadata'):
                        if meta.get('name', '').lower() == 'application':
                            creator = meta
                            break

                if creator is not None and creator.text:
                    result['logiciel'] = normaliser_logiciel(creator.text)
                    logiciel_trouve = True

                    

        # ------------------------------------------------------------
        # 4. D√©tection FreeCAD via texte brut
        # ------------------------------------------------------------
        if not logiciel_trouve:
            with z.open('3D/3dmodel.model') as f:
                content = f.read().decode('utf-8', errors='ignore')
                if "freecad" in content.lower():
                    result['logiciel'] = "freecad"
                else:
                    result['logiciel'] = "unknown"
    print('logicel trouv√© dans analyse_fichier_3mf',result)
    return result






def nameSlicer(File3mf: str):
    print('File3mf',File3mf)
    result = analyse_fichier_3mf(File3mf)
    return result['logiciel']

def is_qidistudio(zipin):
    names = zipin.namelist()

    # 1) Signature multi-objets QidiStudio
    if any(n.startswith("3D/Objects/") and n.endswith(".model") for n in names):

        # 2) Fichiers de configuration QidiStudio (ancien ou nouveau)
        if "Metadata/model_settings.config" in names:
            return True
        if "Metadata/model_settings.json" in names:
            return True

        # 3) Analyse du 3dmodel.model
        if "3D/3dmodel.model" in names:
            try:
                data = zipin.read("3D/3dmodel.model").decode("utf-8", "ignore").lower()

                # Signatures QidiStudio
                if "qidistudio" in data:
                    return True
                if "qidi" in data and "application" in data:
                    return True

                # Exclusion explicite Prusa/Slic3r
                if "prusaslicer" in data or "slic3r" in data:
                    return False

            except:
                pass

    return False


def is_qidislicer(zipin):
    names = zipin.namelist()

    # --- Signature moderne QidiSlicer (la seule fiable) ---
    if "3D/3dmodel.model" in names:
        try:
            data = zipin.read("3D/3dmodel.model").decode("utf-8", "ignore").lower()
            if "application" in data and "qidislicer" in data:
                return True
        except Exception as e:
            print("‚ö†Ô∏è is_qidislicer: erreur lecture 3dmodel.model :", e)
            return False

    # --- Anciennes signatures QidiSlicer (versions Cura-like) ---
    if "Metadata/plate.ini" in names:
        return True
    if "Metadata/print_settings.ini" in names and "Metadata/filament_settings.ini" in names:
        return True

    return False


def is_slic3r_style(zipin):
    """
    D√©tection des 3MF style Slic3r/Prusa/Orca/SuperSlicer.
    IMPORTANT :
    - QidiSlicer 1.2.5 utilise des fichiers Slic3r_PE ‚Üí NE PAS le classer ici.
    """

    names = zipin.namelist()

    # --- Exclusion PRIORITAIRE : QidiSlicer ---
    # (QidiSlicer moderne utilise des fichiers Slic3r_PE)
    try:
        if "3D/3dmodel.model" in names:
            data = zipin.read("3D/3dmodel.model").decode("utf-8", "ignore").lower()
            if "application" in data and "qidislicer" in data:
                return False  # surtout pas Slic3r
    except Exception as e:
        print("‚ö†Ô∏è is_slic3r_style: erreur lecture 3dmodel.model :", e)

    # --- 1) Signatures PrusaSlicer / Slic3r / SuperSlicer / Orca ---
    if any("Slic3r_PE" in n for n in names):
        return True
    if "Metadata/Prusa_Slicer_wipe_tower_information.xml" in names:
        return True

    # Multi-objets Slic3r/Orca
    if any(n.startswith("3D/Objects/") and n.endswith(".model") for n in names):
        return True

    # --- 2) Analyse du 3dmodel.model ---
    if "3D/3dmodel.model" in names:
        try:
            data = zipin.read("3D/3dmodel.model").decode("utf-8", "ignore").lower()

            if "prusaslicer" in data:
                return True
            if "slic3rpe" in data:
                return True
            if "slic3r" in data:
                return True
            if "superslicer" in data:
                return True
            if "orcaslicer" in data:
                return True

        except Exception as e:
            print("‚ö†Ô∏è is_slic3r_style: erreur lecture 3dmodel.model :", e)

    return False
"""
def is_curaOLD(zip_file):
    names = zip_file.namelist()

    # Cura a TOUJOURS un dossier Metadata/
    if not any(n.startswith("Metadata/") for n in names):
        return False

    # Cura a TOUJOURS un dossier Thumbnails/
    if not any(n.startswith("Thumbnails/") for n in names):
        return False

    # Cura n'a JAMAIS de structure Slic3r/Prusa
    if any(n.startswith("3D/Objects/") for n in names):
        return False

    return True
"""
   
def is_cura(File3mf):
    print('is_curaFile3mf')
    result = nameSlicer(File3mf) 
    return result == 'cura'

def is_freecad(File3mf):
    result = nameSlicer(File3mf)
    print('nameSlicer', result)
    return result == 'freecad'


def zip_contains_real_mesh(zip_path):
    """
    Retourne True si le 3MF contient au moins un <mesh>.
    Fonction fiable pour Cura, Qidi, Prusa, Orca, etc.
    """
    try:
        with zipfile.ZipFile(zip_path, "r") as zin:
            for name in zin.namelist():
                if name.endswith(".model"):
                    data = zin.read(name)
                    if b"<mesh" in data:
                        return True
    except Exception as e:
        print("‚ö†Ô∏è zip_contains_real_mesh Erreur lecture 3MF :", e)
    return False


# Recherche le fichier de g√©om√©trie principal dans une archive 3MF
def find_geom_file_in_3mf(zip_path):
    
    
    if not os.path.exists(zip_path):
        print(' dans find_geom_file_in_3mf fichier src_3mf inexistant',zip_path)    
    
    
    
    with zipfile.ZipFile(zip_path, 'r') as z:
        rels_name = "_rels/.rels"
        if rels_name in z.namelist():
            try:
                rels_text = z.read(rels_name).decode("utf-8")
                root = ET.fromstring(rels_text)
                for rel in root:
                    if rel.tag.endswith("Relationship"):
                        rtype = rel.attrib.get("Type", "")
                        if rtype.endswith("3dmodel"):
                            target = rel.attrib.get("Target")
                            if target and target.startswith("/"):
                                target = target[1:]
                            if target in z.namelist():
                                return target
            except Exception:
                pass
        for name in z.namelist():
            if fnmatch.fnmatch(name, "3D/Objects/*.model"):
                return name
        if "3D/3dmodel.model" in z.namelist():
            return "3D/3dmodel.model"
    return None

# R√©initialise la transformation des items en les centrant sur un point donn√©
def reset_item_transform(model_data, center=(CENTER_X, CENTER_Y, CENTER_Z)):
    text = model_data.decode("utf-8")
    new_transform = f'transform="1 0 0 0 1 0 0 0 1 {center[0]} {center[1]} {center[2]}"'
    text = re.sub(r'(<item[^>]*?)\s+transform="[^"]+"', r'\1 ' + new_transform, text)
    return text.encode("utf-8")

# Exporte une s√©lection en STL avec param√®tres de tessellation    
def export_stl_with_deflection(selection, stl_path,
                               linear_deflection=DEFAULT_LINEAR_DEFLECTION,
                               angular_deflection=DEFAULT_ANGULAR_DEFLECTION):
    doc = FreeCAD.ActiveDocument
    temp_objs = []
    try:
        for obj in selection:
            mesh = MeshPart.meshFromShape(
                Shape=obj.Shape,
                LinearDeflection=float(linear_deflection),
                AngularDeflection=float(angular_deflection)
            )
            mobj = doc.addObject("Mesh::Feature", f"TempMeshSTL_{obj.Name}")
            mobj.Mesh = mesh
            temp_objs.append(mobj)
        doc.recompute()
        Mesh.export(temp_objs, stl_path)
    finally:
        for t in temp_objs:
            try: doc.removeObject(t.Name)
            except Exception: pass
        doc.recompute()

# Exporte une s√©lection en 3MF avec param√®tres de tessellation
def export_selection_with_deflection(selection, out_3mf_path,
                                     linear_deflection=DEFAULT_LINEAR_DEFLECTION,
                                     angular_deflection=DEFAULT_ANGULAR_DEFLECTION):
    doc = FreeCAD.ActiveDocument
    temp_objs = []
    try:
        for obj in selection:
            mesh = MeshPart.meshFromShape(
                Shape=obj.Shape,
                LinearDeflection=float(linear_deflection),
                AngularDeflection=float(angular_deflection))
            mobj = doc.addObject("Mesh::Feature", f"TempMesh_{obj.Name}")
            mobj.Mesh = mesh
            temp_objs.append(mobj)
        doc.recompute()
        Mesh.export(temp_objs, out_3mf_path)
    finally:
        for t in temp_objs:
            try: doc.removeObject(t.Name)
            except Exception: pass
        doc.recompute()


# Force uniquement la composante Z des transformations dans le mod√®le 3MF
def force_zmax_in_transform(model_data, zmax):
    """
    Remplace uniquement la composante Z (12e valeur) du transform des <item> dans 3dmodel.model.
    - Conserve X/Y et la matrice de rotation/√©chelle.
    - zmax est un float (hauteur max des vertex) calcul√© par recenter_vertices.

    Si plusieurs <item> existent, on les met tous √† jour.
    """
    try:
        text = model_data.decode("utf-8")

        def repl(m):
            nums = m.group(1).split()
            # transform = 12 nombres : 9 pour la matrice, 3 pour la translation (X, Y, Z)
            if len(nums) == 12:
                nums[-1] = f"{zmax}"
                return 'transform="' + " ".join(nums) + '"'
            # Si format inattendu, on ne modifie pas
            return m.group(0)

        # Met √† jour tous les transform="..."; count=0 = sans limite
        text = re.sub(r'transform="([^"]+)"', repl, text, count=0)
        return text.encode("utf-8")
    except Exception as e:
        print("‚ö†Ô∏è force_zmax_in_transform: √©chec, on garde le transform d'origine :", e)
        return model_data


# Recentre les sommets en XY et calcule le Zmax pour placement correct
def recenter_vertices(model_data, slicer_target, slicer_source, fc_3mf_existed_at_start):
    """
    Recentrage des vertex en X/Y et calcul du Zmax pour placement correct sur le plateau.
    Retourne : (donn√©es XML modifi√©es, zmax)
    """
    try:
        print('Recentrage des vertex en X/Y et calcul du Zmax pour placement correct sur le plateau')
        ET.register_namespace('', "http://schemas.microsoft.com/3dmanufacturing/core/2015/02")
        root = ET.fromstring(model_data.decode("utf-8"))
        ns = {"ns": "http://schemas.microsoft.com/3dmanufacturing/core/2015/02"}
        verts = root.findall(".//ns:vertex", ns)

        if not verts:
            # Aucun sommet trouv√© ‚Üí avertissement et retour inchang√©
            show_message(tr("warn_title"), tr("warn_no_geom_vertices"))
            return model_data, CENTER_Z

        xs = [float(v.attrib["x"]) for v in verts]
        ys = [float(v.attrib["y"]) for v in verts]
        zs = [float(v.attrib["z"]) for v in verts]
        centerx = 0
        centery = 0
        print('slicer_target',slicer_target)
        print('slicer_source',slicer_source)
        print('fc_3mf_existed_at_start',fc_3mf_existed_at_start)
        """
        if slicer_target in ['cura'] and slicer_source in ['freecad']: ##################################"fc_3mf_existed_at_start
            centerx = CENTER_X
            centery = CENTER_Y  
            print('center_x',centerx)
        """

        # Calcul du centre XY et du Zmax
        xc, yc = (min(xs) + max(xs)) / 2.0, (min(ys) + max(ys)) / 2.0
        zmax = max(zs)

        # Recentrage XY
        for v in verts:
            v.attrib["x"] = str(float(v.attrib["x"]) - xc + centerx) 
            v.attrib["y"] = str(float(v.attrib["y"]) - yc + centery)
        return ET.tostring(root, encoding="utf-8", xml_declaration=False), zmax

    except Exception as e:
        print("‚ö†Ô∏è Erreur recentrage vertex :", e)
        return model_data, CENTER_Z

def clean_qidi_style(src_3mf, dst_3mf):
    """
    Nettoie un 3MF QidiSlicer moderne (Cura-like).
    - Garde uniquement le premier <object> et son <item> dans 3D/3dmodel.model
    - Supprime les autres objets et items
    - Nettoie Metadata/Slic3r_PE_model.config pour ne garder que l'objet conserv√©
    - Garantit la pr√©sence du fichier 3D/_rels/3dmodel.model.rels
    """

    model_path = "3D/3dmodel.model"
    rels_path = "3D/_rels/3dmodel.model.rels"
    config_path = "Metadata/Slic3r_PE_model.config"
    
    
    if not os.path.exists(src_3mf):
        print(' dans clean_qidi_style fichier src_3mf inexistant',src_3mf)

    with zipfile.ZipFile(src_3mf, "r") as zin:
        # --- Nettoyage du 3dmodel.model ---
        model_xml = zin.read(model_path).decode("utf-8")
        root = ET.fromstring(model_xml)
        ns = {"m": "http://schemas.microsoft.com/3dmanufacturing/core/2015/02"}

        objects = root.findall("m:resources/m:object", ns)
        items = root.findall("m:build/m:item", ns)

        keep_object_id = None
        removed_ids = []

        if objects:
            keep_object_id = objects[0].attrib.get("id")

        # Supprimer les objets exc√©dentaires
        for obj in objects[1:]:
            removed_ids.append(obj.attrib.get("id"))
            root.find("m:resources", ns).remove(obj)

        # Supprimer les items exc√©dentaires
        for item in items:
            if item.attrib.get("objectid") != keep_object_id:
                removed_ids.append(item.attrib.get("objectid"))
                root.find("m:build", ns).remove(item)

        new_model_xml = ET.tostring(root, encoding="utf-8")

        # --- Nettoyage du Slic3r_PE_model.config ---
        if config_path in zin.namelist():
            cfg_xml = zin.read(config_path).decode("utf-8")
            cfg_root = ET.fromstring(cfg_xml)

            for obj in cfg_root.findall("object"):
                if obj.attrib.get("id") != keep_object_id:
                    removed_ids.append(obj.attrib.get("id"))
                    cfg_root.remove(obj)

            new_cfg_xml = ET.tostring(cfg_root, encoding="utf-8")
        else:
            new_cfg_xml = None

        # --- R√©√©criture du ZIP nettoy√© ---
        
        if not os.path.exists(src_3mf):
            print(' dans clean_qidi_style fichier src_3mf inexistant',src_3mf)        
        
        
        with zipfile.ZipFile(dst_3mf, "w", compression=zipfile.ZIP_DEFLATED) as zout:
            for item in zin.infolist():
                name = item.filename
                if name == model_path:
                    zout.writestr(name, new_model_xml)
                    continue
                if name == config_path and new_cfg_xml:
                    zout.writestr(name, new_cfg_xml)
                    continue
                zout.writestr(name, zin.read(name))

            # Garantir la pr√©sence du rels
            if rels_path not in zin.namelist():
                rels_content = """<?xml version='1.0' encoding='UTF-8'?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
 <Relationship Target="/3D/3dmodel.model" Id="rel0" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" />
</Relationships>
"""
                zout.writestr(rels_path, rels_content)

    print(f"‚úÖ Nettoyage QidiSlicer termin√©. Objet conserv√© id={keep_object_id}")
    if removed_ids:
        print(f"   Objets supprim√©s : {removed_ids}")
    else:
        print("   Aucun objet supprim√© (mono-objet d√©j√†).")
    print(f"   Fichier nettoy√© : {dst_3mf}")


def clean_multi_object_style(src_3mf, dst_3mf, mode="qidi"):
    """
    Nettoyage CHIRURGICAL d'un 3MF QidiStudio.
    Version corrig√©e + PATCH chemins :
    - Normalisation des chemins (strip + replace)
    - D√©tection correcte du parent (object id="X")
    - Suppression des objets exc√©dentaires
    - Suppression des items exc√©dentaires
    - Suppression des relations exc√©dentaires
    - Nettoyage complet de Metadata/model_settings.config
    """

    print("\n=== Nettoyage CHIRURGICAL QidiStudio ===")
    if not os.path.exists(src_3mf):
        print(' dans clean_multi_object_style fichier src_3mf inexistant',src_3mf)

    rels_path = "3D/_rels/3dmodel.model.rels"
    config_path = "Metadata/model_settings.config"
    model_path = "3D/3dmodel.model"


    with zipfile.ZipFile(src_3mf, "r") as zin:

        # --- 1) D√©tection des fichiers objets ---
        object_models = [
            n.strip().replace("\\", "/")
            for n in zin.namelist()
            if n.startswith("3D/Objects/") and n.endswith(".model")
        ]

        print(f"üìÅ Objets trouv√©s : {object_models}")

        if not object_models:
            print("‚ö†Ô∏è Aucun objet trouv√© ‚Üí fichier non conforme QidiStudio")
            return None, None

        keep_model = object_models[0]
        to_delete = object_models[1:]

        print(f"‚û°Ô∏è Objet conserv√© : {keep_model}")
        print(f"üóëÔ∏è Objets supprim√©s : {to_delete}")

        # --- 2) Nettoyage CHIRURGICAL du 3dmodel.model ---
        model_txt = zin.read(model_path).decode("utf-8")

        # D√©tection du parent r√©el
        parent_pattern = (
            rf'<object[^>]*id="(\d+)"[^>]*>[\s\S]*?'
            rf'<component[^>]*p:path="/{keep_model}"'
        )
        m = re.search(parent_pattern, model_txt)

        if not m:
            print("‚ùå Impossible de trouver l'objet parent dans 3dmodel.model")
            return None, keep_model

        keep_object_id = m.group(1)
        print(f"‚û°Ô∏è ID parent conserv√© : {keep_object_id}")

        # SUPPRESSION des <object> exc√©dentaires
        model_txt_before = model_txt
        model_txt = re.sub(
            rf'<object[^>]*id="(?!{keep_object_id}")([\s\S]*?)</object>',
            '',
            model_txt
        )
        if model_txt != model_txt_before:
            print("üóëÔ∏è Objets exc√©dentaires supprim√©s dans 3dmodel.model")

        # SUPPRESSION des <item> exc√©dentaires
        model_txt_before = model_txt
        model_txt = re.sub(
            rf'<item[^>]*objectid="(?!{keep_object_id}")([^"]*)"[^>]*/>',
            '',
            model_txt
        )
        if model_txt != model_txt_before:
            print("üóëÔ∏è Items exc√©dentaires supprim√©s dans <build>")

        # --- 3) Nettoyage du rels ---
        if rels_path in zin.namelist():
            rels_txt = zin.read(rels_path).decode("utf-8")
            rels_before = rels_txt

            rels_txt = re.sub(
                rf'<Relationship[^>]*Target="(?!/{keep_model}")([^"]*)"[^>]*/>',
                '',
                rels_txt
            )

            if rels_txt != rels_before:
                print("üóëÔ∏è Relations exc√©dentaires supprim√©es dans rels")

        # --- 4) Nettoyage complet du model_settings.config ---
        if config_path in zin.namelist():
            cfg_txt = zin.read(config_path).decode("utf-8")

            # SUPPRESSION <object id="...">
            cfg_before = cfg_txt
            cfg_txt = re.sub(
                rf'<object[^>]*id="(?!{keep_object_id}")([\s\S]*?)</object>',
                '',
                cfg_txt
            )
            if cfg_txt != cfg_before:
                print("üóëÔ∏è Objets exc√©dentaires supprim√©s dans model_settings.config")

            # SUPPRESSION <model_instance>
            cfg_before = cfg_txt
            cfg_txt = re.sub(
                rf'<model_instance>[\s\S]*?<metadata key="object_id" value="(?!{keep_object_id}")([\s\S]*?)</model_instance>',
                '',
                cfg_txt
            )
            if cfg_txt != cfg_before:
                print("üóëÔ∏è model_instance exc√©dentaires supprim√©s")

            # SUPPRESSION <assemble_item>
            cfg_before = cfg_txt
            cfg_txt = re.sub(
                rf'<assemble_item[^>]*object_id="(?!{keep_object_id}")([^"]*)"[^>]*/>',
                '',
                cfg_txt
            )
            if cfg_txt != cfg_before:
                print("üóëÔ∏è assemble_item exc√©dentaires supprim√©s")

        # --- 5) R√©√©criture du ZIP ---
        print("üì¶ R√©√©criture du fichier nettoy√©‚Ä¶")

        compression = zipfile.ZIP_STORED if mode == "qidi" else zipfile.ZIP_DEFLATED
        with zipfile.ZipFile(dst_3mf, "w", compression=compression) as zout:
            for item in zin.infolist():
                name = item.filename.strip().replace("\\", "/")

                # SUPPRESSION des fichiers objets exc√©dentaires
                if name.startswith("3D/Objects/") and name != keep_model:
                    print(f"üóëÔ∏è Suppression fichier : {name}")
                    continue

                if name == model_path:
                    zout.writestr(name, model_txt)
                    continue

                if name == rels_path:
                    zout.writestr(name, rels_txt)
                    continue

                if name == config_path:
                    zout.writestr(name, cfg_txt)
                    continue

                zout.writestr(name, zin.read(item.filename))

    print("‚úÖ Nettoyage CHIRURGICAL termin√©.")
    print(f"‚û°Ô∏è Objet final conserv√© : {keep_model} (id={keep_object_id})")
    print(f"‚û°Ô∏è Fichier nettoy√© : {dst_3mf}")

    return keep_object_id, keep_model


def clean_prusa_style(src_3mf, dst_3mf):
    """
    Nettoyage complet pour PrusaSlicer :
    - Cas 1 : mono-objet ‚Üí copie brute
    - Cas 2 : duplications dans <build> ‚Üí garder un seul <item>
    - Cas 3 : multi-objets r√©els dans <resources> ‚Üí garder un seul objet
    """

    print("\n=== Nettoyage PrusaSlicer ===")

    model_path = "3D/3dmodel.model"
    rels_path = "3D/_rels/3dmodel.model.rels"
    config_path = "Metadata/Slic3r_PE_model.config"
    
    if not os.path.exists(src_3mf):
        print(' dans clean_prusa_style fichier src_3mf inexistant',src_3mf) 

    with zipfile.ZipFile(src_3mf, "r") as zin:

        # --- 1) Lire le mod√®le principal ---
        model_txt = zin.read(model_path).decode("utf-8")

        # --- 2) D√©tecter les objets dans <resources> ---
        objects = re.findall(r'<object[^>]*id="(\d+)"', model_txt)
        objects = list(dict.fromkeys(objects))  # unique

        print(f"üì¶ Objets trouv√©s dans <resources> : {objects}")

        # CAS 1 : Mono-objet ‚Üí rien √† nettoyer
        if len(objects) <= 1:
            print("‚û°Ô∏è Mono-objet Prusa ‚Üí copie brute")
            shutil.copy(src_3mf, dst_3mf)
            return objects[0] if objects else None, model_path

        # CAS 2 : Multi-objets r√©els
        keep_object_id = objects[0]
        delete_ids = objects[1:]

        print(f"‚û°Ô∏è Objet conserv√© : {keep_object_id}")
        print(f"üóëÔ∏è Objets supprim√©s : {delete_ids}")

        # --- Nettoyage du 3dmodel.model ---
        # Supprimer les <object> exc√©dentaires
        for oid in delete_ids:
            model_txt = re.sub(
                rf'<object[^>]*id="{oid}"[\s\S]*?</object>',
                '',
                model_txt
            )

        # Supprimer les <item> exc√©dentaires
        model_txt = re.sub(
            rf'<item[^>]*objectid="(?!{keep_object_id}")([^"]*)"[^>]*/>',
            '',
            model_txt
        )

        # --- Nettoyage du fichier Slic3r_PE_model.config ---
        if config_path in zin.namelist():
            cfg_txt = zin.read(config_path).decode("utf-8")

            for oid in delete_ids:
                cfg_txt = re.sub(
                    rf'<object[^>]*id="{oid}"[\s\S]*?</object>',
                    '',
                    cfg_txt
                )

        # --- Nettoyage du rels ---
        if rels_path in zin.namelist():
            rels_txt = zin.read(rels_path).decode("utf-8")
            rels_txt = re.sub(
                rf'<Relationship[^>]*Target="[^"]*object_{delete_ids[0]}\.model"[^>]*/>',
                '',
                rels_txt
            )

        # --- R√©√©criture du ZIP ---
        print("üì¶ R√©√©criture du fichier nettoy√©‚Ä¶")

        with zipfile.ZipFile(dst_3mf, "w", compression=zipfile.ZIP_DEFLATED) as zout:
            for item in zin.infolist():
                name = item.filename.replace("\\", "/")

                if name == model_path:
                    zout.writestr(name, model_txt)
                    continue

                if name == config_path:
                    zout.writestr(name, cfg_txt)
                    continue

                if name == rels_path:
                    zout.writestr(name, rels_txt)
                    continue

                zout.writestr(name, zin.read(item.filename))

    print("‚úÖ Nettoyage PrusaSlicer termin√©.")
    print(f"‚û°Ô∏è Objet final conserv√© : {keep_object_id}")
    print(f"‚û°Ô∏è Fichier nettoy√© : {dst_3mf}")

    return keep_object_id, model_path



def replace_mesh_in_model_xml(old_model_xml_bytes, new_model_xml_bytes):
    """
    Remplace uniquement le <mesh> dans le mod√®le Qidi.
    Conserve :
      - le root <model> d'origine
      - les namespaces (dont slic3rpe)
      - les m√©tadonn√©es (dont Application=QIDISlicer-1.2.5)
      - les <resources>, <build>, <item>, transforms, etc.

    old_model_xml_bytes : contenu du 3dmodel.model Qidi
    new_model_xml_bytes : contenu du 3dmodel.model FreeCAD recentr√©
    """

    # D√©codage robuste
    old_text = old_model_xml_bytes.decode("utf-8", errors="replace")
    new_text = new_model_xml_bytes.decode("utf-8", errors="replace")

    # Parsing XML
    old_root = ET.fromstring(old_text)
    new_root = ET.fromstring(new_text)

    # Namespace principal
    ns_uri = old_root.tag.split("}")[0].strip("{") if "}" in old_root.tag else ""
    ns = {"m": ns_uri} if ns_uri else {}

    # Trouver les <mesh>
    old_mesh = old_root.find(".//m:mesh", ns) if ns else old_root.find(".//mesh")
    new_mesh = new_root.find(".//m:mesh", ns) if ns else new_root.find(".//mesh")

    if old_mesh is None or new_mesh is None:
        print("‚ö†Ô∏è Impossible de trouver <mesh> dans l'un des fichiers.")
        return old_model_xml_bytes

    # Remplacer le contenu du <mesh> d'origine
    for child in list(old_mesh):
        old_mesh.remove(child)
    for child in list(new_mesh):
        old_mesh.append(child)

    # Re-s√©rialisation
    xml_bytes = ET.tostring(old_root, encoding="utf-8")
    xml_decl = b'<?xml version="1.0" encoding="UTF-8"?>\n'

    if not xml_bytes.startswith(b"<?xml"):
        xml_bytes = xml_decl + xml_bytes

    return xml_bytes



def inject_geometry_into_qidi_3mf(old_3mf_path, new_3mf_path, new_model_xml_bytes):
    """
    Construit un nouveau 3MF Qidi en rempla√ßant uniquement le <mesh> dans 3D/3dmodel.model.
    Conserve :
      - [Content_Types].xml
      - _rels/.rels
      - Metadata/*
      - namespaces
      - Application=QIDISlicer-1.2.5
      - transforms
    """


    if not os.path.exists(old_3mf_path):
        print(' dans inject_geometry_into_qidi_3mf fichier src_3mf inexistant',old_3mf_path) 

    with zipfile.ZipFile(old_3mf_path, "r") as zin, \
         zipfile.ZipFile(new_3mf_path, "w", compression=zipfile.ZIP_DEFLATED) as zout:

        for info in zin.infolist():
            name = info.filename
            data = zin.read(name)

            # On remplace uniquement 3D/3dmodel.model
            if name == "3D/3dmodel.model":
                merged = replace_mesh_in_model_xml(data, new_model_xml_bytes)
                zout.writestr(name, merged)
                continue

            # Tous les autres fichiers sont recopi√©s tels quels
            zout.writestr(name, data)


def ask_incompatible_slicer_dialog(s_source, s_target):
    """
    Bo√Æte de dialogue Qt en cas de slicer source != slicer cible.
    Retourne: "keep", "delete" ou "cancel".
    """
    msg = QtGui.QMessageBox()
    msg.setIcon(QtGui.QMessageBox.Warning)
    msg.setWindowTitle(tr("warn_title"))

    # Texte multilingue avec insertion des valeurs
    txt = tr("warn_incompatible_slicer_dialog").format(
        source=s_source,
        target=s_target
    )
    msg.setText(txt)

    # Boutons 
    #btn_keep = msg.addButton(tr("btn_keep"), QtGui.QMessageBox.AcceptRole)
    btn_delete = msg.addButton(tr("btn_delete"), QtGui.QMessageBox.DestructiveRole)
    btn_cancel = msg.addButton(tr("btn_cancel"), QtGui.QMessageBox.RejectRole)

    msg.exec()

    #if msg.clickedButton() == btn_keep:
    #    return "keep"
    if msg.clickedButton() == btn_delete:
        return "delete"
    return "cancel"


def prepare_environment():
    """
    Pr√©pare l‚Äôenvironnement :
    - charge la config
    - v√©rifie le document FreeCAD
    - d√©tecte le .3mf existant
    - renomme en .old.3mf si n√©cessaire

    Retourne :
        (cfg, doc, base_name, fc_3mf, old_3mf_backup, fc_3mf_existed_at_start)
    ou None en cas d‚Äôerreur.
    """

    cfg = load_config()

    # V√©rification document
    doc = FreeCAD.ActiveDocument
    if not doc:
        show_message(tr("error_title"), tr("error_no_doc"))
        return None

    fcstd_path = doc.FileName
    if not fcstd_path:
        show_message(tr("error_title"), tr("error_no_save"))
        return None

    # Construction des chemins
    base_name = os.path.splitext(fcstd_path)[0]
    fc_3mf = base_name + ".3mf"
    old_3mf_backup = base_name + ".old.3mf"

    # D√©tection du .3mf existant AVANT export
    fc_3mf_existed_at_start = os.path.exists(fc_3mf)
    """
    # Sauvegarde de l'ancien 3MF (seulement si le .3mf existait au d√©part)
    if fc_3mf_existed_at_start:
        try:
            shutil.move(fc_3mf, old_3mf_backup) ################################################ Sans doute √† placer apr√®s la boite de dialogue pour ne le faire que si pas annuler
        except Exception as e:
            show_message(tr("error_title"), f"{tr('error_backup_3mf')} {e}")
            return None
    """
    return (cfg, doc, base_name, fc_3mf, old_3mf_backup, fc_3mf_existed_at_start)


def get_valid_selection(fc_3mf, old_3mf_backup, fc_3mf_existed_at_start):
    """
    V√©rifie la s√©lection FreeCAD :
    - 0 objet ‚Üí message + restauration √©ventuelle
    - >1 objet ‚Üí message + restauration √©ventuelle
    Retourne :
        [obj]  ‚Üí s√©lection valide
        None   ‚Üí erreur ou annulation
    """

    # R√©cup√©ration des objets s√©lectionn√©s ayant une Shape valide
    selection = [
        obj for obj in FreeCADGui.Selection.getSelection()
        if hasattr(obj, "Shape") and obj.Shape is not None
    ]

    # Aucun objet s√©lectionn√©
    if not selection:
        show_message(tr("warn_title"), tr("warn_no_selection"))

        # Restauration √©ventuelle du .old.3mf
        if fc_3mf_existed_at_start \
           and os.path.exists(old_3mf_backup) \
           and not os.path.exists(fc_3mf):
            shutil.move(old_3mf_backup, fc_3mf)

        return None

    # Trop d‚Äôobjets s√©lectionn√©s
    if len(selection) > 1:
        show_message(tr("warn_title"), tr("warn_multi_selection"))

        # Restauration √©ventuelle du .old.3mf
        if fc_3mf_existed_at_start \
           and os.path.exists(old_3mf_backup) \
           and not os.path.exists(fc_3mf):
            shutil.move(old_3mf_backup, fc_3mf)

        return None

    # S√©lection valide : un seul objet
    return selection


def get_user_options(cfg):
    """
    Affiche la bo√Æte de dialogue utilisateur :
    - param√®tres FreeCAD
    - positions
    - STL
    - slicer
    - commandes externes

    G√®re :
    - annulation
    - validation du chemin du slicer
    - sauvegarde des pr√©f√©rences

    Retourne :
        (keep_params, keep_positions, generate_stl,
         slicer_path, launch_slicer,
         linear_value, angular_value, extra_cmds)
    ou None si annulation.
    """

    # Pr√©f√©rences actuelles
    slicer_path_pref = cfg.get("slicer_exe", DEFAULT_SLICER_EXE)
    linear_pref = cfg.get("linear_deflection", DEFAULT_LINEAR_DEFLECTION)
    angular_pref = cfg.get("angular_deflection", DEFAULT_ANGULAR_DEFLECTION)

    while True:
        # Appel de la bo√Æte de dialogue utilisateur
        (keep_params, keep_positions, generate_stl,
         slicer_path, launch_slicer,
         linear_value, angular_value, extra_cmds) = ask_user_options(
            slicer_path_pref, linear_pref, angular_pref
        )

        # Annulation
        if slicer_path is None and launch_slicer is None:
            show_message(tr("info_title"), tr("info_cancel"))
            return None

        # Validation du chemin du slicer
        if launch_slicer and slicer_path and not os.path.exists(slicer_path):
            show_message(tr("error_title"), f"{tr('error_invalid_slicer')}\n{slicer_path}")
            continue

        # Options valides ‚Üí on sort de la boucle
        break

    # Sauvegarde des pr√©f√©rences
    save_settings(
        linear=linear_value,
        angular_rad=angular_value,
        slicer_path=slicer_path
    )

    return (keep_params, keep_positions, generate_stl,
            slicer_path, launch_slicer,
            linear_value, angular_value, extra_cmds)


def export_freecad_files(selection, base_name, fc_3mf, generate_stl,
                         linear_value, angular_value,
                         fc_3mf_existed_at_start, old_3mf_backup):
    """
    Exporte :
    - 3MF FreeCAD
    - STL si demand√©

    G√®re :
    - erreurs d‚Äôexport
    - restauration √©ventuelle du .old.3mf

    Retourne :
        True  ‚Üí export OK
        False ‚Üí erreur ou restauration
    """

    # ------------------------------------------------------------
    # Export 3MF FreeCAD
    # ------------------------------------------------------------
    try:
        export_selection_with_deflection(
            selection, fc_3mf,
            linear_deflection=linear_value,
            angular_deflection=angular_value
        )
    except Exception as e:
        show_message(tr("error_title"), f"{tr('error_export_3mf')} {e}")

        # Restauration √©ventuelle
        if fc_3mf_existed_at_start \
           and os.path.exists(old_3mf_backup) \
           and not os.path.exists(fc_3mf):
            shutil.move(old_3mf_backup, fc_3mf)

        return False

    # ------------------------------------------------------------
    # Export STL (optionnel)
    # ------------------------------------------------------------
    if generate_stl:
        try:
            export_stl_with_deflection(
                selection, base_name + ".stl",
                linear_deflection=linear_value,
                angular_deflection=angular_value
            )
        except Exception as e:
            show_message(tr("error_title"), f"{tr('error_generate_stl')} {e}")
            # On continue malgr√© l‚Äôerreur STL

    return True

def handle_empty_plate(fc_3mf_existed_at_start, old_3mf_backup, fc_3mf):
    """
    Analyse le plateau vide sur old_3mf_backup:
    - Si un 3MF existait avant l‚Äôexport FreeCAD
    - Si old_3mf_backup ne contient aucun mesh r√©el
    ‚Üí propose :
        ‚Ä¢ Restaurer l'ancien 3MF
        ‚Ä¢ Repartir √† z√©ro
        ‚Ä¢ Annuler

    Peut relancer la macro automatiquement.

    Retourne :
        True  ‚Üí continuer le workflow
        False ‚Üí arr√™ter la macro
    """

    # On ne teste le plateau vide QUE si un 3MF existait avant l‚Äôexport
    if not fc_3mf_existed_at_start:
        return True

    # V√©rifie si fc_3mf existe et contient un vrai mesh
    if not (os.path.exists(fc_3mf) and not zip_contains_real_mesh(fc_3mf)):
        return True  # Pas de plateau vide ‚Üí on continue

    # Plateau vide d√©tect√© ‚Üí bo√Æte de dialogue
    msg = tr("warn_empty_plate")

    box = QtGui.QMessageBox()
    box.setWindowTitle(tr("warn_empty_plate_title"))
    box.setText(msg)

    restore_btn = box.addButton(tr("btn_restore_old_3mf"), QtGui.QMessageBox.AcceptRole)
    reset_btn   = box.addButton(tr("btn_reset_new_project"), QtGui.QMessageBox.DestructiveRole)
    cancel_btn  = box.addButton(QtGui.QMessageBox.Cancel)

    box.exec()
    clicked = box.clickedButton()

    # ----------------------------------------------------------------------------
    # 1) Restaurer l'ancien 3MF = Copie old_3mf_backup en fc_3mf et relance la macro
    # ----------------------------------------------------------------------------
    if clicked == restore_btn:
        #if os.path.exists(fc_3mf):
        #    print('Effacement du fichier ', fc_3mf)
        #    os.remove(fc_3mf)     
        shutil.copy(old_3mf_backup, fc_3mf)
        print ('copie du fichier', old_3mf_backup, ' en ', fc_3mf)  

        #----------------------Relance de la macro -----------------------------------
        export_replace_geometry()
        return False  # On arr√™te ce cycle

    # ------------------------------------------------------------
    # 2) Repartir √† z√©ro = on efface fc_3mf et on relance la macro
    # ------------------------------------------------------------
    elif clicked == reset_btn:
        if os.path.exists(fc_3mf):
            os.remove(fc_3mf)
        print("üóëÔ∏è Nouveau projet : 3MF FreeCAD supprim√©. Relance de la macro.")
        export_replace_geometry()
        return False  # On arr√™te ce cycle

    # ------------------------------------------------------------
    # 3) Annuler 
    # ------------------------------------------------------------
    else:
        print("‚ÑπÔ∏è Annul√© par l‚Äôutilisateur.")
        return False


def inject_geometry_if_possible(base_name, fc_3mf, old_3mf_backup, fc_3mf_existed_at_start,
                                slicer_path, keep_params, keep_positions):
    """
    Injection g√©om√©trique :
    - D√©tecte le slicer source (QidiStudio, QidiSlicer, Slic3r/Prusa/Orca, Cura)
    - V√©rifie compatibilit√© avec le slicer cible
    - Nettoie le 3MF source selon le slicer
    - Injecte la g√©om√©trie FreeCAD
    - Reconstruit le 3MF final

    Ne retourne rien (effets sur fichiers).
    """

    # ------------------------------------------------------------
    # 1) V√©rifier si injection possible
    # ------------------------------------------------------------
    is_slicer_file = os.path.exists(old_3mf_backup) and zip_contains_real_mesh(old_3mf_backup)
    inject_possible = fc_3mf_existed_at_start and is_slicer_file

    slicer_source = "unknown" ####################################" A supprimer ?
    slicer_target = None    ####################################" A supprimer ?

    if not inject_possible:
        print("‚úÖ Fichier g√©n√©r√© uniquement par FreeCAD :", fc_3mf)
        return

    # ------------------------------------------------------------
    # 2) D√©tection du slicer source 
    # ------------------------------------------------------------
    """
    if os.path.exists(old_3mf_backup): ###############"" A retrirerle test et le else car  fait dans nameSlicer
     
        
        if not os.path.exists(old_3mf_backup):
            print(' dans inject_geometry_into_qidi_3mf fichier src_3mf inexistant',old_3mf_backup)     
    
        with zipfile.ZipFile(old_3mf_backup, "r") as zin:
            if is_qidistudio(zin):
                print("   üîé Slicer d√©tect√© (source) : qidiStudio")
                slicer_source = "qidistudio"
            elif is_qidislicer(zin):
                print("   üîé Slicer d√©tect√© (source) : qidiSlicer")
                slicer_source = "qidislicer"
            elif is_slic3r_style(zin) and not is_qidislicer(zin):
                print("   üîé Slicer d√©tect√© (source) : slic3r/Orca/Prusa")
                slicer_source = "slic3r"
            #elif is_cura(zin):
            elif is_cura(old_3mf_backup):
                print("   üîé Slicer d√©tect√© (source) : cura")
                slicer_source = "cura"
            elif is_freecad(old_3mf_backup):
                print("   üîé Slicer d√©tect√© (source) : freecad")
                slicer_source = "freecad"    
            else:
                print("   üîé Slicer d√©tect√© (source) : unknown")
                slicer_source = "unknown"
            print('A comparer avec ',slicer_source)
        
    else:
        slicer_source = 'none'
    """    
    slicer_source = nameSlicer(old_3mf_backup)
    print ('1845 2) d√©tection du slicer source slicer_source =', slicer_source)

    # ------------------------------------------------------------
    # 3) D√©tection du slicer cible
    # ------------------------------------------------------------
    slicer_target = detect_slicer_target_from_path(slicer_path) if slicer_path else None
    

    # ------------------------------------------------------------
    # 4) Gestion des incompatibilit√©s
    # ------------------------------------------------------------
    if slicer_target not in (None, "unknown") and slicer_source not in ("none", "unknown", "freecad") \
       and slicer_source != slicer_target:
        action = ask_incompatible_slicer_dialog(slicer_source, slicer_target)
        print('action', action)
        if action == "cancel":
            if os.path.exists(fc_3mf):
                os.remove(fc_3mf)
            if fc_3mf_existed_at_start and os.path.exists(old_3mf_backup):
                shutil.move(old_3mf_backup, fc_3mf) ######################################## A REMPLACER PAR UN COPY ?
            print("‚ùå Op√©ration annul√©e par l‚Äôutilisateur (slicers incompatibles).")
            return

        if action == "delete":
            print("üóëÔ∏è Suppression de l‚Äôancien 3MF incompatible.")
            try:
                os.remove(old_3mf_backup)
            except Exception as e:
                print("‚ö†Ô∏è Impossible de supprimer l‚Äôancien 3MF :", e)
            inject_possible = False


    if not inject_possible:
        print("‚ö†Ô∏è Injection impossible, export FreeCAD seul.")
        return

    
    # ------------------------------------------------------------
    # 5) Nettoyage du 3MF selon le slicer source
    # ------------------------------------------------------------
    cleaned_old_3mf = base_name + ".cleaned.3mf"
    keep_model = None

    if slicer_source == "qidistudio" and os.path.exists(old_3mf_backup):
        keep_object_id, keep_model = clean_multi_object_style(
            old_3mf_backup, cleaned_old_3mf, mode="qidi"
        )

    elif slicer_source == "qidislicer":
        clean_qidi_style(old_3mf_backup, cleaned_old_3mf)
        keep_model = None

    elif slicer_source == "slic3r":
        keep_object_id, keep_model = clean_prusa_style(
            old_3mf_backup,
            cleaned_old_3mf
        )

    else:
        shutil.copy(old_3mf_backup, cleaned_old_3mf)
        keep_model = "3D/Objects/object_1.model"

    old_3mf = cleaned_old_3mf

    # ------------------------------------------------------------
    # 6) Extraction g√©om√©trie FreeCAD
    # ------------------------------------------------------------
    geom_entry = find_geom_file_in_3mf(fc_3mf)
    if not geom_entry:
        show_message(tr("error_title"), tr("error_no_geom"))
        return
        
    if not os.path.exists(fc_3mf):
            print(' dans inject_geometry_into_qidi_3mf fichier src_3mf inexistant',fc_3mf)  

    with zipfile.ZipFile(fc_3mf, 'r') as fc_zip:
        geom_data = fc_zip.read(geom_entry)

    geom_data_centered, zmax = recenter_vertices(geom_data, slicer_target, slicer_source, fc_3mf_existed_at_start)

    # ------------------------------------------------------------
    # 7) Reconstruction du 3MF final
    # ------------------------------------------------------------
    tmp_new = base_name + ".new.3mf"

    with zipfile.ZipFile(old_3mf, 'r') as old_zip, \
         zipfile.ZipFile(tmp_new, 'w', compression=zipfile.ZIP_DEFLATED) as new_zip:

        names = old_zip.namelist()
        has_objects = any(n.startswith("3D/Objects/") for n in names)

        for item in old_zip.infolist():
            name = item.filename
            data = old_zip.read(name)

            # Cas multi-objets
            if has_objects:

                # Remplacement du mod√®le principal
                if name == keep_model:
                    new_zip.writestr(name, geom_data_centered)
                    print(f"   ‚úÖ Objet inject√© : {keep_model}")
                    continue

                # Suppression des autres objets
                elif name.startswith("3D/Objects/") and name.endswith(".model"):
                    continue

                # Transformations
                if name.endswith("3dmodel.model"):
                    if keep_positions:
                        data = force_zmax_in_transform(data, zmax)
                    else:
                        data = reset_item_transform(data, center=(CENTER_X, CENTER_Y, zmax))
                    new_zip.writestr(name, data)
                    continue

                # M√©tadonn√©es
                if not keep_params and name.startswith("Metadata/"):
                    continue

                new_zip.writestr(name, data)
                continue

            # Cas Qidi mono-objet
            else:
                new_zip.close()
                inject_geometry_into_qidi_3mf(old_3mf, tmp_new, geom_data_centered)
                break

    # ------------------------------------------------------------
    # 8) Remplacement du fichier final
    # ------------------------------------------------------------
    if os.path.exists(fc_3mf): #############"" Plus besoin du controle  peut retirer le if (et le remoce)
        os.remove(fc_3mf)
    shutil.move(tmp_new, fc_3mf)

    if os.path.exists(old_3mf):
        os.remove(old_3mf)

    print("‚úÖ Export avec r√©cup√©ration des param√®tres du slicer :", fc_3mf)


def launch_slicer_if_needed(slicer_path, launch_slicer, fc_3mf):
    """
    Lance le slicer si demand√© par l‚Äôutilisateur.
    - V√©rifie l‚Äôexistence du chemin
    - Ouvre le slicer avec le fichier 3MF
    - Sinon affiche un message de fin

    Ne retourne rien.
    """

    # Lancement demand√© ?
    if launch_slicer and slicer_path and os.path.exists(slicer_path):
        try:
            time.sleep(0.2)  # petit d√©lai pour √©viter les conflits disque
            subprocess.Popen(f'"{slicer_path}" "{fc_3mf}"', shell=True)
        except Exception as e:
            show_message(tr("error_title"), f"{tr('error_launch_slicer')} {e}")
        return

    # Si l‚Äôutilisateur n‚Äôa pas demand√© le lancement
    if not launch_slicer:
        show_message(tr("info_title"), tr("info_done"))


def run_extra_commands(extra_cmds):
    """
    Ex√©cute les commandes externes d√©finies par l‚Äôutilisateur.
    Chaque entr√©e est un tuple : (checked, cmd, delay)

    - checked : bool ‚Üí ex√©cuter ou non
    - cmd : commande syst√®me
    - delay : d√©lai en secondes avant ex√©cution

    Ne retourne rien.
    """

    for checked, cmd, delay in extra_cmds:
        if not checked:
            continue

        try:
            if delay > 0:
                time.sleep(delay)

            subprocess.Popen(cmd)

        except Exception as e:
            show_message(tr("error_title"), f"{tr('error_external_cmd')} {e}")


# -------------------------
# Routine principale
# -------------------------
# Routine principale : exporte la s√©lection en 3MF/STL, injecte g√©om√©trie, 
# lance slicer et commandes externes
# -------------------------

def export_replace_geometry():

    print('\n\n>>> NOUVELLE EXECUTION DE LA MACRO <<<')

    # ------------------------------------------------------------
    # 1) V√©rifications initiales
    # ------------------------------------------------------------


    env = prepare_environment()
    if env is None:
        return
    (cfg, doc, base_name, fc_3mf, old_3mf_backup, fc_3mf_existed_at_start) = env

    # V√©rification de la s√©lection
    selection = get_valid_selection(fc_3mf, old_3mf_backup, fc_3mf_existed_at_start)
    if selection is None:
        return

    # ------------------------------------------------------------
    # 2) Pr√©f√©rences + bo√Æte de dialogue
    # ------------------------------------------------------------

    opts = get_user_options(cfg)
    
    if opts is None:
        # Annulation ‚Üí restauration √©ventuelle ##############################"" A RETIRER ne laisser que le return
        print('export_replace_geometry dans 2)', ' move de old vers fc_3mf')
        shutil.move(old_3mf_backup, fc_3mf)
        return

    (keep_params, keep_positions, generate_stl,
     slicer_path, launch_slicer,
     linear_value, angular_value, extra_cmds) = opts

    slicer_target = detect_slicer_target_from_path(slicer_path) if slicer_path else None
    
    
    #------------------------------------------------------------
    # r√©cup slice source
    #--------------------------------------------------------------
    
    
    slicer_source = nameSlicer(fc_3mf) #######################################################################
    print ('==============slicer_source', slicer_source)


    # ------------------------------------------------------------
    # 4) TEST PLATEAU VIDE du fc_3mf si vide propose de copier en old en fc_3mf (False)
    # ou de sortir (True) si (annul√© ou retore car plateau vide)
    # ------------------------------------------------------------
    if not handle_empty_plate(fc_3mf_existed_at_start, old_3mf_backup, fc_3mf):
        return

    #------------------------------------------------------------
    # pr√©paration de l'environnement suite apr√®s boite de dialogue
    #--------------------------------------------------------------



    #copie du 3mf en old = Sauvegarde de l'ancien 3MF (seulement si le .3mf existait au d√©part)
    #Suite √† √ßa l e3mf n'existe plus.
    if fc_3mf_existed_at_start:
        #try:
            shutil.copy(fc_3mf, old_3mf_backup) 
    """ except Exception as e:
            show_message(tr("error_title"), f"{tr('error_backup_3mf')} {e}")
            return None
    """    
    #if not fc_3mf_existed_at_start and slicer_target in ["cura"]:

    if slicer_source in ['noFile', 'freecad'] and slicer_target in ["cura"]:
           show_message( "premier lancement", 
                f"Le slicer {slicer_target} ne recentre pas les objets. Dans {slicer_target}" 
                " d√©zoomez pour pouvoir le recentrer sur le plateau."
)


    # ------------------------------------------------------------
    # 3) Export FreeCAD ‚Üí 3MF
    # ------------------------------------------------------------
    if not export_freecad_files(selection, base_name, fc_3mf, generate_stl,
                                linear_value, angular_value,
                                fc_3mf_existed_at_start, old_3mf_backup):
        return


    # ------------------------------------------------------------
    # 5) Injection g√©om√©trie si ancien 3MF
    # ------------------------------------------------------------
    inject_geometry_if_possible(
        base_name, fc_3mf, old_3mf_backup, fc_3mf_existed_at_start,
        slicer_path, keep_params, keep_positions
    )
    

    # ------------------------------------------------------------
    # 6) Lancement du slicer
    # ------------------------------------------------------------
    launch_slicer_if_needed(slicer_path, launch_slicer, fc_3mf)


    # ------------------------------------------------------------
    # 7) Commandes externes
    # ------------------------------------------------------------
    run_extra_commands(extra_cmds)




export_replace_geometry()
