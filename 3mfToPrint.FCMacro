# -*- coding: utf-8 -*-
"""
Macro FreeCAD : export 3MF avec contrôle de tessellation (LinearDeflection / AngularDeflection),
remplacement de la géométrie dans un 3MF existant, options UI et sauvegarde dans macro_config.ini.
"""
import math
import os
import sys
import zipfile
import shutil
import subprocess
import re
import fnmatch
import xml.etree.ElementTree as ET
import configparser
import platform
import shlex

import FreeCAD
import FreeCADGui
import Mesh
import MeshPart
from PySide import QtGui

# -------------------------
# Constantes et configuration
# -------------------------
INI_FILE = os.path.join(os.path.dirname(__file__), "3mfToPrint.ini")

CENTER_X = 120
CENTER_Y = 120
CENTER_Z = 2.5   # valeur par défaut Qidi

if platform.system() == "Windows":
    DEFAULT_SLICER_EXE = r"C:\Program Files\QIDIStudio\qidi-studio.exe"
elif platform.system() == "Linux":
    DEFAULT_SLICER_EXE = "/usr/bin/qidi-studio"
else:
    DEFAULT_SLICER_EXE = ""

DEFAULT_LINEAR_DEFLECTION = 0.01
DEFAULT_ANGULAR_DEGREES = 3.0
DEFAULT_ANGULAR_DEFLECTION = DEFAULT_ANGULAR_DEGREES * math.pi / 180.0

# -------------------------
# Utilitaires UI / config
# -------------------------
def show_message(title, message):
    QtGui.QMessageBox.information(None, title, message)

def load_config():
    cfg = {
        "slicer_exe": DEFAULT_SLICER_EXE,
        "linear_deflection": DEFAULT_LINEAR_DEFLECTION,
        "angular_deflection": DEFAULT_ANGULAR_DEFLECTION,
    }
    config = configparser.ConfigParser()
    if os.path.exists(INI_FILE):
        try:
            config.read(INI_FILE)
            if "Settings" in config:
                s = config["Settings"]
                if "slicer_exe" in s:
                    cfg["slicer_exe"] = s.get("slicer_exe", cfg["slicer_exe"])
                if "linear_deflection" in s:
                    try:
                        cfg["linear_deflection"] = float(s.get("linear_deflection", cfg["linear_deflection"]))
                    except Exception:
                        pass
                if "angular_deflection" in s:
                    try:
                        cfg["angular_deflection"] = float(s.get("angular_deflection", cfg["angular_deflection"]))
                    except Exception:
                        pass
        except Exception:
            pass
    return cfg

def save_slicer_path(path):
    config = configparser.ConfigParser()
    if os.path.exists(INI_FILE):
        try:
            config.read(INI_FILE)
        except Exception:
            config = configparser.ConfigParser()
    if "Settings" not in config:
        config["Settings"] = {}
    config["Settings"]["slicer_exe"] = path
    try:
        with open(INI_FILE, "r", encoding="utf-8") as f:
            existing = configparser.ConfigParser()
            existing.read_file(f)
            if "Settings" in existing and "linear_deflection" in existing["Settings"]:
                config["Settings"]["linear_deflection"] = existing["Settings"]["linear_deflection"]
            if "Settings" in existing and "angular_deflection" in existing["Settings"]:
                config["Settings"]["angular_deflection"] = existing["Settings"]["angular_deflection"]
    except Exception:
        pass
    with open(INI_FILE, "w", encoding="utf-8") as f:
        config.write(f)

def save_deflection_values(linear, angular):
    config = configparser.ConfigParser()
    if os.path.exists(INI_FILE):
        try:
            config.read(INI_FILE)
        except Exception:
            config = configparser.ConfigParser()
    if "Settings" not in config:
        config["Settings"] = {}
    config["Settings"]["linear_deflection"] = str(linear)
    config["Settings"]["angular_deflection"] = str(angular)
    try:
        with open(INI_FILE, "r", encoding="utf-8") as f:
            existing = configparser.ConfigParser()
            existing.read_file(f)
            if "Settings" in existing and "slicer_exe" in existing["Settings"]:
                config["Settings"]["slicer_exe"] = existing["Settings"]["slicer_exe"]
    except Exception:
        pass
    with open(INI_FILE, "w", encoding="utf-8") as f:
        config.write(f)

def ask_user_options(current_slicer, current_linear, current_angular):
    dialog = QtGui.QDialog()
    dialog.setWindowTitle("Options d'export vers QidiStudio")
    dialog.setMinimumWidth(700)

    layout = QtGui.QVBoxLayout()

    chk_params = QtGui.QCheckBox("Conserver les paramètres d'impression (profil du slicer)")
    chk_params.setChecked(True)
    layout.addWidget(chk_params)

    chk_positions = QtGui.QCheckBox("Conserver les positions sur le plateau")
    chk_positions.setChecked(True)
    layout.addWidget(chk_positions)

    chk_launch = QtGui.QCheckBox("Lancer le slicer après export")
    chk_launch.setChecked(True)
    layout.addWidget(chk_launch)

    h = QtGui.QHBoxLayout()
    h.addWidget(QtGui.QLabel("Chemin du slicer"))
    edit_slicer = QtGui.QLineEdit(current_slicer)
    edit_slicer.setMinimumWidth(420)
    btn_browse = QtGui.QPushButton("Parcourir…")
    def browse():
        path, _ = QtGui.QFileDialog.getOpenFileName(dialog, "Choisir l'exécutable du slicer")
        if path:
            edit_slicer.setText(path)
    btn_browse.clicked.connect(browse)
    h.addWidget(edit_slicer, stretch=1)
    h.addWidget(btn_browse)
    layout.addLayout(h)

    hlin = QtGui.QHBoxLayout()
    label_lin = QtGui.QLabel("Précision (LinearDeflection) entre 0.01 et 10. Haute qualité : 0.01")
    spin_lin = QtGui.QDoubleSpinBox()
    spin_lin.setRange(0.01, 10.0)
    spin_lin.setSingleStep(0.01)
    spin_lin.setDecimals(2)
    try:
        spin_lin.setValue(round(float(current_linear), 2))
    except Exception:
        spin_lin.setValue(DEFAULT_LINEAR_DEFLECTION)
    hlin.addWidget(label_lin)
    hlin.addWidget(spin_lin)
    layout.addLayout(hlin)

    hanga = QtGui.QHBoxLayout()
    label_ang = QtGui.QLabel("Tolérance angulaire (AngularDeflection) en degrés (ex: 3)")
    spin_ang = QtGui.QDoubleSpinBox()
    spin_ang.setRange(1.0, 90.0)
    spin_ang.setSingleStep(1.0)
    spin_ang.setDecimals(1)
    try:
        deg = float(current_angular) * 180.0 / math.pi
        spin_ang.setValue(deg)
    except Exception:
        spin_ang.setValue(DEFAULT_ANGULAR_DEGREES)
    hanga.addWidget(label_ang)
    hanga.addWidget(spin_ang)
    layout.addLayout(hanga)

    btns = QtGui.QDialogButtonBox(QtGui.QDialogButtonBox.Ok | QtGui.QDialogButtonBox.Cancel)
    layout.addWidget(btns)
    dialog.setLayout(layout)

    btns.accepted.connect(dialog.accept)
    btns.rejected.connect(dialog.reject)

    if dialog.exec() == QtGui.QDialog.Accepted:
        linear_val = float(spin_lin.value())
        angular_deg = float(spin_ang.value())
        angular_rad = angular_deg * math.pi / 180.0
        return (chk_params.isChecked(),
                chk_positions.isChecked(),
                edit_slicer.text(),
                chk_launch.isChecked(),
                linear_val,
                angular_rad)
    else:
        return (None, None, None, None, None, None)

# -------------------------
# Fonctions de traitement 3MF / mesh
# -------------------------
def find_geom_file_in_3mf(zip_path):
    with zipfile.ZipFile(zip_path, 'r') as z:
        rels_name = "_rels/.rels"
        if rels_name in z.namelist():
            try:
                rels_bytes = z.read(rels_name)
                rels_text = rels_bytes.decode("utf-8")
                root = ET.fromstring(rels_text)
                for rel in root:
                    if rel.tag.endswith("Relationship"):
                        rtype = rel.attrib.get("Type", "")
                        if rtype == "http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel":
                            target = rel.attrib.get("Target")
                            if target and target.startswith("/"):
                                target = target[1:]
                            if target in z.namelist():
                                return target
            except Exception:
                pass
        for name in z.namelist():
            if fnmatch.fnmatch(name, "3D/Objects/*.model"):
                return name
        if "3D/3dmodel.model" in z.namelist():
            return "3D/3dmodel.model"
    return None

def reset_item_transform(model_data, center=(CENTER_X, CENTER_Y, CENTER_Z)):
    text = model_data.decode("utf-8")
    new_transform = f'transform="1 0 0 0 1 0 0 0 1 {center[0]} {center[1]} {center[2]}"'
    text = re.sub(r'(<item[^>]*?)\s+transform="[^"]+"', r'\1 ' + new_transform, text)
    return text.encode("utf-8")

def export_selection_with_deflection(selection, out_3mf_path,
                                     linear_deflection=DEFAULT_LINEAR_DEFLECTION,
                                     angular_deflection=DEFAULT_ANGULAR_DEFLECTION):
    doc = FreeCAD.ActiveDocument
    temp_objs = []
    try:
        for obj in selection:
            mesh = MeshPart.meshFromShape(Shape=obj.Shape,
                                          LinearDeflection=float(linear_deflection),
                                          AngularDeflection=float(angular_deflection))
            mobj = doc.addObject("Mesh::Feature", f"TempMesh_{obj.Name}")
            mobj.Mesh = mesh
            temp_objs.append(mobj)
        doc.recompute()
        Mesh.export(temp_objs, out_3mf_path)
    finally:
        for t in temp_objs:
            try:
                doc.removeObject(t.Name)
            except Exception:
                pass
        doc.recompute()

# -------------------------
# Routine principale
# -------------------------
def export_replace_geometry():
    cfg = load_config()
    doc = FreeCAD.ActiveDocument
    if not doc:
        show_message("Erreur", "❌ Aucun document ouvert dans FreeCAD.")
        return

    fcstd_path = doc.FileName
    if not fcstd_path:
        show_message("Erreur", "❌ Le projet n'a pas encore été sauvegardé.")
        return

    base_name = os.path.splitext(fcstd_path)[0]
    fc_3mf = base_name + ".3mf"
    old_3mf = base_name + ".old.3mf"

    if os.path.exists(fc_3mf):
        try:
            shutil.move(fc_3mf, old_3mf)
        except Exception:
            pass

    selection = FreeCADGui.Selection.getSelection()
    if not selection:
        show_message("Avertissement", "⚠️ Aucun objet sélectionné.")
        return
    if len(selection) > 1:
        show_message("Avertissement", "⚠️ Sélection multiple non supportée.")
        return

    slicer_path_pref = cfg.get("slicer_exe", DEFAULT_SLICER_EXE)
    linear_pref = cfg.get("linear_deflection", DEFAULT_LINEAR_DEFLECTION)
    angular_pref = cfg.get("angular_deflection", DEFAULT_ANGULAR_DEFLECTION)

    keep_params, keep_positions, slicer_path, launch_slicer, linear_value, angular_value = \
        ask_user_options(slicer_path_pref, linear_pref, angular_pref)

    if slicer_path is None and launch_slicer is None:
        show_message("Info", "⚠️ Export annulé par l’utilisateur.")
        if os.path.exists(old_3mf) and not os.path.exists(fc_3mf):
            try:
                shutil.move(old_3mf, fc_3mf)
            except Exception:
                pass
        return

    try:
        save_deflection_values(linear_value, angular_value)
    except Exception:
        pass

    try:
        export_selection_with_deflection(selection, fc_3mf,
                                         linear_deflection=linear_value,
                                         angular_deflection=angular_value)
    except Exception as e:
        show_message("Erreur", f"❌ Erreur lors de l'export 3MF : {e}")
        if os.path.exists(old_3mf) and not os.path.exists(fc_3mf):
            try:
                shutil.move(old_3mf, fc_3mf)
            except Exception:
                pass
        return

    print("Exportation FreeCAD terminée :", fc_3mf)

    if os.path.exists(old_3mf):
        geom_entry = find_geom_file_in_3mf(fc_3mf)
        if not geom_entry:
            show_message("Erreur", "❌ Aucun fichier de géométrie détecté dans le 3MF exporté.")
            return
        with zipfile.ZipFile(fc_3mf, 'r') as fc_zip:
            geom_data = fc_zip.read(geom_entry)

        tmp_new = base_name + ".new.3mf"

        if not slicer_path or not os.path.exists(slicer_path):
            if launch_slicer:
                show_message("Erreur", "❌ Aucun slicer valide fourni, la macro s'arrête.")
                if os.path.exists(old_3mf) and not os.path.exists(fc_3mf):
                    try:
                        shutil.move(old_3mf, fc_3mf)
                    except Exception:
                        pass
                return
            else:
                if not slicer_path:
                    show_message("Avertissement", "⚠️ Aucun slicer renseigné ; le slicer ne sera pas lancé.")
                else:
                    show_message("Avertissement", "⚠️ Le chemin du slicer fourni est introuvable ; le slicer ne sera pas lancé.")

        try:
            with zipfile.ZipFile(old_3mf, 'r') as old_zip, zipfile.ZipFile(tmp_new, 'w') as new_zip:
                for item in old_zip.infolist():
                    data = old_zip.read(item.filename)
                    if item.filename.startswith("3D/Objects/") and item.filename.endswith(".model"):
                        new_zip.writestr(item.filename, geom_data)
                    elif item.filename.endswith("3dmodel.model"):
                        if not keep_positions:
                            data = reset_item_transform(data, center=(CENTER_X, CENTER_Y, CENTER_Z))
                        new_zip.writestr(item.filename, data)
                    elif not keep_params and item.filename.startswith("Metadata/"):
                        continue
                    else:
                        new_zip.writestr(item, data)
        except Exception as e:
            show_message("Erreur", f"❌ Erreur lors de la création du 3MF final : {e}")
            return

        try:
            if os.path.exists(fc_3mf):
                os.remove(fc_3mf)
        except Exception:
            pass
        try:
            shutil.move(tmp_new, fc_3mf)
        except Exception as e:
            show_message("Erreur", f"❌ Impossible de remplacer le 3MF : {e}")
            return
        try:
            if os.path.exists(old_3mf):
                os.remove(old_3mf)
        except Exception:
            pass

        print("✅ Géométrie FreeCAD injectée et options appliquées :", fc_3mf)

        if launch_slicer and slicer_path and os.path.exists(slicer_path):
            try:
                subprocess.Popen([slicer_path, fc_3mf])
            except Exception as e:
                show_message("Erreur", f"❌ Erreur lors du lancement du slicer : {e}")
        else:
            if not launch_slicer:
                show_message("Info", "✅ Export terminé. Le slicer n'a pas été lancé (option décochée).")

        if slicer_path and os.path.exists(slicer_path):
            try:
                save_slicer_path(slicer_path)
            except Exception:
                pass
    else:
        print("✅ Fichier généré uniquement par FreeCAD :", fc_3mf)

# Lancement automatique
if __name__ == "__main__":
    export_replace_geometry()
