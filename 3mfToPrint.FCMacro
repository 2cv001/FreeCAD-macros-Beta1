# -*- coding: utf-8 -*-
"""
Macro FreeCAD multilingue : export 3MF/STL avec contrôle de tessellation,
conservation des paramètres du slicer, ouverture automatique du slicer,
et déclenchement de commandes externes (domotique).
"""

import math, os, zipfile, shutil, subprocess, re, fnmatch, xml.etree.ElementTree as ET
import configparser, ast, platform, time
import FreeCAD, FreeCADGui, Mesh, MeshPart
from PySide import QtGui, QtCore

# -------------------------
# Constantes et configuration
# -------------------------
INI_FILE = os.path.join(os.path.dirname(__file__), "3mfToPrint.ini")
CENTER_X, CENTER_Y, CENTER_Z = 120, 120, 2.5

if platform.system() == "Windows":
    DEFAULT_SLICER_EXE = r"C:\Program Files\QIDIStudio\qidi-studio.exe"
elif platform.system() == "Linux":
    DEFAULT_SLICER_EXE = "/usr/bin/qidi-studio"
else:
    DEFAULT_SLICER_EXE = ""

DEFAULT_LINEAR_DEFLECTION = 0.01
DEFAULT_ANGULAR_DEGREES = 3.0
DEFAULT_ANGULAR_DEFLECTION = DEFAULT_ANGULAR_DEGREES * math.pi / 180.0

EXTRA_COMMANDS = [
    (["calc.exe"], "Ouvrir la calculatrice Windows ?", 0, False),
]

# -------------------------
# Traductions multilingues
# -------------------------
TRANSLATIONS = {
    "fr": {
        "options_title": "Options d'export vers QidiStudio",
        "keep_params": "Conserver les paramètres d'impression (profil du slicer)",
        "keep_positions": "Conserver les positions sur le plateau",
        "generate_stl": "En plus du .3mf, générer également un STL",
        "launch_slicer": "Lancer le slicer",
        "browse": "Parcourir…",
        "linear_label": "Précision (LinearDeflection) entre 0.01 et 10. Haute qualité : 0.01",
        "angular_label": "Tolérance angulaire (AngularDeflection) en degrés (ex: 3)",
        "external_actions": "Actions externes à exécuter avant fermeture :",
        "error_no_doc": "❌ Aucun document ouvert dans FreeCAD.",
        "error_no_save": "❌ Le projet n'a pas encore été sauvegardé.",
        "warn_no_selection": "⚠️ Aucun objet sélectionné.",
        "warn_multi_selection": "⚠️ Sélection multiple non supportée.",
        "info_cancel": "⚠️ Export annulé par l’utilisateur.",
        "info_done": "✅ Export terminé. Le slicer n'a pas été lancé (option décochée).",
    },
    "en": {
        "options_title": "Export options to QidiStudio",
        "keep_params": "Keep printing parameters (slicer profile)",
        "keep_positions": "Keep positions on the build plate",
        "generate_stl": "Also generate an STL along with the .3mf",
        "launch_slicer": "Launch slicer",
        "browse": "Browse…",
        "linear_label": "Precision (LinearDeflection) between 0.01 and 10. High quality: 0.01",
        "angular_label": "Angular tolerance (AngularDeflection) in degrees (e.g. 3)",
        "external_actions": "External actions to execute before closing:",
        "error_no_doc": "❌ No document open in FreeCAD.",
        "error_no_save": "❌ The project has not been saved yet.",
        "warn_no_selection": "⚠️ No object selected.",
        "warn_multi_selection": "⚠️ Multiple selection not supported.",
        "info_cancel": "⚠️ Export cancelled by user.",
        "info_done": "✅ Export finished. Slicer was not launched (option unchecked).",
    }
}

def get_user_language():
    try:
        locale = FreeCADGui.getLocale().lower()
        # Normalisation
        if locale.startswith("fr") or "french" in locale:
            return "fr"
        if locale.startswith("en") or "english" in locale:
            return "en"
        '''
        if locale.startswith("de") or "german" in locale:
            return "de"
        if locale.startswith("es") or "spanish" in locale:
            return "es"
        if locale.startswith("it") or "italian" in locale:
            return "it"
        '''    
        # Fallback
        return "en"
    except Exception:
        return "en"




def tr(key):
    lang = get_user_language()
    return TRANSLATIONS.get(lang, TRANSLATIONS["en"]).get(key, key)



# -------------------------
# Utilitaires UI / config
# -------------------------
def show_message(title, message):
    QtGui.QMessageBox.information(None, title, message)

def load_config():
    cfg = {
        "slicer_exe": DEFAULT_SLICER_EXE,
        "linear_deflection": DEFAULT_LINEAR_DEFLECTION,
        "angular_deflection": DEFAULT_ANGULAR_DEFLECTION,
    }
    config = configparser.ConfigParser()
    if os.path.exists(INI_FILE):
        try:
            config.read(INI_FILE)
            if "Settings" in config:
                s = config["Settings"]
                if "slicer_exe" in s:
                    cfg["slicer_exe"] = s.get("slicer_exe", cfg["slicer_exe"])
                if "linear_deflection" in s:
                    cfg["linear_deflection"] = float(s.get("linear_deflection", cfg["linear_deflection"]))
                if "angular_deflection_deg" in s:
                    deg = float(s.get("angular_deflection_deg", DEFAULT_ANGULAR_DEGREES))
                    cfg["angular_deflection"] = deg * math.pi / 180.0
        except Exception as e:
            print("⚠️ Erreur lecture ini:", e)
    return cfg

def save_settings(linear=None, angular_rad=None, slicer_path=None):
    angular_deg = None
    if angular_rad is not None:
        angular_deg = angular_rad * 180.0 / math.pi
    if not os.path.exists(INI_FILE):
        with open(INI_FILE, "w", encoding="utf-8") as f:
            f.write(
                "[Settings]\n"
                f"linear_deflection = {linear if linear is not None else DEFAULT_LINEAR_DEFLECTION}\n"
                f"angular_deflection_deg = {angular_deg if angular_deg is not None else DEFAULT_ANGULAR_DEGREES}\n"
                f"slicer_exe = {slicer_path if slicer_path else ''}\n\n"
                "[extra_commands]\nEXTRA_COMMANDS = []\n"
            )
        return
    with open(INI_FILE, "r", encoding="utf-8") as f:
        lines = f.readlines()
    new_lines, in_settings = [], False
    for line in lines:
        if line.strip().startswith("[Settings]"):
            in_settings = True
            new_lines.append(line)
            continue
        if in_settings and line.strip().startswith("[") and not line.strip().startswith("[Settings]"):
            in_settings = False
        if in_settings:
            if line.strip().startswith("linear_deflection") and linear is not None:
                new_lines.append(f"linear_deflection = {linear}\n"); continue
            if line.strip().startswith("angular_deflection_deg") and angular_deg is not None:
                new_lines.append(f"angular_deflection_deg = {angular_deg}\n"); continue
            if line.strip().startswith("slicer_exe") and slicer_path is not None:
                new_lines.append(f"slicer_exe = {slicer_path}\n"); continue
        new_lines.append(line)
    with open(INI_FILE, "w", encoding="utf-8") as f:
        f.writelines(new_lines)
# -------------------------
# Interface utilisateur
# -------------------------
def ask_user_options(current_slicer, current_linear, current_angular):
    """Affiche boîte de dialogue pour options export (positions, params, STL, slicer, deflection)."""
    dialog = QtGui.QDialog()
    dialog.setWindowTitle(tr("options_title"))
    dialog.setMinimumWidth(720)

    layout = QtGui.QVBoxLayout()

    # Cases principales
    chk_params = QtGui.QCheckBox(tr("keep_params"))
    chk_params.setChecked(True)
    layout.addWidget(chk_params)

    chk_positions = QtGui.QCheckBox(tr("keep_positions"))
    chk_positions.setChecked(True)
    layout.addWidget(chk_positions)

    chk_stl = QtGui.QCheckBox(tr("generate_stl"))
    chk_stl.setChecked(False)
    layout.addWidget(chk_stl)

    # Ligne combinée : case "Lancer le slicer" + champ chemin
    h_slicer = QtGui.QHBoxLayout()
    chk_launch = QtGui.QCheckBox(tr("launch_slicer"))
    chk_launch.setChecked(True)
    h_slicer.addWidget(chk_launch)

    edit_slicer = QtGui.QLineEdit(current_slicer or "")
    edit_slicer.setMinimumWidth(420)
    h_slicer.addWidget(edit_slicer, stretch=1)

    btn_browse = QtGui.QPushButton(tr("browse"))
    def browse():
        path, _ = QtGui.QFileDialog.getOpenFileName(dialog, tr("browse"))
        if path:
            edit_slicer.setText(path)
    btn_browse.clicked.connect(browse)
    h_slicer.addWidget(btn_browse)
    layout.addLayout(h_slicer)

    # Précision linéaire
    h_lin = QtGui.QHBoxLayout()
    lbl_lin = QtGui.QLabel(tr("linear_label"))
    lbl_lin.setMinimumWidth(420)
    h_lin.addWidget(lbl_lin)

    spin_lin = QtGui.QDoubleSpinBox()
    spin_lin.setRange(0.01, 10.0)
    spin_lin.setSingleStep(0.01)
    spin_lin.setDecimals(2)
    spin_lin.setMaximumWidth(80)
    try:
        spin_lin.setValue(round(float(current_linear), 2))
    except Exception:
        spin_lin.setValue(DEFAULT_LINEAR_DEFLECTION)
    h_lin.addWidget(spin_lin)
    h_lin.addStretch()
    layout.addLayout(h_lin)

    # Tolérance angulaire
    h_ang = QtGui.QHBoxLayout()
    lbl_ang = QtGui.QLabel(tr("angular_label"))
    lbl_ang.setMinimumWidth(420)
    h_ang.addWidget(lbl_ang)

    spin_ang = QtGui.QDoubleSpinBox()
    spin_ang.setRange(1.0, 90.0)
    spin_ang.setSingleStep(1.0)
    spin_ang.setDecimals(1)
    spin_ang.setMaximumWidth(80)
    try:
        deg = float(current_angular) * 180.0 / math.pi
        spin_ang.setValue(deg)
    except Exception:
        spin_ang.setValue(DEFAULT_ANGULAR_DEGREES)
    h_ang.addWidget(spin_ang)
    h_ang.addStretch()
    layout.addLayout(h_ang)

    # Cases pour les commandes externes
    extra_checks = []
    if EXTRA_COMMANDS:
        layout.addWidget(QtGui.QLabel(tr("external_actions")))
    for cmd, label, delay, default in EXTRA_COMMANDS:
        chk = QtGui.QCheckBox(label)
        chk.setChecked(default)
        layout.addWidget(chk)
        extra_checks.append((chk, cmd, delay))

    # Boutons OK/Annuler
    btns = QtGui.QDialogButtonBox(QtGui.QDialogButtonBox.Ok | QtGui.QDialogButtonBox.Cancel)
    layout.addWidget(btns)
    dialog.setLayout(layout)

    btns.accepted.connect(dialog.accept)
    btns.rejected.connect(dialog.reject)

    if dialog.exec() == QtGui.QDialog.Accepted:
        linear_val = float(spin_lin.value())
        angular_deg = float(spin_ang.value())
        angular_rad = angular_deg * math.pi / 180.0
        return (
            chk_params.isChecked(),
            chk_positions.isChecked(),
            chk_stl.isChecked(),
            edit_slicer.text(),
            chk_launch.isChecked(),
            linear_val,
            angular_rad,
            [(chk.isChecked(), cmd, delay) for chk, cmd, delay in extra_checks]
        )
    else:
        return (None, None, None, None, None, None, None, [])

# -------------------------
# Fonctions de traitement 3MF / mesh
# -------------------------
def find_geom_file_in_3mf(zip_path):
    with zipfile.ZipFile(zip_path, 'r') as z:
        rels_name = "_rels/.rels"
        if rels_name in z.namelist():
            try:
                rels_text = z.read(rels_name).decode("utf-8")
                root = ET.fromstring(rels_text)
                for rel in root:
                    if rel.tag.endswith("Relationship"):
                        rtype = rel.attrib.get("Type", "")
                        if rtype.endswith("3dmodel"):
                            target = rel.attrib.get("Target")
                            if target and target.startswith("/"):
                                target = target[1:]
                            if target in z.namelist():
                                return target
            except Exception:
                pass
        for name in z.namelist():
            if fnmatch.fnmatch(name, "3D/Objects/*.model"):
                return name
        if "3D/3dmodel.model" in z.namelist():
            return "3D/3dmodel.model"
    return None

def reset_item_transform(model_data, center=(CENTER_X, CENTER_Y, CENTER_Z)):
    text = model_data.decode("utf-8")
    new_transform = f'transform="1 0 0 0 1 0 0 0 1 {center[0]} {center[1]} {center[2]}"'
    text = re.sub(r'(<item[^>]*?)\s+transform="[^"]+"', r'\1 ' + new_transform, text)
    return text.encode("utf-8")

def export_stl_with_deflection(selection, stl_path,
                               linear_deflection=DEFAULT_LINEAR_DEFLECTION,
                               angular_deflection=DEFAULT_ANGULAR_DEFLECTION):
    doc = FreeCAD.ActiveDocument
    temp_objs = []
    try:
        for obj in selection:
            mesh = MeshPart.meshFromShape(
                Shape=obj.Shape,
                LinearDeflection=float(linear_deflection),
                AngularDeflection=float(angular_deflection)
            )
            mobj = doc.addObject("Mesh::Feature", f"TempMeshSTL_{obj.Name}")
            mobj.Mesh = mesh
            temp_objs.append(mobj)
        doc.recompute()
        Mesh.export(temp_objs, stl_path)
    finally:
        for t in temp_objs:
            try: doc.removeObject(t.Name)
            except Exception: pass
        doc.recompute()

def export_selection_with_deflection(selection, out_3mf_path,
                                     linear_deflection=DEFAULT_LINEAR_DEFLECTION,
                                     angular_deflection=DEFAULT_ANGULAR_DEFLECTION):
    doc = FreeCAD.ActiveDocument
    temp_objs = []
    try:
        for obj in selection:
            mesh = MeshPart.meshFromShape(
                Shape=obj.Shape,
                LinearDeflection=float(linear_deflection),
                AngularDeflection=float(angular_deflection))
            mobj = doc.addObject("Mesh::Feature", f"TempMesh_{obj.Name}")
            mobj.Mesh = mesh
            temp_objs.append(mobj)
        doc.recompute()
        Mesh.export(temp_objs, out_3mf_path)
    finally:
        for t in temp_objs:
            try: doc.removeObject(t.Name)
            except Exception: pass
        doc.recompute()

def recenter_vertices(model_data):
    try:
        ET.register_namespace('', "http://schemas.microsoft.com/3dmanufacturing/core/2015/02")
        root = ET.fromstring(model_data.decode("utf-8"))
        ns = {"ns": "http://schemas.microsoft.com/3dmanufacturing/core/2015/02"}
        verts = root.findall(".//ns:vertex", ns)
        xs = [float(v.attrib["x"]) for v in verts]
        ys = [float(v.attrib["y"]) for v in verts]
        xc, yc = (min(xs)+max(xs))/2.0, (min(ys)+max(ys))/2.0
        for v in verts:
            v.attrib["x"] = str(float(v.attrib["x"]) - xc)
            v.attrib["y"] = str(float(v.attrib["y"]) - yc)
        return ET.tostring(root, encoding="utf-8", xml_declaration=False)
    except Exception as e:
        print("⚠️ Erreur recentrage vertex :", e)
        return model_data

# -------------------------
# Routine principale
# -------------------------
def export_replace_geometry():
    cfg = load_config()
    doc = FreeCAD.ActiveDocument
    if not doc:
        show_message("Erreur", tr("error_no_doc"))
        return

    fcstd_path = doc.FileName
    if not fcstd_path:
        show_message("Erreur", tr("error_no_save"))
        return

    base_name = os.path.splitext(fcstd_path)[0]
    fc_3mf = base_name + ".3mf"
    old_3mf = base_name + ".old.3mf"

    if os.path.exists(fc_3mf):
        try:
            shutil.move(fc_3mf, old_3mf)
        except Exception:
            pass

    selection = FreeCADGui.Selection.getSelection()
    if not selection:
        show_message("Avertissement", tr("warn_no_selection"))
        return
    if len(selection) > 1:
        show_message("Avertissement", tr("warn_multi_selection"))
        return

    slicer_path_pref = cfg.get("slicer_exe", DEFAULT_SLICER_EXE)
    linear_pref = cfg.get("linear_deflection", DEFAULT_LINEAR_DEFLECTION)
    angular_pref = cfg.get("angular_deflection", DEFAULT_ANGULAR_DEFLECTION)

    keep_params, keep_positions, generate_stl, slicer_path, launch_slicer, linear_value, angular_value, extra_cmds = \
        ask_user_options(slicer_path_pref, linear_pref, angular_pref)

    if slicer_path is None and launch_slicer is None:
        show_message("Info", tr("info_cancel"))
        if os.path.exists(old_3mf) and not os.path.exists(fc_3mf):
            try:
                shutil.move(old_3mf, fc_3mf)
            except Exception:
                pass
        return

    save_settings(linear=linear_value, angular_rad=angular_value)
    # print("✅ Valeurs sauvegardées :", linear_value, angular_value)

    try:
        export_selection_with_deflection(selection, fc_3mf,
                                         linear_deflection=linear_value,
                                         angular_deflection=angular_value)
    except Exception as e:
        show_message("Erreur", f"❌ Erreur lors de l'export 3MF : {e}")
        if os.path.exists(old_3mf) and not os.path.exists(fc_3mf):
            try:
                shutil.move(old_3mf, fc_3mf)
            except Exception:
                pass
        return



    # Génération STL si demandé
    if generate_stl:
        stl_path = base_name + ".stl"
        try:
            export_stl_with_deflection(selection, stl_path,
                                       linear_deflection=linear_value,
                                       angular_deflection=angular_value)
        except Exception as e:
            show_message("Erreur", f"❌ Erreur lors de la génération du STL : {e}")

    # Injection géométrie si ancien 3MF
    if os.path.exists(old_3mf):
        geom_entry = find_geom_file_in_3mf(fc_3mf)
        if not geom_entry:
            show_message("Erreur", "❌ Aucun fichier de géométrie détecté dans le 3MF exporté.")
            return
        with zipfile.ZipFile(fc_3mf, 'r') as fc_zip:
            geom_data = fc_zip.read(geom_entry)

        tmp_new = base_name + ".new.3mf"

        try:
            with zipfile.ZipFile(old_3mf, 'r') as old_zip, zipfile.ZipFile(tmp_new, 'w') as new_zip:
                for item in old_zip.infolist():
                    data = old_zip.read(item.filename)
                    if item.filename.startswith("3D/Objects/") and item.filename.endswith(".model"):
                        geom_data_centered = recenter_vertices(geom_data)
                        new_zip.writestr(item.filename, geom_data_centered)
                    elif item.filename.endswith("3dmodel.model"):
                        if not keep_positions:
                            data = reset_item_transform(data, center=(CENTER_X, CENTER_Y, CENTER_Z))
                        new_zip.writestr(item.filename, data)
                    elif not keep_params and item.filename.startswith("Metadata/"):
                        continue
                    else:
                        new_zip.writestr(item, data)
        except Exception as e:
            show_message("Erreur", f"❌ Erreur lors de la création du 3MF final : {e}")
            return

        try:
            if os.path.exists(fc_3mf):
                os.remove(fc_3mf)
        except Exception:
            pass
        try:
            shutil.move(tmp_new, fc_3mf)
        except Exception as e:
            show_message("Erreur", f"❌ Impossible de remplacer le 3MF : {e}")
            return
        try:
            if os.path.exists(old_3mf):
                os.remove(old_3mf)
        except Exception:
            pass



        if launch_slicer and slicer_path and os.path.exists(slicer_path):
            try:
                subprocess.Popen([slicer_path, fc_3mf])
            except Exception as e:
                show_message("Erreur", f"❌ Erreur lors du lancement du slicer : {e}")
        else:
            if not launch_slicer:
                show_message("Info", tr("info_done"))

        if slicer_path and os.path.exists(slicer_path):
            try:
                save_settings(slicer_path=slicer_path)
            except Exception:
                pass
    else:
        print("✅ Fichier généré uniquement par FreeCAD :", fc_3mf)

    # Exécution des commandes externes
    for checked, cmd, delay in extra_cmds:
        if checked:
            try:
                if delay > 0:
                    time.sleep(delay)
                subprocess.Popen(cmd)
            except Exception as e:
                show_message("Erreur", f"❌ Impossible d'exécuter la commande externe : {e}")

# Lancement automatique
if __name__ == "__main__":
    export_replace_geometry()
