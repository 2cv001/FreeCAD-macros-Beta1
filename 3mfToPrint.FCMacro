# -*- coding: utf-8 -*-
"""
Cette macro FreeCAD automatise l‚Äôexport de mod√®les 3D vers le format 3MF (utilis√© par QidiStudio et d‚Äôautres slicers), avec un contr√¥le pr√©cis 
de la qualit√© de maillage. Elle peut aussi g√©n√©rer un STL en parall√®le, si l‚Äôutilisateur le souhaite.
"""

import math
import os
import zipfile
import shutil
import subprocess
import re
import fnmatch
import xml.etree.ElementTree as ET
import configparser, ast
import platform
import time

import FreeCAD
import FreeCADGui
import Mesh
import MeshPart
from PySide import QtGui, QtCore


# -------------------------
# Constantes et configuration
# -------------------------
INI_FILE = os.path.join(os.path.dirname(__file__), "3mfToPrint.ini")
print('INI_FILE ', INI_FILE )
CENTER_X = 120
CENTER_Y = 120
CENTER_Z = 2.5   # valeur par d√©faut Qidi

if platform.system() == "Windows":
    DEFAULT_SLICER_EXE = r"C:\Program Files\QIDIStudio\qidi-studio.exe"
elif platform.system() == "Linux":
    DEFAULT_SLICER_EXE = "/usr/bin/qidi-studio"
else:
    DEFAULT_SLICER_EXE = ""

DEFAULT_LINEAR_DEFLECTION = 0.01
DEFAULT_ANGULAR_DEGREES = 3.0
DEFAULT_ANGULAR_DEFLECTION = DEFAULT_ANGULAR_DEGREES * math.pi / 180.0

# EXTRA_COMMANDS : liste de commandes externes optionnelles
# Chaque entr√©e est un tuple avec la structure suivante :
#   cmd      : liste repr√©sentant la commande √† ex√©cuter (ex: ['curl', 'https://...', '--insecure'])
#   label    : texte affich√© dans la bo√Æte de dialogue (ex: "Turn on and connect printer CR10 ?")
#   delay    : d√©lai en secondes avant d'ex√©cuter la commande (ex: 10)
#   default  : √©tat par d√©faut de la case √† cocher (True = coch√©e, False = d√©coch√©e)
#
# Exemple (ne sera pas ex√©cut√©, uniquement pour illustrer la syntaxe) :
# EXTRA_COMMANDS = [
#     (['curl', 'https://pijeedom/core/api/jeeApi.php?apikey=...','--insecure'],
#      "Turn on and connect printer CR10 ?", 10, False),
#     (['curl', 'https://autre/api?id=123','--insecure'],
#      "Allumer la lampe atelier ?", 5, True),
# ]
EXTRA_COMMANDS = [
     (["calc.exe"], 
     "Ouvrir la calculatrice Windows ?", 
     0, 
     False),

]





# -------------------------
# Utilitaires UI / config
# -------------------------
def show_message(title, message):
    """Affiche une bo√Æte de dialogue avec titre et texte.
    Entr√©es: title (str), text (str). Sorties: aucune (GUI)."""
    QtGui.QMessageBox.information(None, title, message)

def load_config():
    """Charge la configuration utilisateur depuis fichier JSON.
    Entr√©es: aucune. Sorties: dict avec pr√©f√©rences (slicer, deflection, etc.)."""
    cfg = {
        "slicer_exe": DEFAULT_SLICER_EXE,
        "linear_deflection": DEFAULT_LINEAR_DEFLECTION,
        "angular_deflection": DEFAULT_ANGULAR_DEFLECTION,
    }
    config = configparser.ConfigParser()
    if os.path.exists(INI_FILE):
        try:
            config.read(INI_FILE)
            if "Settings" in config:
                s = config["Settings"]
                if "slicer_exe" in s:
                    cfg["slicer_exe"] = s.get("slicer_exe", cfg["slicer_exe"])
                if "linear_deflection" in s:
                    cfg["linear_deflection"] = float(s.get("linear_deflection", cfg["linear_deflection"]))
                if "angular_deflection_deg" in s:
                    deg = float(s.get("angular_deflection_deg", DEFAULT_ANGULAR_DEGREES))
                    cfg["angular_deflection"] = deg * math.pi / 180.0
        except Exception as e:
            print("‚ö†Ô∏è Erreur lecture ini:", e)
    return cfg
    
def load_extra_commands_from_ini(path=INI_FILE):
    """Charge EXTRA_COMMANDS depuis le fichier ini si pr√©sent.
    Entr√©es: path (str chemin du fichier ini).
    Sorties: liste de tuples (cmd_list, description, delay, wait_flag)."""
    cfg = configparser.ConfigParser()
    try:
        cfg.read(path, encoding="utf-8")
        if "extra_commands" in cfg and "EXTRA_COMMANDS" in cfg["extra_commands"]:
            return ast.literal_eval(cfg["extra_commands"]["EXTRA_COMMANDS"])
    except Exception as e:
        print("‚ö†Ô∏è Erreur lecture EXTRA_COMMANDS ini:", e)
    return []

# Fusion au d√©marrage : commandes ini avant celles cod√©es en dur
EXTRA_COMMANDS = load_extra_commands_from_ini(INI_FILE) + EXTRA_COMMANDS







def save_settings(linear=None, angular_rad=None, slicer_path=None):
    """Met √† jour les valeurs de d√©flection et/ou le chemin du slicer
    sans perdre les commentaires du fichier ini.
    - linear : float (pr√©cision lin√©aire)
    - angular_rad : float (tol√©rance angulaire en radians, convertie en degr√©s)
    - slicer_path : str (chemin vers l'ex√©cutable du slicer)
    """
    angular_deg = None
    if angular_rad is not None:
        angular_deg = angular_rad * 180.0 / math.pi

    # Cr√©ation initiale avec commentaires si le fichier n'existe pas
    if not os.path.exists(INI_FILE):
        with open(INI_FILE, "w", encoding="utf-8") as f:
            f.write(
                "[Settings]\n"
                "# linear_deflection : pr√©cision lin√©aire (float)\n"
                "# angular_deflection_deg : tol√©rance angulaire en DEGR√âS (ex: 3.0)\n"
                f"linear_deflection = {linear if linear is not None else DEFAULT_LINEAR_DEFLECTION}\n"
                f"angular_deflection_deg = {angular_deg if angular_deg is not None else DEFAULT_ANGULAR_DEGREES}\n"
                f"slicer_exe = {slicer_path if slicer_path else ''}\n\n"
                "[extra_commands]\n"
                "EXTRA_COMMANDS = [\n"
                "# IMPORTANT :\n"
                "# - Les valeurs doivent √™tre indent√©es (au moins un espace ou une tabulation).\n"
                "# - Exemple correct :\n"
                "#     ([\"calc.exe\"], \"Ouvrir la calculatrice Windows ?\", 0, False),\n"
                "#     ([\"curl\", \"https://pijeedom/core/api/jeeApi.php?apikey=...\", \"--insecure\"], \"Turn on Q1Pro ?\", 0, True)\n"
                "# Placez ici vos commandes :\n"
                "\n"
                "\n"
                "    ]\n"
            )
        print("‚úÖ Fichier ini cr√©√© avec commentaires :", INI_FILE)
        return

    # Mise √† jour cibl√©e de [Settings]
    with open(INI_FILE, "r", encoding="utf-8") as f:
        lines = f.readlines()

    new_lines = []
    in_settings = False
    for line in lines:
        if line.strip().startswith("[Settings]"):
            in_settings = True
            new_lines.append(line)
            continue
        if in_settings and line.strip().startswith("[") and not line.strip().startswith("[Settings]"):
            in_settings = False
        if in_settings:
            if line.strip().startswith("linear_deflection") and linear is not None:
                new_lines.append(f"linear_deflection = {linear}\n")
                continue
            if line.strip().startswith("angular_deflection_deg") and angular_deg is not None:
                new_lines.append(f"angular_deflection_deg = {angular_deg}\n")
                continue
            if line.strip().startswith("slicer_exe") and slicer_path is not None:
                new_lines.append(f"slicer_exe = {slicer_path}\n")
                continue
        new_lines.append(line)

    with open(INI_FILE, "w", encoding="utf-8") as f:
        f.writelines(new_lines)

    print("‚úÖ Mise √† jour ini :", INI_FILE,
          "linear=", linear, "angular_deg=", angular_deg, "slicer_exe=", slicer_path)



def load_config():
    """Charge la configuration utilisateur depuis 3mfToPrint.ini.
    Retourne un dict avec angular_deflection en radians pour FreeCAD."""
    cfg = {
        "slicer_exe": DEFAULT_SLICER_EXE,
        "linear_deflection": DEFAULT_LINEAR_DEFLECTION,
        "angular_deflection": DEFAULT_ANGULAR_DEFLECTION,  # radians en interne
    }

    if not os.path.exists(INI_FILE):
        return cfg

    try:
        config = configparser.ConfigParser()
        config.read(INI_FILE, encoding="utf-8")

        # Section Settings
        if "Settings" in config:
            s = config["Settings"]

            if "slicer_exe" in s:
                cfg["slicer_exe"] = s.get("slicer_exe", cfg["slicer_exe"])

            if "linear_deflection" in s:
                try:
                    cfg["linear_deflection"] = float(s.get("linear_deflection", cfg["linear_deflection"]))
                except Exception:
                    pass

            # Lecture en degr√©s, conversion en radians
            if "angular_deflection_deg" in s:
                try:
                    deg = float(s.get("angular_deflection_deg", DEFAULT_ANGULAR_DEGREES))
                    cfg["angular_deflection"] = deg * math.pi / 180.0
                except Exception:
                    pass

    except Exception as e:
        print("‚ö†Ô∏è Erreur lecture ini:", e)

    return cfg



def ask_user_options(current_slicer, current_linear, current_angular):
    """Affiche bo√Æte de dialogue pour options export (positions, params, STL, slicer, 
    deflection).
    Entr√©es: slicer_path_pref (str), linear_pref (float), angular_pref (float).
    Sorties: tuple (keep_params, keep_positions, generate_stl, slicer_path, launch_slicer, 
    linear_value, angular_value, extra_cmds)."""
    dialog = QtGui.QDialog()
    dialog.setWindowTitle("Options d'export vers QidiStudio")
    dialog.setMinimumWidth(720)

    layout = QtGui.QVBoxLayout()

    # Cases principales
    chk_params = QtGui.QCheckBox("Conserver les param√®tres d'impression (profil du slicer)")
    chk_params.setChecked(True)
    layout.addWidget(chk_params)

    chk_positions = QtGui.QCheckBox("Conserver les positions sur le plateau")
    chk_positions.setChecked(True)
    layout.addWidget(chk_positions)

    # Nouvelle case : g√©n√©rer STL
    chk_stl = QtGui.QCheckBox("En plus du .3mf, g√©n√©rer √©galement un STL")
    chk_stl.setChecked(False)
    layout.addWidget(chk_stl)

    # Ligne combin√©e : case "Lancer le slicer" + champ chemin
    h_slicer = QtGui.QHBoxLayout()
    chk_launch = QtGui.QCheckBox("Lancer le slicer")
    chk_launch.setChecked(True)
    h_slicer.addWidget(chk_launch)

    edit_slicer = QtGui.QLineEdit(current_slicer or "")
    edit_slicer.setMinimumWidth(420)
    h_slicer.addWidget(edit_slicer, stretch=1)

    btn_browse = QtGui.QPushButton("Parcourir‚Ä¶")
    def browse():
        path, _ = QtGui.QFileDialog.getOpenFileName(dialog, "Choisir l'ex√©cutable du slicer")
        if path:
            edit_slicer.setText(path)
    btn_browse.clicked.connect(browse)
    h_slicer.addWidget(btn_browse)

    layout.addLayout(h_slicer)

    # Pr√©cision lin√©aire
    h_lin = QtGui.QHBoxLayout()
    lbl_lin = QtGui.QLabel("Pr√©cision (LinearDeflection) entre 0.01 et 10. Haute qualit√© : 0.01")
    lbl_lin.setMinimumWidth(420)
    h_lin.addWidget(lbl_lin)

    spin_lin = QtGui.QDoubleSpinBox()
    spin_lin.setRange(0.01, 10.0)
    spin_lin.setSingleStep(0.01)
    spin_lin.setDecimals(2)
    spin_lin.setMaximumWidth(80)
    try:
        spin_lin.setValue(round(float(current_linear), 2))
    except Exception:
        spin_lin.setValue(DEFAULT_LINEAR_DEFLECTION)
    h_lin.addWidget(spin_lin)
    h_lin.addStretch()
    layout.addLayout(h_lin)

    # Tol√©rance angulaire
    h_ang = QtGui.QHBoxLayout()
    lbl_ang = QtGui.QLabel("Tol√©rance angulaire (AngularDeflection) en degr√©s (ex: 3)")
    lbl_ang.setMinimumWidth(420)
    h_ang.addWidget(lbl_ang)

    spin_ang = QtGui.QDoubleSpinBox()
    spin_ang.setRange(1.0, 90.0)
    spin_ang.setSingleStep(1.0)
    spin_ang.setDecimals(1)
    spin_ang.setMaximumWidth(80)
    try:
        deg = float(current_angular) * 180.0 / math.pi
        spin_ang.setValue(deg)
    except Exception:
        spin_ang.setValue(DEFAULT_ANGULAR_DEGREES)
    h_ang.addWidget(spin_ang)
    h_ang.addStretch()
    layout.addLayout(h_ang)

    # Cases pour les commandes externes
    extra_checks = []
    if EXTRA_COMMANDS:
        layout.addWidget(QtGui.QLabel("Actions externes √† ex√©cuter avant fermeture :"))
    for cmd, label, delay, default in EXTRA_COMMANDS:
        chk = QtGui.QCheckBox(label)
        chk.setChecked(default)
        layout.addWidget(chk)
        extra_checks.append((chk, cmd, delay))

    # Boutons OK/Annuler
    btns = QtGui.QDialogButtonBox(QtGui.QDialogButtonBox.Ok | QtGui.QDialogButtonBox.Cancel)
    layout.addWidget(btns)
    dialog.setLayout(layout)

    btns.accepted.connect(dialog.accept)
    btns.rejected.connect(dialog.reject)

    if dialog.exec() == QtGui.QDialog.Accepted:
        linear_val = float(spin_lin.value())
        angular_deg = float(spin_ang.value())
        angular_rad = angular_deg * math.pi / 180.0
        return (
            chk_params.isChecked(),
            chk_positions.isChecked(),
            chk_stl.isChecked(),          # <-- ajout du flag STL
            edit_slicer.text(),
            chk_launch.isChecked(),
            linear_val,
            angular_rad,
            [(chk.isChecked(), cmd, delay) for chk, cmd, delay in extra_checks]
        )
    else:
        return (None, None, None, None, None, None, None, [])

# -------------------------
# Fonctions de traitement 3MF / mesh
# -------------------------
def find_geom_file_in_3mf(zip_path):
    """Cherche le fichier de g√©om√©trie principal dans une archive 3MF.
    Entr√©es: fc_3mf (str chemin). Sorties: nom du fichier de g√©om√©trie ou None."""
    with zipfile.ZipFile(zip_path, 'r') as z:
        rels_name = "_rels/.rels"
        if rels_name in z.namelist():
            try:
                rels_bytes = z.read(rels_name)
                rels_text = rels_bytes.decode("utf-8")
                root = ET.fromstring(rels_text)
                for rel in root:
                    if rel.tag.endswith("Relationship"):
                        rtype = rel.attrib.get("Type", "")
                        if rtype == "http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel":
                            target = rel.attrib.get("Target")
                            if target and target.startswith("/"):
                                target = target[1:]
                            if target in z.namelist():
                                return target
            except Exception:
                pass
        for name in z.namelist():
            if fnmatch.fnmatch(name, "3D/Objects/*.model"):
                return name
        if "3D/3dmodel.model" in z.namelist():
            return "3D/3dmodel.model"
    return None

def reset_item_transform(model_data, center=(CENTER_X, CENTER_Y, CENTER_Z)):
    """R√©initialise le transform d‚Äôun item dans 3dmodel.model.
    Entr√©es: data (bytes XML), center (tuple X,Y,Z). Sorties: bytes XML modifi√© 
    avec transform identit√© ou centr√©."""
    text = model_data.decode("utf-8")
    new_transform = f'transform="1 0 0 0 1 0 0 0 1 {center[0]} {center[1]} {center[2]}"'
    text = re.sub(r'(<item[^>]*?)\s+transform="[^"]+"', r'\1 ' + new_transform, text)
    return text.encode("utf-8")


def export_stl_with_deflection(selection, stl_path,
                               linear_deflection=DEFAULT_LINEAR_DEFLECTION,
                               angular_deflection=DEFAULT_ANGULAR_DEFLECTION):
    """Exporte la s√©lection FreeCAD en STL avec d√©flection donn√©e.
    Entr√©es: selection (objets FreeCAD), stl_path (str chemin),
    linear_deflection (float), angular_deflection (float).
    Sorties: fichier .stl g√©n√©r√©."""
    doc = FreeCAD.ActiveDocument
    temp_objs = []
    try:
        for obj in selection:
            mesh = MeshPart.meshFromShape(
                Shape=obj.Shape,
                LinearDeflection=float(linear_deflection),
                AngularDeflection=float(angular_deflection)
            )
            mobj = doc.addObject("Mesh::Feature", f"TempMeshSTL_{obj.Name}")
            mobj.Mesh = mesh
            temp_objs.append(mobj)
        doc.recompute()
        Mesh.export(temp_objs, stl_path)
        print("‚úÖ STL g√©n√©r√© avec d√©flection :", stl_path)
    finally:
        for t in temp_objs:
            try:
                doc.removeObject(t.Name)
            except Exception:
                pass
        doc.recompute()




def export_selection_with_deflection(selection, out_3mf_path,
                                     linear_deflection=DEFAULT_LINEAR_DEFLECTION,
                                     angular_deflection=DEFAULT_ANGULAR_DEFLECTION):
    """Exporte la s√©lection FreeCAD en 3MF avec d√©flection donn√©e.
    Entr√©es: selection (objets FreeCAD), fc_3mf (str chemin), 
    linear_deflection (float), angular_deflection (float).
    Sorties: fichier .3mf g√©n√©r√©."""
    doc = FreeCAD.ActiveDocument
    temp_objs = []
    try:
        for obj in selection:
            mesh = MeshPart.meshFromShape(Shape=obj.Shape,
                                          LinearDeflection=float(linear_deflection),
                                          AngularDeflection=float(angular_deflection))
            mobj = doc.addObject("Mesh::Feature", f"TempMesh_{obj.Name}")
            mobj.Mesh = mesh
            temp_objs.append(mobj)
        doc.recompute()
        Mesh.export(temp_objs, out_3mf_path)
    finally:
        for t in temp_objs:
            try:
                doc.removeObject(t.Name)
            except Exception:
                pass
        doc.recompute()
        
        
def recenter_vertices(model_data):
    try:
        # Enregistre le namespace par d√©faut pour √©viter le pr√©fixe ns0
        ET.register_namespace('', "http://schemas.microsoft.com/3dmanufacturing/core/2015/02")

        root = ET.fromstring(model_data.decode("utf-8"))
        ns = {"ns": "http://schemas.microsoft.com/3dmanufacturing/core/2015/02"}
        verts = root.findall(".//ns:vertex", ns)

        xs = [float(v.attrib["x"]) for v in verts]
        ys = [float(v.attrib["y"]) for v in verts]
        xc = (min(xs) + max(xs)) / 2.0
        yc = (min(ys) + max(ys)) / 2.0

        for v in verts:
            v.attrib["x"] = str(float(v.attrib["x"]) - xc)
            v.attrib["y"] = str(float(v.attrib["y"]) - yc)

        # Retourne le XML sans ns0
        return ET.tostring(root, encoding="utf-8", xml_declaration=False)
    except Exception as e:
        print("‚ö†Ô∏è Erreur recentrage vertex :", e)
        return model_data

# -------------------------
# Routine principale
# -------------------------
def export_replace_geometry():
    """Routine principale: exporte projet FreeCAD en .3mf, 
    remplace g√©om√©trie Qidi par celle de FreeCAD,
    applique options (recentrage, positions, params), lance slicer et 
    commandes externes. Peut aussi g√©n√©rer un STL si demand√©.
    Entr√©es: document actif FreeCAD + options utilisateur. 
    Sorties: fichier .3mf et √©ventuellement .stl final pr√™t pour QidiStudio."""
    cfg = load_config()
    doc = FreeCAD.ActiveDocument
    if not doc:
        show_message("Erreur", "‚ùå Aucun document ouvert dans FreeCAD.")
        return

    fcstd_path = doc.FileName
    if not fcstd_path:
        show_message("Erreur", "‚ùå Le projet n'a pas encore √©t√© sauvegard√©.")
        return

    base_name = os.path.splitext(fcstd_path)[0]
    fc_3mf = base_name + ".3mf"
    old_3mf = base_name + ".old.3mf"

    if os.path.exists(fc_3mf):
        try:
            shutil.move(fc_3mf, old_3mf)
        except Exception:
            pass

    selection = FreeCADGui.Selection.getSelection()
    if not selection:
        show_message("Avertissement", "‚ö†Ô∏è Aucun objet s√©lectionn√©.")
        return
    if len(selection) > 1:
        show_message("Avertissement", "‚ö†Ô∏è S√©lection multiple non support√©e.")
        return

    slicer_path_pref = cfg.get("slicer_exe", DEFAULT_SLICER_EXE)
    linear_pref = cfg.get("linear_deflection", DEFAULT_LINEAR_DEFLECTION)
    angular_pref = cfg.get("angular_deflection", DEFAULT_ANGULAR_DEFLECTION)

    # ‚ö†Ô∏è Ajout du flag generate_stl
    keep_params, keep_positions, generate_stl, slicer_path, launch_slicer, linear_value, angular_value, extra_cmds = \
        ask_user_options(slicer_path_pref, linear_pref, angular_pref)

    if slicer_path is None and launch_slicer is None:
        show_message("Info", "‚ö†Ô∏è Export annul√© par l‚Äôutilisateur.")
        if os.path.exists(old_3mf) and not os.path.exists(fc_3mf):
            try:
                shutil.move(old_3mf, fc_3mf)
            except Exception:
                pass
        return

    save_settings(linear=linear_value, angular_rad=angular_value)
    print("‚úÖ Valeurs sauvegard√©es :", linear_value, angular_value)

    try:
        export_selection_with_deflection(selection, fc_3mf,
                                         linear_deflection=linear_value,
                                         angular_deflection=angular_value)
    except Exception as e:
        show_message("Erreur", f"‚ùå Erreur lors de l'export 3MF : {e}")
        if os.path.exists(old_3mf) and not os.path.exists(fc_3mf):
            try:
                shutil.move(old_3mf, fc_3mf)
            except Exception:
                pass
        return

    print("Exportation FreeCAD termin√©e :", fc_3mf)

    # üîß G√©n√©ration STL si demand√©
    if generate_stl:
        stl_path = base_name + ".stl"
        try:
            export_stl_with_deflection(selection, stl_path,
                                       linear_deflection=linear_value,
                                       angular_deflection=angular_value)
        except Exception as e:
            show_message("Erreur", f"‚ùå Erreur lors de la g√©n√©ration du STL : {e}")

    if os.path.exists(old_3mf):
        geom_entry = find_geom_file_in_3mf(fc_3mf)
        if not geom_entry:
            show_message("Erreur", "‚ùå Aucun fichier de g√©om√©trie d√©tect√© dans le 3MF export√©.")
            return
        with zipfile.ZipFile(fc_3mf, 'r') as fc_zip:
            geom_data = fc_zip.read(geom_entry)

        tmp_new = base_name + ".new.3mf"

        try:
            with zipfile.ZipFile(old_3mf, 'r') as old_zip, zipfile.ZipFile(tmp_new, 'w') as new_zip:
                for item in old_zip.infolist():
                    data = old_zip.read(item.filename)
                    if item.filename.startswith("3D/Objects/") and item.filename.endswith(".model"):
                        geom_data_centered = recenter_vertices(geom_data)
                        new_zip.writestr(item.filename, geom_data_centered)
                    elif item.filename.endswith("3dmodel.model"):
                        if not keep_positions:
                            data = reset_item_transform(data, center=(CENTER_X, CENTER_Y, CENTER_Z))
                        new_zip.writestr(item.filename, data)
                    elif not keep_params and item.filename.startswith("Metadata/"):
                        continue
                    else:
                        new_zip.writestr(item, data)
        except Exception as e:
            show_message("Erreur", f"‚ùå Erreur lors de la cr√©ation du 3MF final : {e}")
            return

        try:
            if os.path.exists(fc_3mf):
                os.remove(fc_3mf)
        except Exception:
            pass
        try:
            shutil.move(tmp_new, fc_3mf)
        except Exception as e:
            show_message("Erreur", f"‚ùå Impossible de remplacer le 3MF : {e}")
            return
        try:
            if os.path.exists(old_3mf):
                os.remove(old_3mf)
        except Exception:
            pass

        print("‚úÖ G√©om√©trie FreeCAD inject√©e et options appliqu√©es :", fc_3mf)

        if launch_slicer and slicer_path and os.path.exists(slicer_path):
            try:
                subprocess.Popen([slicer_path, fc_3mf])
            except Exception as e:
                show_message("Erreur", f"‚ùå Erreur lors du lancement du slicer : {e}")
        else:
            if not launch_slicer:
                show_message("Info", "‚úÖ Export termin√©. Le slicer n'a pas √©t√© lanc√© (option d√©coch√©e).")

        if slicer_path and os.path.exists(slicer_path):
            try:
                save_settings(slicer_path=slicer_path)
            except Exception:
                pass
    else:
        print("‚úÖ Fichier g√©n√©r√© uniquement par FreeCAD :", fc_3mf)

    for checked, cmd, delay in extra_cmds:
        if checked:
            try:
                if delay > 0:
                    time.sleep(delay)
                subprocess.Popen(cmd)
                print("‚úÖ Commande externe ex√©cut√©e :", cmd[0])
            except Exception as e:
                show_message("Erreur", f"‚ùå Impossible d'ex√©cuter la commande externe : {e}")


# Lancement automatique
if __name__ == "__main__":
    export_replace_geometry()
