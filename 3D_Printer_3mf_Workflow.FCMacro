# -*- coding: utf-8 -*-
"""
Macro FreeCAD multilingue : export 3MF/STL avec contr√¥le de tessellation,
conservation des param√®tres du slicer, ouverture automatique du slicer,
et d√©clenchement de commandes externes (domotique).
S'il y a deux objets dans le 3mf source, ne garde que le premier

Variables contenant le nom des fichiers :
fc_3mf : test.3mf si le projet est test.FCStd
    AVANT EXPORT FREECAD
    C'est le fichier g√©n√©r√© par le slicer avec les param√®tre impression.
    S'il existe au lancement de la macro, fc_3mf_existed_at_start = True
    APRES EXPORT FREECAD
    Ecras√© par FreeCAD au moment de l'export, il contient alors la g√©om√©trie mais pas les param√®tres d'impression

old_3mf_backup : Ex test.old.3mf
    Sauvegarde du fichier du slicer avant export, il contient les param√®tres impression
    Cr√©√© (copi√© de fc_3mf) au d√©but de la macro si fc_3mf existe.

    fc_3mf (avant export)
        ‚Üì copie
    old_3mf_backup  ‚Üê contient les param√®tres d'impression si fc_3mf les a
        ‚Üì export FreeCAD
    fc_3mf (apr√®s export) ‚Üê contient la g√©om√©trie FreeCAD, pas les param√®tres impression
        ‚Üì injection
    fc_3mf (final) ‚Üê g√©om√©trie FreeCAD + position Qidi

tmp_new
    fichier provisoir qui sert √† construire le fichier 3mf d√©ficnitif

slicer_source
    contient le nom du slicer source. D√©fini dans prepare_environment()
slicer_target
    contient le nom du slicer cible. D√©fini juste apr√®s la boite de dialogue principale
fc_3mf_existed_at_start
    comme son nom l'indique


"""

import math, os, zipfile, shutil, subprocess, re, fnmatch, xml.etree.ElementTree as ET
import configparser, ast, platform, time
import FreeCAD, FreeCADGui, Mesh, MeshPart
from PySide import QtGui, QtCore
from typing import Dict, Optional
import gc
import tempfile
import traceback
print(">>> VERSION MACRO ACTIVE <<<")

# -------------------------
# Constantes et configuration
# -------------------------
INI_FILE = os.path.join(os.path.dirname(__file__), "3D_Printer_3mf_Workflow.ini")
PLATEAU_X, PLATEAU_Y, PLATEAU_Z = 240, 240, 0
MAX_OLD_BACKUPS = 5

DEBUG = True

if platform.system() == "Windows":
    DEFAULT_SLICER_EXE = r"C:\Program Files\QIDIStudio\qidi-studio.exe"
elif platform.system() == "Linux":
    DEFAULT_SLICER_EXE = "/usr/bin/qidi-studio"
else:
    DEFAULT_SLICER_EXE = ""

DEFAULT_LINEAR_DEFLECTION = 0.01
DEFAULT_ANGULAR_DEGREES = 2
DEFAULT_ANGULAR_DEFLECTION = DEFAULT_ANGULAR_DEGREES * math.pi / 180.0

EXTRA_COMMANDS = [
    # (["calc.exe"], "Ouvrir la calculatrice Windows ?", 0, False),
    # (["curl", "-u", "admin:motDePass", "--insecure",
    #  "http://IpDeLaPriseShelly/rpc/Switch.Set?id=0&on=true"],
    #  "Allumer la prise Shelly Gen2 ?", 0, False),
]


# Charge les commandes externes d√©finies dans le fichier ini
def load_extra_commands_from_ini(path=INI_FILE):
    cfg = configparser.ConfigParser()
    try:
        cfg.read(path, encoding="utf-8")
        if "extra_commands" in cfg and "EXTRA_COMMANDS" in cfg["extra_commands"]:
            return ast.literal_eval(cfg["extra_commands"]["EXTRA_COMMANDS"])
    except Exception as e:
        print("‚ö†Ô∏è Read error EXTRA_COMMANDS ini:", e)
    return []


# Fusion au d√©marrage : commandes ini avant celles cod√©es en dur
EXTRA_COMMANDS = load_extra_commands_from_ini(INI_FILE) + EXTRA_COMMANDS

# -------------------------
# Traductions multilingues
# -------------------------
TRANSLATIONS = {
    "fr": {
        # Titres
        "error_title": "Erreur",
        "warn_title": "Avertissement",
        "info_title": "Info",

        # Buttons
        # "btn_keep": "Conserver",
        "btn_delete": "Ok",
        "btn_cancel": "Annuler",

        # Options UI
        "options_title": "Options d'export vers QidiStudio",
        "keep_positions": "Conserver les positions sur le plateau",
        "generate_stl": "En plus du .3mf, g√©n√©rer √©galement un STL",
        "launch_slicer": "Lancer le slicer",
        "browse": "Parcourir‚Ä¶",
        "linear_label": "Pr√©cision (LinearDeflection). Entre 0.01 et 10. Haute qualit√© : 0.01",
        "angular_label": "Tol√©rance angulaire (AngularDeflection) (ex: 3)",
        "external_actions": "Actions externes √† ex√©cuter avant fermeture :",
        "ignore_transform": "Ne pas r√©cup√©rer la position/rotation du slicer",
        "base3mf_label": "Fichier 3MF pour param√®tres impr. :",
        "base3mf_dialog_title": "Choisir un fichier 3MF pour les param√®tres d'impression",
        "base3mf_filter": "Fichiers 3MF (*.3mf)",
        "select_3mf_placeholder": "S√©lectionner un fichier .3mf",
        "hint_base3mf": "Facultatif : permet d‚Äôutiliser les param√®tres d‚Äôimprimante d‚Äôun autre fichier 3MF."
                        "\nPar d√©faut, le fichier 3MF du projet est utilis√©.",

        # Messages d'erreur / avertissement
        "error_no_doc": "‚ùå Aucun document ouvert dans FreeCAD.",
        "error_no_save": "‚ùå Le projet n'a pas encore √©t√© sauvegard√©.",
        "warn_no_selection": "‚ö†Ô∏è Aucun objet s√©lectionn√©.",
        "warn_multi_selection": "‚ö†Ô∏è S√©lection multiple non support√©e.",
        "error_write_ini": "‚ùå √âcriture impossible sur le fichier ini :",
        "error_export_3mf": "‚ùå Erreur lors de l'export 3MF :",
        "error_generate_stl": "‚ùå Erreur lors de la g√©n√©ration du STL :",
        "error_create_3mf": "‚ùå Erreur lors de la cr√©ation du 3MF final :",
        "error_replace_3mf": "‚ùå Impossible de remplacer le 3MF :",
        "error_launch_slicer": "‚ùå Erreur lors du lancement du slicer :",
        "error_external_cmd": "‚ùå Impossible d'ex√©cuter la commande externe :",
        "error_no_geom": "‚ùå Aucun fichier de g√©om√©trie d√©tect√© dans le 3MF export√©.",
        "error_invalid_slicer": "‚ùå Le chemin du slicer est invalide :",
        "warn_no_geom_vertices": "L'objet s√©lectionn√© n'a pas de g√©om√©trie 3D utilisable (par ex. un Sketch).",
        "warn_incompatible_slicer_dialog":
            "Le fichier 3MF d‚Äôorigine provient de : {source}\n"
            "Le slicer cible s√©lectionn√© est :       {target}\n\n"
            "Ces slicers ne sont pas identiques.\n"
            "Continuer en effa√ßant le fichier 3mf, sans r√©cup√©ration des param√®tres d'impression ?",
        "warn_empty_plate":
            "‚ö†Ô∏è Le fichier 3MF du slicer ne contient aucun objet et ne peut servir de base.\n"
            "Cela arrive souvent apr√®s une suppression dans le slicer.\n\n"
            "Que souhaitez-vous faire ?\n\n"
            "‚Ä¢ Restaurer l'ancien fichier 3MF du slicer\n"
            "‚Ä¢ Supprimer le 3MF export√© par FreeCAD et repartir comme un nouveau projet\n"
            "‚Ä¢ Annuler",
        "warn_empty_plate_title": "Plateau vide",
        "btn_restore_old_3mf": "Restaurer l'ancien 3MF",
        "btn_reset_new_project": "Repartir √† z√©ro",

        # Infos
        "info_done": "‚úÖ Export termin√©. Le slicer n'a pas √©t√© lanc√© (option d√©coch√©e).",
        "info_export_fc": "‚úÖ Fichier g√©n√©r√© uniquement par FreeCAD :",
        "info_export_slicer": "‚úÖ Export avec r√©cup√©ration des param√®tres du slicer :",
        "reset_all": "Repartir de z√©ro (ne rien conserver)",
        "hint_reset_all": "Supprime le fichier 3MF existant et relance la macro pour repartir d‚Äôun fichier vierge.",
        "reset_title": "R√©initialisation",
        "reset_message": "Le fichier 3MF existant a √©t√© supprim√©.\nLa macro va red√©marrer pour repartir d‚Äôun fichier vierge.",

        # Aides / tooltips
        "hint_linear": "Valeur plus petite = maillage plus fin.\nExemple : 0.01 = haute qualit√©, mais fichier lourd.\n"
                       "Exemple : 0.1 = adapt√© √† une imprimante FDM classique.",
        "hint_angular": "Tol√©rance angulaire en degr√©s.\nPetite valeur = plus de d√©tails, mais fichier plus lourd.",
        "hint_positions": "Conserve la position XY sur le plateau.\n‚ö†Ô∏è Le Z est toujours recalcul√© pour √©viter que l'objet soit sous le plateau.",
        "no_external_actions": "Pas encore de commandes utilisateurs ajout√©es.",
        "hint_external_actions": "Vous pouvez ajouter vos propres actions dans le fichier ini, section [extra_commands].\n"
                                 "Chaque commande peut √™tre configur√©e avec d√©lai et activation par case √† cocher.",
        "hint_generate_stl": "G√©n√®re aussi un fichier STL en plus du 3MF.",
        "hint_launch_slicer": "Lance automatiquement le slicer apr√®s export si le chemin est valide.",
        "ini_file_label": "Fichier ini :",
        "hint_ignore_transform": "Si coch√©, la position XY et la rotation du slicer ne seront pas r√©cup√©r√©es.\n"
                                 "L'objet sera replac√© droit et recentr√© sur le plateau.",

    },

    "en": {
        # Titles
        "error_title": "Error",
        "warn_title": "Warning",
        "info_title": "Info",

        # Buttons
        # "btn_keep": "Keep",
        "btn_delete": "Ok",
        "btn_cancel": "Cancel",

        # UI options
        "options_title": "Export options for QidiStudio",
        "generate_stl": "Also generate an STL along with the 3MF",
        "launch_slicer": "Launch slicer",
        "browse": "Browse‚Ä¶",
        "linear_label": "Precision (LinearDeflection). Between 0.01 and 10. High quality: 0.01",
        "angular_label": "Angular tolerance (AngularDeflection) (e.g. 3)",
        "external_actions": "External actions to execute before closing:",
        "ignore_transform": "Do not recover slicer position/rotation",
        "base3mf_label": "3MF file for print parameters:",
        "base3mf_dialog_title": "Select a 3MF file for print parameters",
        "base3mf_filter": "3MF files (*.3mf)",
        "select_3mf_placeholder": "Select a .3mf file",
        "hint_base3mf": "Optional: allows using printer parameters from another 3MF file."
                        "\nBy default, the project‚Äôs 3MF file is used.",

        # Error / warning messages
        "error_no_doc": "‚ùå No document open in FreeCAD.",
        "error_no_save": "‚ùå The project has not been saved yet.",
        "warn_no_selection": "‚ö†Ô∏è No object selected.",
        "warn_multi_selection": "‚ö†Ô∏è Multiple selection not supported.",
        "error_write_ini": "‚ùå Unable to write to the ini file:",
        "error_export_3mf": "‚ùå Error during 3MF export:",
        "error_generate_stl": "‚ùå Error during STL generation:",
        "error_create_3mf": "‚ùå Error while creating the final 3MF:",
        "error_replace_3mf": "‚ùå Unable to replace the 3MF:",
        "error_launch_slicer": "‚ùå Error while launching slicer:",
        "error_external_cmd": "‚ùå Unable to execute external command:",
        "error_no_geom": "‚ùå No geometry file detected in exported 3MF.",
        "error_invalid_slicer": "‚ùå Invalid slicer path:",
        "warn_no_geom_vertices": "Selected object does not contain usable 3D geometry (e.g. a Sketch).",
        "warn_incompatible_slicer_dialog":
            "The original 3MF file was created by: {source}\n"
            "The selected target slicer is:        {target}\n\n"
            "These slicers are not identical.\n"
            "Continue by deleting the 3MF file, without recovering the print settings?\n\n",
        "warn_empty_plate":
            "‚ö†Ô∏è The slicer's 3MF file contains no objects and cannot be used as a base.\n"
            "This often happens after deleting objects inside the slicer.\n\n"
            "What would you like to do?\n\n"
            "‚Ä¢ Restore the previous 3MF file from the slicer\n"
            "‚Ä¢ Delete the 3MF exported by FreeCAD and start a new project\n"
            "‚Ä¢ Cancel",
        "warn_empty_plate_title": "Empty build plate",
        "btn_restore_old_3mf": "Restore previous 3MF",
        "btn_reset_new_project": "Start a new project",

        # Infos
        "info_done": "‚úÖ Export finished. Slicer was not launched (option unchecked).",
        "info_export_fc": "‚úÖ File generated only by FreeCAD:",
        "info_export_slicer": "‚úÖ Export with slicer settings recovered:",
        "reset_all": "Start from scratch (discard everything)",
        "hint_reset_all": "Deletes the existing 3MF file and restarts the macro with a fresh empty project.",
        "reset_title": "Reset",
        "reset_message": "The existing 3MF file has been deleted.\nThe macro will restart with a fresh empty project.",

        # Tooltips
        "hint_linear": "Smaller value = finer mesh.\nExample: 0.01 = high quality but heavy file.\n"
                       "Example: 0.1 = suitable for standard FDM printer.",
        "hint_angular": "Angular tolerance in degrees.\nSmaller value = more detail, but heavier file.",
        "hint_positions": "Keeps XY position on the build plate.\n‚ö†Ô∏è  Z is always recalculated to prevent"
                          "the object from going below the build plate.",
        "no_external_actions": "No user commands added yet.",
        "hint_external_actions": "You can add your own actions in the ini file, section [extra_commands].\n"
                                 "Each command can be configured with delay and checkbox activation.",
        "hint_generate_stl": "Also generates an STL file along with the 3MF.",
        "hint_launch_slicer": "Automatically launches the slicer after export if the path is valid.",
        "ini_file_label": "INI file:",
        "hint_ignore_transform": "If checked, the slicer's XY position and rotation will not be recovered.\n"
                                 "The object will be placed upright and centered on the build plate.",

    }
}


# D√©termine la langue de l‚Äôutilisateur √† partir de FreeCADGui
def get_user_language():
    try:
        locale = FreeCADGui.getLocale().lower()
        # Normalisation
        if locale.startswith("fr") or "french" in locale:
            return "fr"
        if locale.startswith("en") or "english" in locale:
            return "en"
        '''
        if locale.startswith("de") or "german" in locale:
            return "de"
        if locale.startswith("es") or "spanish" in locale:
            return "es"
        if locale.startswith("it") or "italian" in locale:
            return "it"
        '''
        # Fallback
        return "en"
    except Exception:
        return "en"


# Traduit une cl√© donn√©e selon la langue utilisateur
def tr(key):
    lang = get_user_language()
    return TRANSLATIONS.get(lang, TRANSLATIONS["en"]).get(key, key)


# -------------------------
# Utilitaires UI / config
# -------------------------
# Affiche une bo√Æte de message d‚Äôinformation dans FreeCAD
def show_message(title, message):
    QtGui.QMessageBox.information(None, title, message)


# Charge la configuration (slicer, d√©flections) depuis le fichier ini
def load_config():
    cfg = {
        "slicer_exe": DEFAULT_SLICER_EXE,
        "linear_deflection": DEFAULT_LINEAR_DEFLECTION,
        "angular_deflection": DEFAULT_ANGULAR_DEFLECTION,
    }
    config = configparser.ConfigParser()
    if os.path.exists(INI_FILE):
        try:
            config.read(INI_FILE)
            if "Settings" in config:
                s = config["Settings"]
                if "slicer_exe" in s:
                    cfg["slicer_exe"] = s.get("slicer_exe", cfg["slicer_exe"])
                if "linear_deflection" in s:
                    cfg["linear_deflection"] = float(s.get("linear_deflection", cfg["linear_deflection"]))
                if "angular_deflection_deg" in s:
                    deg = float(s.get("angular_deflection_deg", DEFAULT_ANGULAR_DEGREES))
                    cfg["angular_deflection"] = deg * math.pi / 180.0
        except Exception as e:
            print("‚ö†Ô∏è Erreur lecture ini:", e)
    return cfg


# Sauvegarde les param√®tres (d√©flections, chemin slicer) dans le fichier ini
def save_settings(linear, angular_rad, slicer_path):
    angular_deg = None
    if angular_rad is not None:
        angular_deg = angular_rad * 180.0 / math.pi

    # Cr√©ation initiale avec commentaires si le fichier n'existe pas
    if not os.path.exists(INI_FILE):
        with open(INI_FILE, "w", encoding="utf-8") as f:
            f.write(
                "[Settings]\n"
                "# linear_deflection : pr√©cision lin√©aire (float)\n"
                "# angular_deflection_deg : tol√©rance angulaire en DEGR√âS (ex: 3.0)\n"
                "# slicer_exe : chemin vers l'ex√©cutable du slicer\n"
                f"linear_deflection = {linear}\n"
                f"angular_deflection_deg = {angular_deg}\n"
                f"slicer_exe = {slicer_path}\n\n"
                "[extra_commands]\n"
                "EXTRA_COMMANDS = [\n"
                "    ]\n"
            )
        return

    # Mise √† jour cibl√©e de [Settings] si le fichier existe d√©j√†
    with open(INI_FILE, "r", encoding="utf-8") as f:
        lines = f.readlines()

    new_lines = []
    in_settings = False
    for line in lines:
        if line.strip().startswith("[Settings]"):
            in_settings = True
            new_lines.append(line)
            continue
        if in_settings and line.strip().startswith("[") and not line.strip().startswith("[Settings]"):
            in_settings = False
        if in_settings:
            if line.strip().startswith("linear_deflection") and linear is not None:
                new_lines.append(f"linear_deflection = {linear}\n")
                continue
            if line.strip().startswith("angular_deflection_deg") and angular_deg is not None:
                new_lines.append(f"angular_deflection_deg = {angular_deg}\n")
                continue
            if line.strip().startswith("slicer_exe") and slicer_path is not None:
                new_lines.append(f"slicer_exe = {slicer_path}\n")
                continue
        new_lines.append(line)

    with open(INI_FILE, "w", encoding="utf-8") as f:
        f.writelines(new_lines)


# -------------------------
# Interface utilisateur
# -------------------------
# Affiche une bo√Æte de dialogue pour demander les options d‚Äôexport √† l‚Äôutilisateur
def ask_user_options(current_slicer, current_linear, current_angular):
    """Affiche bo√Æte de dialogue pour options export (positions, params, STL, slicer, deflection)."""
    dialog = QtGui.QDialog()
    dialog.setWindowTitle(tr("options_title"))
    dialog.setMinimumWidth(720)

    layout = QtGui.QVBoxLayout()

    # Cases principales
    chk_stl = QtGui.QCheckBox(tr("generate_stl"))
    chk_stl.setToolTip(tr("hint_generate_stl"))
    chk_stl.setChecked(False)

    # Nouvelle case : repartir de z√©ro
    chk_reset = QtGui.QCheckBox(tr("reset_all"))
    chk_reset.setToolTip(tr("hint_reset_all"))
    chk_reset.setChecked(False)
    layout.addWidget(chk_reset)
    layout.addWidget(chk_stl)

    # Nouvelle case : ignorer la position/rotation du slicer
    chk_ignore_transform = QtGui.QCheckBox(tr("ignore_transform"))
    chk_ignore_transform.setToolTip(tr("hint_ignore_transform"))

    chk_ignore_transform.setChecked(False)
    layout.addWidget(chk_ignore_transform)

    # Ligne combin√©e : case "Lancer le slicer" + champ chemin
    h_slicer = QtGui.QHBoxLayout()
    chk_launch = QtGui.QCheckBox(tr("launch_slicer"))
    chk_launch.setFixedWidth(250)  # largeur colonne gauche

    chk_launch.setToolTip(tr("hint_launch_slicer"))
    chk_launch.setChecked(True)
    h_slicer.addWidget(chk_launch)

    edit_slicer = QtGui.QLineEdit(current_slicer or "")
    edit_slicer.setMinimumWidth(420)
    h_slicer.addWidget(edit_slicer, stretch=1)

    btn_browse = QtGui.QPushButton(tr("browse"))

    def browse():
        path, _ = QtGui.QFileDialog.getOpenFileName(dialog, tr("browse"))
        if path:
            edit_slicer.setText(path)

    btn_browse.clicked.connect(browse)
    h_slicer.addWidget(btn_browse)
    layout.addLayout(h_slicer)

    # ------------------------------------------------------------
    # Calcul du fichier 3MF par d√©faut
    # ------------------------------------------------------------
    doc = FreeCAD.ActiveDocument
    if doc and doc.FileName:
        fcstd_path = doc.FileName
        default_fc_3mf = os.path.splitext(fcstd_path)[0] + ".3mf"
    else:
        default_fc_3mf = "select file .3mf"

    # ------------------------------------------------------------
    # Ligne "Fichier 3MF de base" align√©e EXACTEMENT comme la ligne EXE
    # ------------------------------------------------------------
    h_base3mf = QtGui.QHBoxLayout()

    lbl_base3mf = QtGui.QLabel(tr("base3mf_label"))
    lbl_base3mf.setFixedWidth(chk_launch.width())
    lbl_base3mf.setToolTip(tr("hint_base3mf"))

    h_base3mf.addWidget(lbl_base3mf)

    edit_base3mf = QtGui.QLineEdit(default_fc_3mf)
    edit_base3mf.setToolTip(tr("hint_base3mf"))

    edit_base3mf.setMinimumWidth(420)
    h_base3mf.addWidget(edit_base3mf, stretch=1)
    btn_base3mf = QtGui.QPushButton(tr("browse"))

    def browse_base3mf():
        fcstd_dir = os.path.dirname(FreeCAD.ActiveDocument.FileName) \
            if FreeCAD.ActiveDocument and FreeCAD.ActiveDocument.FileName else ""

        path, _ = QtGui.QFileDialog.getOpenFileName(
            dialog,
            tr("base3mf_dialog_title"),
            fcstd_dir,
            tr("base3mf_filter")
        )

        if path:
            edit_base3mf.setText(path)

    btn_base3mf.clicked.connect(browse_base3mf)
    h_base3mf.addWidget(btn_base3mf)

    layout.addLayout(h_base3mf)

    # Pr√©cision lin√©aire
    h_lin = QtGui.QHBoxLayout()
    lbl_lin = QtGui.QLabel(tr("linear_label"))
    lbl_lin.setMinimumWidth(420)
    h_lin.addWidget(lbl_lin)

    spin_lin = QtGui.QDoubleSpinBox()
    spin_lin.setToolTip(tr("hint_linear"))
    spin_lin.setRange(0.01, 10.0)
    spin_lin.setSingleStep(0.01)
    spin_lin.setDecimals(2)
    spin_lin.setMaximumWidth(80)
    try:
        spin_lin.setValue(round(float(current_linear), 2))
    except Exception:
        spin_lin.setValue(DEFAULT_LINEAR_DEFLECTION)
    h_lin.addWidget(spin_lin)
    lbl_lin_unit = QtGui.QLabel("mm")
    h_lin.addWidget(lbl_lin_unit)

    h_lin.addStretch()
    layout.addLayout(h_lin)

    # Tol√©rance angulaire
    h_ang = QtGui.QHBoxLayout()
    lbl_ang = QtGui.QLabel(tr("angular_label"))
    lbl_ang.setMinimumWidth(420)
    h_ang.addWidget(lbl_ang)

    spin_ang = QtGui.QDoubleSpinBox()
    spin_ang.setToolTip(tr("hint_angular"))
    spin_ang.setRange(0.5, 90.0)
    spin_ang.setSingleStep(0.5)
    spin_ang.setDecimals(1)
    spin_ang.setMaximumWidth(80)
    try:
        deg = float(current_angular) * 180.0 / math.pi
        spin_ang.setValue(deg)
    except Exception:
        spin_ang.setValue(DEFAULT_ANGULAR_DEGREES)
    h_ang.addWidget(spin_ang)
    lbl_ang_unit = QtGui.QLabel("¬∞")
    h_ang.addWidget(lbl_ang_unit)

    h_ang.addStretch()
    layout.addLayout(h_ang)

    # Cases pour les commandes externes
    extra_checks = []
    if EXTRA_COMMANDS:
        lbl_ext = QtGui.QLabel(tr("external_actions"))
        lbl_ext.setToolTip(tr("hint_external_actions") + f"\n\n{tr('ini_file_label')} {INI_FILE}")
        layout.addWidget(lbl_ext)
        for cmd, label, delay, default in EXTRA_COMMANDS:
            chk = QtGui.QCheckBox(label)
            chk.setChecked(default)
            layout.addWidget(chk)
            extra_checks.append((chk, cmd, delay))
    else:
        # üëâ Afficher un libell√© m√™me si aucune commande n'est d√©finie
        lbl_ext = QtGui.QLabel(tr("no_external_actions"))
        lbl_ext.setToolTip(tr("hint_external_actions") + f"\n\nFichier ini : {INI_FILE}")
        layout.addWidget(lbl_ext)

    # Boutons OK/Annuler
    btns = QtGui.QDialogButtonBox(QtGui.QDialogButtonBox.Ok | QtGui.QDialogButtonBox.Cancel)
    layout.addWidget(btns)
    dialog.setLayout(layout)

    btns.accepted.connect(dialog.accept)
    btns.rejected.connect(dialog.reject)

    if dialog.exec() == QtGui.QDialog.Accepted:
        linear_val = float(spin_lin.value())
        angular_deg = float(spin_ang.value())
        angular_rad = angular_deg * math.pi / 180.0
        return (
            chk_stl.isChecked(),
            edit_slicer.text(),
            edit_base3mf.text(),
            chk_launch.isChecked(),
            linear_val,
            angular_rad,
            chk_reset.isChecked(),
            chk_ignore_transform.isChecked(),
            [(chk.isChecked(), cmd, delay) for chk, cmd, delay in extra_checks],
        )


    else:
        return (None, None, None, None, None, None, None, None, [])


def get_user_options(cfg):
    """
    Affiche la bo√Æte de dialogue utilisateur :
    - param√®tres FreeCAD
    - positions
    - STL
    - slicer
    - commandes externes

    G√®re :
    - annulation
    - validation du chemin du slicer
    - sauvegarde des pr√©f√©rences


    """

    # Pr√©f√©rences actuelles
    slicer_path_pref = cfg.get("slicer_exe", DEFAULT_SLICER_EXE)
    linear_pref = cfg.get("linear_deflection", DEFAULT_LINEAR_DEFLECTION)
    angular_pref = cfg.get("angular_deflection", DEFAULT_ANGULAR_DEFLECTION)

    while True:
        # Appel de la bo√Æte de dialogue utilisateur
        (generate_stl,
         slicer_path, base3mf_path, launch_slicer,
         linear_value, angular_value, reset_all,
         ignore_transform, extra_cmds) = ask_user_options(
            slicer_path_pref, linear_pref, angular_pref
        )

        # Annulation
        if slicer_path is None and launch_slicer is None:
            # show_message(tr("info_title"), tr("info_cancel"))
            return None

        # Validation du chemin du slicer
        if launch_slicer and slicer_path and not os.path.exists(slicer_path):
            show_message(tr("error_title"), f"{tr('error_invalid_slicer')}\n{slicer_path}")
            continue

        # Options valides ‚Üí on sort de la boucle
        break

    # Sauvegarde des pr√©f√©rences
    save_settings(
        linear=linear_value,
        angular_rad=angular_value,
        slicer_path=slicer_path
    )

    return (
        generate_stl,
        slicer_path,
        base3mf_path,
        launch_slicer,
        linear_value,
        angular_value,
        reset_all,
        ignore_transform,
        extra_cmds
    )


# -------------------------
# Rotation des sauvegardes
# -------------------------
def rotate_old_backups(base_name, max_backups):
    """
    Sauvegarde le fichier base_name.3mf sous la forme :
        base_name.old.YYYY-MM-DD-HH-MM-SS.3mf

    Et conserve uniquement les max_backups fichiers les plus r√©cents.
    """
    fc_3mf = base_name + ".3mf"
    if not os.path.exists(fc_3mf):
        return

    # 1) Cr√©er un backup dat√©
    timestamp = time.strftime("%Y-%m-%d-%H-%M-%S")
    backup_path = f"{base_name}.old.{timestamp}.3mf"
    shutil.copy(fc_3mf, backup_path)

    if DEBUG:
        print("Backup dat√© cr√©√© :", os.path.basename(backup_path))

    # 2) Lister tous les backups dat√©s
    dir_name = os.path.dirname(base_name) or "."
    prefix = os.path.basename(base_name) + ".old."
    suffix = ".3mf"

    backups = []
    for fname in os.listdir(dir_name):
        if fname.startswith(prefix) and fname.endswith(suffix):
            full = os.path.join(dir_name, fname)
            backups.append(full)

    # 3) Trier par date de modification (du plus r√©cent au plus ancien)
    backups.sort(key=lambda p: os.path.getmtime(p), reverse=True)

    # 4) Supprimer les plus anciens au-del√† de max_backups
    for old in backups[max_backups:]:
        if DEBUG:
            print("Suppression ancien backup :", os.path.basename(old))
        os.remove(old)


# -------------------------
# Fonctions de traitement 3MF / mesh
# -------------------------
def detect_slicer_target_from_path(path):
    if not path:
        return None

    p = path.lower()

    # QidiSlicer (mono-objet)
    if "qidislicer" in p:
        return "qidislicer"

    # QidiStudio family (multi-objets Qidi-compatible)
    if any(x in p for x in ("qidistudio", "orca", "bambu", "creality")):
        return "qidistudio"

    # # Prusa / SuperSlicer (multi-objets standard Slic3r)

    if any(x in p for x in (
            "prusa",
            "super",
            "superslicer",
            "anycubic",
            "flashprint",
            "ideamaker",
            "raise3d",
    )):
        return "slic3r"

    # Cura
    if "cura" in p:
        return "cura"

    return "slic3r"



def build_model_xml(vertices, triangles):
    """
    Construit un XML 3MF minimal pour 3D/3dmodel.model
    √† partir d'une liste de vertices et triangles.
    """
    # Namespace officiel 3MF
    ns_uri = "http://schemas.microsoft.com/3dmanufacturing/core/2015/02"
    ET.register_namespace("", ns_uri)

    model = ET.Element("{%s}model" % ns_uri, {
        "unit": "millimeter",
        "xml:lang": "en-US"
    })

    resources = ET.SubElement(model, "resources")
    obj = ET.SubElement(resources, "object", {"id": "1", "type": "model"})
    mesh = ET.SubElement(obj, "mesh")

    # --- vertices ---
    verts = ET.SubElement(mesh, "vertices")
    for (x, y, z) in vertices:
        ET.SubElement(verts, "vertex", {
            "x": f"{x}",
            "y": f"{y}",
            "z": f"{z}"
        })

    # --- triangles ---
    tris = ET.SubElement(mesh, "triangles")
    for (v1, v2, v3) in triangles:
        ET.SubElement(tris, "triangle", {
            "v1": str(v1),
            "v2": str(v2),
            "v3": str(v3)
        })

    # --- build section ---
    build = ET.SubElement(model, "build")
    ET.SubElement(build, "item", {
        "objectid": "1",
        "transform": "1 0 0 0 1 0 0 0 1 0 0 0"
    })

    return ET.tostring(model, encoding="utf-8")



def extract_vertices_and_triangles_from_model_xml(xml_bytes):
    """
    Extrait vertices et triangles depuis un XML 3MF FreeCAD.
    Retourne (vertices, triangles)
    """
    root = ET.fromstring(xml_bytes)

    # Namespace ?
    if "}" in root.tag:
        ns_uri = root.tag.split("}")[0].strip("{")
        ns = {"m": ns_uri}
        vert_elems = root.findall(".//m:vertex", ns)
        tri_elems  = root.findall(".//m:triangle", ns)
    else:
        vert_elems = root.findall(".//vertex")
        tri_elems  = root.findall(".//triangle")

    vertices = []
    for v in vert_elems:
        vertices.append((
            float(v.get("x")),
            float(v.get("y")),
            float(v.get("z"))
        ))

    triangles = []
    for t in tri_elems:
        triangles.append((
            int(t.get("v1")),
            int(t.get("v2")),
            int(t.get("v3"))
        ))

    return vertices, triangles




def extract_vertices_from_model_xml(xml_bytes):
    """
    Extrait la liste des vertices [(x,y,z), ...] depuis un XML 3MF (3D/3dmodel.model).
    """
    root = ET.fromstring(xml_bytes)

    # Gestion du namespace √©ventuel
    if "}" in root.tag:
        ns_uri = root.tag.split("}")[0].strip("{")
        ns = {"m": ns_uri}
        vert_elems = root.findall(".//m:vertex", ns)
    else:
        vert_elems = root.findall(".//vertex")

    vertices = []
    for v in vert_elems:
        x = float(v.get("x"))
        y = float(v.get("y"))
        z = float(v.get("z"))
        vertices.append((x, y, z))

    return vertices




def compute_mesh_center(vertices):
    xs = [v[0] for v in vertices]
    ys = [v[1] for v in vertices]
    zs = [v[2] for v in vertices]
    return (
        (min(xs) + max(xs)) / 2.0,
        (min(ys) + max(ys)) / 2.0,
        (min(zs) + max(zs)) / 2.0,
    )

def compute_translation_to_match_centers(freecad_vertices, qidi_vertices):
    center_fc = compute_mesh_center(freecad_vertices)
    center_qidi = compute_mesh_center(qidi_vertices)

    tx = center_qidi[0] - center_fc[0]
    ty = center_qidi[1] - center_fc[1]
    tz = center_qidi[2] - center_fc[2]

    return (tx, ty, tz)

def apply_translation(vertices, translation):
    tx, ty, tz = translation
    return [(x + tx, y + ty, z + tz) for (x, y, z) in vertices]



# ------------------------------------------------------------
# Analyse du fichier 3MF (nb objets et slicer)
# ------------------------------------------------------------
def analyse_fichier_3mf(file_path: str) -> Dict[str, Optional[str]]:
    """
    Analyse un fichier 3MF et retourne :
    - le nombre d'objets 3D (en filtrant les objets vides)
    - le logiciel d'export (FreeCAD, PrusaSlicer, QidiSlicer, Cura, etc.)
    Orcaslicer est d√©tect√© comme bambu car c'est un fork direct
    """
    result = {
        'nombre_objets': None,
        'logiciel': None
    }

    if not os.path.exists(file_path):
        result = {
            'nombre_objets': 'nofile',
            'logiciel': 'nofile'
        }
        if DEBUG: print('Dans analyse_fichier_3mf : pas de fichier', os.path.basename(file_path))
        return result

        # ------------------------------------------------------------

    # Normalisation du nom du logiciel
    # ------------------------------------------------------------
    def normaliser_logiciel(nom: str) -> str:
        if not nom:
            return "Inconnu"

        txt = nom.strip()
        lower = txt.lower()

        # Table de correspondance
        MAPPINGS = {
            # Qidi family
            "qidistudio": "qidistudio",
            "qidislicer": "qidislicer",
            "bambu": "qidistudio",  # Orca d√©tect√© comme Bambu
            "orca": "qidistudio",  # m√™me pipeline que QidiStudio
            "creality": "qidistudio",  # Creality Print = Cura modifi√© = pipeline QidiStudio

            # Prusa-like (Slic3r family)
            "prusaslicer": "slic3r",
            "superslicer": "slic3r",
            "anycubic": "slic3r",  # Anycubic Slicer = fork Prusa
            "flashprint": "slic3r",  # FlashPrint 5 = structure Prusa-like
            "ideamaker": "slic3r",  # IdeaMaker = XML proche Prusa
            "raise3d": "slic3r",  # Raise3D Slicer = IdeaMaker rebadg√©

            # Cura family
            "cura": "cura",

            # FreeCAD
            "freecad": "freecad",
        }

        # Recherche automatique
        for key, value in MAPPINGS.items():
            if key in lower:
                return value

        # Sinon : par d√©faut : idem prusa

        return "slic3r"

    with zipfile.ZipFile(file_path, 'r') as z:

        if DEBUG:
            # ------------------------------------------------------------
            # DEBUG : afficher les 9 premi√®res lignes du fichier 3D/3dmodel.model
            # ------------------------------------------------------------
            try:
                with z.open('3D/3dmodel.model') as f:
                    raw = f.read().decode('utf-8', errors='ignore')
                    lines = raw.splitlines()
                    print("\n===== DEBUG: Premi√®res lignes de 3dmodel.model =====")
                    for i, line in enumerate(lines[:9], start=1):
                        print(f"{i:02d}: {line}")
                    print("====================================================\n")
            except Exception as e:
                print("DEBUG: Impossible de lire 3D/3dmodel.model :", e)

        # ------------------------------------------------------------
        # 1. Compter les objets 3D (en filtrant les objets vides)
        # ------------------------------------------------------------
        with z.open('3D/3dmodel.model') as f:
            model = ET.parse(f)
            ns = {'m': 'http://schemas.microsoft.com/3dmanufacturing/core/2015/02'}

            objects = model.findall('.//m:object', ns)

            objets_valides = []
            for obj in objects:
                has_mesh = obj.find('.//m:mesh', ns) is not None
                has_components = obj.find('.//m:components', ns) is not None
                if has_mesh or has_components:
                    objets_valides.append(obj)

            # Si aucun objet valide ‚Üí fallback FreeCAD (mesh unique)
            if objets_valides:
                result['nombre_objets'] = len(objets_valides)
            else:
                meshes = model.findall('.//m:mesh', ns)
                result['nombre_objets'] = len(meshes) if meshes else 1

        # ------------------------------------------------------------
        # 2. D√©tecter le logiciel qui a fourni la g√©om√©trie.
        # ------------------------------------------------------------
        logiciel_trouve = False

        metadata_file = '3D/3dmodel.model'

        with z.open(metadata_file) as f:
            metadata = ET.parse(f)
            root = metadata.getroot()
            ns = {'m': 'http://schemas.microsoft.com/3dmanufacturing/core/2015/02'}

            # --------------------------------------------------------
            # 2.bis D√©tection QIDIStudio via m√©tadonn√©es "QIDIStudio:*"
            # --------------------------------------------------------
            if not logiciel_trouve:
                metas = root.findall('.//metadata') + root.findall('.//m:metadata', ns)
                for meta in metas:
                    name = meta.get('name', '').lower()
                    if name.startswith("qidistudio:"):
                        result['logiciel'] = "qidistudio"
                        logiciel_trouve = True
                        break

            # --------------------------------------------------------
            # 2.b D√©tection Cura via namespace
            # --------------------------------------------------------
            if not logiciel_trouve:
                for k, v in root.attrib.items():
                    if "ultimaker.com/xml/cura" in v.lower():
                        result['logiciel'] = "Ultimaker Cura"
                        logiciel_trouve = True
                        break

            # --------------------------------------------------------
            # 2.c D√©tection Cura via m√©tadonn√©es "cura:*"
            # --------------------------------------------------------
            if not logiciel_trouve:
                # 1) m√©tadonn√©es AVEC namespace
                metas = root.findall('.//m:metadata', ns)
                # 2) m√©tadonn√©es SANS namespace
                metas += root.findall('.//metadata')
                for meta in metas:
                    name = meta.get('name', '').lower()
                    # Ignorer le metadata ajout√© par la macro
                    if name == "cura:drop_to_buildplate":
                        continue

                    if name.startswith("cura:"):
                        result['logiciel'] = "cura"
                        logiciel_trouve = True
                        break

            # --------------------------------------------------------
            # 2.d D√©tection via <metadata name="Application">
            # --------------------------------------------------------
            if not logiciel_trouve:
                creator = metadata.find('.//Creator') or metadata.find('.//Application')
                if creator is None:
                    for meta in root.findall('.//m:metadata', ns):
                        if meta.get('name', '').lower() == 'application':
                            creator = meta
                            break

                if creator is None:
                    for meta in root.findall('.//metadata'):
                        if meta.get('name', '').lower() == 'application':
                            creator = meta
                            break

                if creator is not None and creator.text:
                    result['logiciel'] = normaliser_logiciel(creator.text)
                    logiciel_trouve = True

        # ------------------------------------------------------------
        # 4. D√©tection FreeCAD via texte brut
        # ------------------------------------------------------------
        if not logiciel_trouve:
            with z.open('3D/3dmodel.model') as f:
                content = f.read().decode('utf-8', errors='ignore')
                if "freecad" in content.lower():
                    result['logiciel'] = "freecad"
                else:
                    result['logiciel'] = "unknown"

    return result


def nameSlicer(File3mf: str):
    result = analyse_fichier_3mf(File3mf)
    return result['logiciel']


def zip_contains_real_mesh(zip_path):
    """
    Retourne True si le 3MF contient au moins un <mesh>.
    Fonction fiable pour Cura, Qidi, Prusa, Orca, etc.
    """
    try:
        with zipfile.ZipFile(zip_path, "r") as zin:
            for name in zin.namelist():
                if name.endswith(".model"):
                    data = zin.read(name)
                    if b"<mesh" in data:
                        return True
    except Exception as e:
        print("‚ö†Ô∏è zip_contains_real_mesh Erreur lecture 3MF :", e)
    return False


# Recherche le fichier de g√©om√©trie principal dans une archive 3MF
def find_geom_file_in_3mf(zip_path):
    if not os.path.exists(zip_path):
        if DEBUG:
            print(' dans find_geom_file_in_3mf fichier src_3mf inexistant', zip_path)

    with zipfile.ZipFile(zip_path, 'r') as z:
        rels_name = "_rels/.rels"
        if rels_name in z.namelist():
            try:
                rels_text = z.read(rels_name).decode("utf-8")
                root = ET.fromstring(rels_text)
                for rel in root:
                    if rel.tag.endswith("Relationship"):
                        rtype = rel.attrib.get("Type", "")
                        if rtype.endswith("3dmodel"):
                            target = rel.attrib.get("Target")
                            if target and target.startswith("/"):
                                target = target[1:]
                            if target in z.namelist():
                                return target
            except Exception:
                pass
        for name in z.namelist():
            if fnmatch.fnmatch(name, "3D/Objects/*.model"):
                return name
        if "3D/3dmodel.model" in z.namelist():
            return "3D/3dmodel.model"
    return None


# Exporte une s√©lection en STL avec param√®tres de tessellation
def export_stl_with_deflection(selection, stl_path,
                               linear_deflection=DEFAULT_LINEAR_DEFLECTION,
                               angular_deflection=DEFAULT_ANGULAR_DEFLECTION):
    if DEBUG: print('Export stl FreeCAD vers stl_path', os.path.basename(stl_path))
    doc = FreeCAD.ActiveDocument
    temp_objs = []
    try:
        for obj in selection:
            mesh = MeshPart.meshFromShape(
                Shape=obj.Shape,
                LinearDeflection=float(linear_deflection),
                AngularDeflection=float(angular_deflection),
                Relative=False
            )
            mobj = doc.addObject("Mesh::Feature", f"TempMeshSTL_{obj.Name}")
            mobj.Mesh = mesh
            temp_objs.append(mobj)
        doc.recompute()
        Mesh.export(temp_objs, stl_path)
    finally:
        for t in temp_objs:
            try:
                doc.removeObject(t.Name)
            except Exception:
                pass
        doc.recompute()


# Exporte une s√©lection en 3MF avec param√®tres de tessellation
def export_selection_with_deflection(selection, out_3mf_path,
                                     linear_deflection=DEFAULT_LINEAR_DEFLECTION,
                                     angular_deflection=DEFAULT_ANGULAR_DEFLECTION):
    if DEBUG: print('Export 3mf FreeCAD vers out_3mf_path', os.path.basename(out_3mf_path))
    doc = FreeCAD.ActiveDocument
    temp_objs = []
    try:
        for obj in selection:
            mesh = MeshPart.meshFromShape(
                Shape=obj.Shape,
                LinearDeflection=float(linear_deflection),
                AngularDeflection=float(angular_deflection),
                Relative=False
            )
            mobj = doc.addObject("Mesh::Feature", f"TempMesh_{obj.Name}")
            mobj.Mesh = mesh
            temp_objs.append(mobj)
        doc.recompute()
        Mesh.export(temp_objs, out_3mf_path)
    finally:
        for t in temp_objs:
            try:
                doc.removeObject(t.Name)
            except Exception:
                pass
        doc.recompute()


def force_zmax_in_transform(model_data, decalz):
    """
    Remplace uniquement la composante Z (12e valeur) du transform des <item> dans 3dmodel.model.
    - Conserve X/Y et la matrice de rotation/√©chelle.
    - decalz (hauteur max des vertex) calcul√© par recenter_vertices.

    Si plusieurs <item> existent, on les met tous √† jour.
    """

    text = model_data.decode("utf-8")

    def repl(m):
        nums = m.group(1).split()
        # transform = 12 nombres : 9 pour la matrice, 3 pour la translation (X, Y, Z)
        if len(nums) == 12:
            nums[-1] = f"{decalz}"
            return 'transform="' + " ".join(nums) + '"'
        # Si format inattendu, on ne modifie pas
        return m.group(0)

    # Met √† jour tous les transform="..."; count=0 = sans limite
    text = re.sub(r'transform="([^"]+)"', repl, text, count=0)
    return text.encode("utf-8")

def correct_item_transform_z(model_data_centered, transform_str):
    """
    Calcule un transform corrig√© (tz ajust√©) en lisant les vertices du mesh recentr√©.
    NE TOUCHE PAS AU XML.
    Ne parse pas le fichier avec ElementTree.
    """

    text = model_data_centered.decode("utf-8", errors="replace")

    # --- 1) Extraction des vertices par regex ---
    import re
    vertex_pattern = r'<vertex[^>]*x="([^"]+)"[^>]*y="([^"]+)"[^>]*z="([^"]+)"'
    verts = re.findall(vertex_pattern, text)

    if not verts:
        return transform_str  # rien √† corriger

    vertices = [(float(x), float(y), float(z)) for (x, y, z) in verts]

    # --- 2) Lire la matrice transform ---
    values = [float(x) for x in transform_str.split()]
    if len(values) != 12:
        return transform_str

    a, b, c, d, e, f, g, h, i, tx, ty, tz = values

    # --- 3) Appliquer la rotation compl√®te ---
    z_rotated = []
    for (x, y, z) in vertices:
        zr = g * x + h * y + i * z
        z_rotated.append(zr)

    Zmin_rot = min(z_rotated)
    Zmin_effectif = Zmin_rot + tz

    tz_corrected = tz - Zmin_effectif

    if DEBUG:
        print(f"[DEBUG ROT] Zmin_rot={Zmin_rot:.3f}, tz={tz:.3f} ‚Üí tz_corrected={tz_corrected:.3f}")

    # --- 4) Retourner le transform corrig√© ---
    new_values = [a, b, c, d, e, f, g, h, i, tx, ty, tz_corrected]
    return " ".join(f"{v:.6f}" for v in new_values)

def clean_multi_object_style(src_3mf, dst_3mf):
    """
    Nettoyage CHIRURGICAL d'un 3MF QidiStudio.
    Version corrig√©e + PATCH chemins :
    - Normalisation des chemins (strip + replace)
    - D√©tection correcte du parent (object id="X")
    - Suppression des objets exc√©dentaires
    - Suppression des items exc√©dentaires
    - Suppression des relations exc√©dentaires
    - Nettoyage complet de Metadata/model_settings.config
    """

    if DEBUG: print("\n=== clean_multi_object_style ===")
    if not os.path.exists(src_3mf):
        if DEBUG: print(' dans clean_multi_object_style fichier src_3mf inexistant', src_3mf)

    rels_path = "3D/_rels/3dmodel.model.rels"
    config_path = "Metadata/model_settings.config"
    model_path = "3D/3dmodel.model"

    with zipfile.ZipFile(src_3mf, "r") as zin:

        # --- 1) D√©tection des fichiers objets ---
        object_models = [
            n.strip().replace("\\", "/")
            for n in zin.namelist()
            if n.startswith("3D/Objects/") and n.endswith(".model")
        ]

        if DEBUG: print(f"üìÅ Objets trouv√©s : {object_models}")

        if not object_models:
            # Cas Cura / Prusa / QidiSlicer / FreeCAD : mono-objet standard
            if DEBUG: print("‚ÑπÔ∏è Aucun fichier 3D/Objects/*.model ‚Üí mono-objet standard")
            shutil.copy(src_3mf, dst_3mf)
            return None, "3D/3dmodel.model"


        keep_model = object_models[0]
        to_delete = object_models[1:]

        if DEBUG: print(f"‚û°Ô∏è Objet conserv√© : {keep_model}")
        if DEBUG: print(f"üóëÔ∏è Objets supprim√©s : {to_delete}")

        # --- 2) Nettoyage CHIRURGICAL du 3dmodel.model ---
        model_txt = zin.read(model_path).decode("utf-8")

        """
        # D√©tection du parent r√©el
        parent_pattern = (
            rf'<object[^>]*id="(\d+)"[^>]*>[\s\S]*?'
            rf'<component[^>]*p:path="/{keep_model}"'
        )
        """

        parent_pattern = (
            rf'<object[^>]*id="(\d+)"[^>]*>[\s\S]*?'
            rf'<component[^>]*(?:p|ns\d*):path="/{keep_model}"'
        )

        m = re.search(parent_pattern, model_txt)

        if not m:
            if DEBUG:  print("‚ùå Impossible de trouver l'objet parent dans 3dmodel.model")
            return None, keep_model

        keep_object_id = m.group(1)
        if DEBUG: print(f"‚û°Ô∏è ID parent conserv√© : {keep_object_id}")

        # SUPPRESSION des <object> exc√©dentaires
        model_txt_before = model_txt
        model_txt = re.sub(
            rf'<object[^>]*id="(?!{keep_object_id}")([\s\S]*?)</object>',
            '',
            model_txt
        )
        if model_txt != model_txt_before:
            if DEBUG: print("üóëÔ∏è Objets exc√©dentaires supprim√©s dans 3dmodel.model")

        # SUPPRESSION des <item> exc√©dentaires
        model_txt_before = model_txt
        model_txt = re.sub(
            rf'<item[^>]*objectid="(?!{keep_object_id}")([^"]*)"[^>]*/>',
            '',
            model_txt
        )
        if model_txt != model_txt_before:
            if DEBUG: print("üóëÔ∏è Items exc√©dentaires supprim√©s dans <build>")

        # --- 3) Nettoyage du rels ---
        if rels_path in zin.namelist():
            rels_txt = zin.read(rels_path).decode("utf-8")
            rels_before = rels_txt

            rels_txt = re.sub(
                rf'<Relationship[^>]*Target="(?!/{keep_model}")([^"]*)"[^>]*/>',
                '',
                rels_txt
            )

            if rels_txt != rels_before:
                if DEBUG: print("üóëÔ∏è Relations exc√©dentaires supprim√©es dans rels")

        # --- 4) Nettoyage complet du model_settings.config ---
        if config_path in zin.namelist():
            cfg_txt = zin.read(config_path).decode("utf-8")

            # SUPPRESSION <object id="...">
            cfg_before = cfg_txt
            cfg_txt = re.sub(
                rf'<object[^>]*id="(?!{keep_object_id}")([\s\S]*?)</object>',
                '',
                cfg_txt
            )
            if cfg_txt != cfg_before:
                if DEBUG: print("üóëÔ∏è Objets exc√©dentaires supprim√©s dans model_settings.config")

            # SUPPRESSION <model_instance>
            cfg_before = cfg_txt
            cfg_txt = re.sub(
                rf'<model_instance>[\s\S]*?<metadata key="object_id" value="(?!{keep_object_id}")([\s\S]*?)</model_instance>',
                '',
                cfg_txt
            )
            if cfg_txt != cfg_before:
                if DEBUG: print("üóëÔ∏è model_instance exc√©dentaires supprim√©s")

            # SUPPRESSION <assemble_item>
            cfg_before = cfg_txt
            cfg_txt = re.sub(
                rf'<assemble_item[^>]*object_id="(?!{keep_object_id}")([^"]*)"[^>]*/>',
                '',
                cfg_txt
            )
            if cfg_txt != cfg_before:
                if DEBUG: print("üóëÔ∏è assemble_item exc√©dentaires supprim√©s")

        # --- 5) R√©√©criture du ZIP ---
        if DEBUG: print("üì¶ R√©√©criture du fichier nettoy√©‚Ä¶")

        # compression = zipfile.ZIP_STORED if mode == "qidi" else zipfile.ZIP_DEFLATED
        # with zipfile.ZipFile(dst_3mf, "w", compression=compression) as zout:
        with zipfile.ZipFile(dst_3mf, "w", compression=zipfile.ZIP_STORED) as zout:

            for item in zin.infolist():
                name = item.filename.strip().replace("\\", "/")

                # SUPPRESSION des fichiers objets exc√©dentaires
                if name.startswith("3D/Objects/") and name != keep_model:
                    if DEBUG: print(f"üóëÔ∏è Suppression fichier : {name}")
                    continue

                if name == model_path:
                    zout.writestr(name, model_txt)
                    continue

                if name == rels_path:
                    zout.writestr(name, rels_txt)
                    continue

                if name == config_path:
                    zout.writestr(name, cfg_txt)
                    continue

                zout.writestr(name, zin.read(item.filename))

    if DEBUG: print("‚úÖ Nettoyage CHIRURGICAL termin√©.")
    if DEBUG: print(f"‚û°Ô∏è Objet final conserv√© : {keep_model} (id={keep_object_id})")
    if DEBUG: print(f"‚û°Ô∏è Fichier nettoy√© : {dst_3mf}")

    return keep_object_id, keep_model





def replace_mesh_in_model_xml(old_model_xml_bytes, new_model_xml_bytes):
    old_text = old_model_xml_bytes.decode("utf-8", errors="replace")
    new_text = new_model_xml_bytes.decode("utf-8", errors="replace")

    old_root = ET.fromstring(old_text)
    new_root = ET.fromstring(new_text)

    ns_uri = old_root.tag.split("}")[0].strip("{") if "}" in old_root.tag else ""
    ns = {"m": ns_uri} if ns_uri else {}

    old_mesh = old_root.find(".//m:mesh", ns) if ns else old_root.find(".//mesh")
    new_mesh = new_root.find(".//m:mesh", ns) if ns else new_root.find(".//mesh")

    if old_mesh is None or new_mesh is None:
        if DEBUG:
            print("‚ö†Ô∏è Impossible de trouver <mesh> dans l'un des fichiers.")
        return old_model_xml_bytes

    for child in list(old_mesh):
        old_mesh.remove(child)
    for child in list(new_mesh):
        old_mesh.append(child)

    xml_bytes = ET.tostring(old_root, encoding="utf-8")
    xml_decl = b'<?xml version="1.0" encoding="UTF-8"?>\n'

    if not xml_bytes.startswith(b"<?xml"):
        xml_bytes = xml_decl + xml_bytes

    return xml_bytes


def ask_incompatible_slicer_dialog(s_source, s_target):
    """
    Bo√Æte de dialogue Qt en cas de slicer source != slicer cible.
    Retourne: "keep", "delete" ou "cancel".
    """
    msg = QtGui.QMessageBox()
    msg.setIcon(QtGui.QMessageBox.Warning)
    msg.setWindowTitle(tr("warn_title"))

    # Texte multilingue avec insertion des valeurs
    txt = tr("warn_incompatible_slicer_dialog").format(
        source=s_source,
        target=s_target
    )
    msg.setText(txt)

    # Boutons
    btn_delete = msg.addButton(tr("btn_delete"), QtGui.QMessageBox.DestructiveRole)
    btn_cancel = msg.addButton(tr("btn_cancel"), QtGui.QMessageBox.RejectRole)

    msg.exec()

    if msg.clickedButton() == btn_delete:
        return "delete"
    return "cancel"


def prepare_environment():
    """
    Pr√©pare l‚Äôenvironnement :
    - charge la config
    - v√©rifie le document FreeCAD
    - d√©tecte le .3mf existant
    - renomme en .old.3mf si n√©cessaire

    Retourne :
        (cfg, doc, base_name, fc_3mf, old_3mf_backup, fc_3mf_existed_at_start)
    ou None en cas d‚Äôerreur.
    """

    cfg = load_config()

    # V√©rification document
    doc = FreeCAD.ActiveDocument
    if not doc:
        show_message(tr("error_title"), tr("error_no_doc"))
        return None

    fcstd_path = doc.FileName
    if not fcstd_path:
        show_message(tr("error_title"), tr("error_no_save"))
        return None

    # Construction des chemins
    base_name = os.path.splitext(fcstd_path)[0]
    fc_3mf = base_name + ".3mf"
    old_3mf_backup = base_name + ".old.3mf"

    # D√©tection du .3mf existant AVANT export
    fc_3mf_existed_at_start = os.path.exists(fc_3mf)

    return (cfg, doc, base_name, fc_3mf, old_3mf_backup, fc_3mf_existed_at_start)


def get_valid_selection(fc_3mf, old_3mf_backup, fc_3mf_existed_at_start):
    """
    V√©rifie la s√©lection FreeCAD :
    - 0 objet ‚Üí message + restauration √©ventuelle
    - >1 objet ‚Üí message + restauration √©ventuelle
    Retourne :
        [obj]  ‚Üí s√©lection valide
        None   ‚Üí erreur ou annulation
    """

    # R√©cup√©ration des objets s√©lectionn√©s ayant une Shape valide

    """
    selection = [
        obj for obj in FreeCADGui.Selection.getSelection()
        if hasattr(obj, "Shape") and obj.Shape is not None
    ]
    """

    sel_ex = FreeCADGui.Selection.getSelectionEx()
    selection = []

    for s in sel_ex:
        obj = s.Object
        if hasattr(obj, "Shape"):
            try:
                shape = obj.Shape
                if shape and not shape.isNull() and shape.Volume > 0:
                    selection.append(obj)
            except Exception:
                pass

    # Aucun objet s√©lectionn√©
    if not selection:
        show_message(tr("warn_title"), tr("warn_no_selection"))

        # Restauration √©ventuelle du .old.3mf
        if fc_3mf_existed_at_start \
                and os.path.exists(old_3mf_backup) \
                and not os.path.exists(fc_3mf):
            if DEBUG: print('move ', os.path.basename(old_3mf_backup), 'vers', os.path.basename(fc_3mf))
            shutil.move(old_3mf_backup, fc_3mf)

        return None

    # Trop d‚Äôobjets s√©lectionn√©s
    if len(selection) > 1:
        show_message(tr("warn_title"), tr("warn_multi_selection"))

        # Restauration √©ventuelle du .old.3mf
        if fc_3mf_existed_at_start \
                and os.path.exists(old_3mf_backup) \
                and not os.path.exists(fc_3mf):
            shutil.move(old_3mf_backup, fc_3mf)

        return None
    # S√©lection valide : un seul objet
    return selection


def export_freecad_files(selection, base_name, fc_3mf, generate_stl,
                         linear_value, angular_value,
                         fc_3mf_existed_at_start, old_3mf_backup):
    """
    Exporte :
    - 3MF FreeCAD
    - STL si demand√©

    G√®re :
    - erreurs d‚Äôexport
    - restauration √©ventuelle du .old.3mf

    Retourne :
        True  ‚Üí export OK
        False ‚Üí erreur ou restauration
    """
    if DEBUG:
        print('D√©but export_freecad_files')
        print([obj.Name for obj in selection])  ##########################

    # ------------------------------------------------------------
    # Export 3MF FreeCAD
    # ------------------------------------------------------------
    try:
        export_selection_with_deflection(
            selection, fc_3mf,
            linear_deflection=linear_value,
            angular_deflection=angular_value
        )
    except Exception as e:
        show_message(tr("error_title"), f"{tr('error_export_3mf')} {e}")

        # Restauration √©ventuelle
        if fc_3mf_existed_at_start \
                and os.path.exists(old_3mf_backup) \
                and not os.path.exists(fc_3mf):
            if DEBUG: print('move ', os.path.basename(old_3mf_backup), 'vers', os.path.basename(fc_3mf))
            shutil.move(old_3mf_backup, fc_3mf)

        return False

    # ------------------------------------------------------------
    # Export STL (optionnel)
    # ------------------------------------------------------------
    if generate_stl:
        try:
            export_stl_with_deflection(
                selection, base_name + ".stl",
                linear_deflection=linear_value,
                angular_deflection=angular_value
            )
        except Exception as e:
            show_message(tr("error_title"), f"{tr('error_generate_stl')} {e}")
            # On continue malgr√© l‚Äôerreur STL

    return True


def handle_empty_plate(fc_3mf_existed_at_start, old_3mf_backup, fc_3mf):
    if DEBUG: print('Fonction handle_empty_plate si plateau vide propose copie old_3mf_backup vers fc_3mf')
    """
    Analyse le plateau vide sur fc_3mf:
    - Si un 3MF existait avant l‚Äôexport FreeCAD
    - Si fc_3mf ne contient aucun mesh r√©el
    ‚Üí propose :
        ‚Ä¢ Restaurer l'ancien 3MF
        ‚Ä¢ Repartir √† z√©ro
        ‚Ä¢ Annuler

    Peut relancer la macro automatiquement.

    Retourne :
        True  ‚Üí continuer le workflow
        False ‚Üí arr√™ter la macro
    """

    # On ne teste le plateau vide QUE si un 3MF existait avant l‚Äôexport
    if not fc_3mf_existed_at_start:
        return True

    # V√©rifie si fc_3mf existe et contient un vrai mesh
    if not (os.path.exists(fc_3mf) and not zip_contains_real_mesh(fc_3mf)):
        return True  # Pas de plateau vide ‚Üí on continue

    # Plateau vide d√©tect√© ‚Üí bo√Æte de dialogue
    msg = tr("warn_empty_plate")

    box = QtGui.QMessageBox()
    box.setWindowTitle(tr("warn_empty_plate_title"))
    box.setText(msg)

    restore_btn = box.addButton(tr("btn_restore_old_3mf"), QtGui.QMessageBox.AcceptRole)
    reset_btn = box.addButton(tr("btn_reset_new_project"), QtGui.QMessageBox.DestructiveRole)
    cancel_btn = box.addButton(QtGui.QMessageBox.Cancel)

    box.exec()
    clicked = box.clickedButton()

    # ----------------------------------------------------------------------------
    # 1) Restaurer l'ancien 3MF = Copie old_3mf_backup en fc_3mf et relance la macro
    # ----------------------------------------------------------------------------
    if clicked == restore_btn:
        # if os.path.exists(fc_3mf):
        #    print('Effacement du fichier ', fc_3mf)
        #    os.remove(fc_3mf)
        if DEBUG: print('copy ', os.path.basename(old_3mf_backup), 'vers', os.path.basename(fc_3mf))
        shutil.copy(old_3mf_backup, fc_3mf)

        # ----------------------Relance de la macro -----------------------------------
        export_replace_geometry()
        return False  # On arr√™te ce cycle

    # ------------------------------------------------------------
    # 2) Repartir √† z√©ro = on efface fc_3mf et on relance la macro
    # ------------------------------------------------------------
    elif clicked == reset_btn:
        if os.path.exists(fc_3mf):
            os.remove(fc_3mf)
            old_3mf = base_name + ".old.3mf"
        if os.path.exists(old_3mf):
            os.remove(old_3mf)
            if DEBUG: print("Suppression de", os.path.basename(old_3mf))

        if DEBUG: print("üóëÔ∏è New projet : 3MF FreeCAD deleted. Macro run again.")
        export_replace_geometry()
        return False  # On arr√™te ce cycle

    # ------------------------------------------------------------
    # 3) Annuler
    # ------------------------------------------------------------
    else:
        if DEBUG: print("‚ÑπÔ∏è Annul√© par l‚Äôutilisateur.")
        return False


def ensure_cura_drop_to_buildplate(model_data):
    """
    Ajoute ou force <metadata name="cura:drop_to_buildplate">True</metadata>
    dans <object>, plac√© AVANT <mesh> pour respecter Cura.
    """
    if DEBUG: print(' Ensure_cura_drop_to_buildplate')
    NS = "http://schemas.microsoft.com/3dmanufacturing/core/2015/02"
    ET.register_namespace('', NS)
    ns = {"ns": NS}

    root = ET.fromstring(model_data.decode("utf-8"))

    # Trouver le premier <object>
    obj = root.find(".//ns:object", ns)
    if obj is None:
        return model_data

    # Trouver <mesh>
    mesh = obj.find("ns:mesh", ns)

    # Trouver <metadatagroup>
    md_group = obj.find("ns:metadatagroup", ns)

    # --- CAS 1 : metadatagroup existe mais est mal plac√© ‚Üí on le d√©place ---
    if md_group is not None:
        # S'il est apr√®s <mesh>, on le d√©place
        children = list(obj)
        md_index = children.index(md_group)
        if mesh is not None:
            mesh_index = children.index(mesh)
            if md_index > mesh_index:
                # Retirer et r√©ins√©rer avant mesh
                obj.remove(md_group)
                obj.insert(mesh_index, md_group)

    # --- CAS 2 : metadatagroup n'existe pas ‚Üí on le cr√©e ---
    else:
        md_group = ET.Element(f"{{{NS}}}metadatagroup")
        if mesh is not None:
            index = list(obj).index(mesh)
            obj.insert(index, md_group)
        else:
            obj.insert(0, md_group)

    # --- Ajouter ou corriger le metadata ---
    md = md_group.find("ns:metadata[@name='cura:drop_to_buildplate']", ns)
    if md is None:
        md = ET.SubElement(md_group, f"{{{NS}}}metadata")
        md.set("name", "cura:drop_to_buildplate")

    md.text = "True"

    return ET.tostring(root, encoding="utf-8", xml_declaration=False)


def patch_drop_to_buildplate_in_place(path):
    if DEBUG: print('Ajout Mise √† plat pour le slicer CURA', os.path.basename(path))
    tmp = path + ".tmp"

    # Lire
    with zipfile.ZipFile(path, 'r') as zin:
        buffer = {name: zin.read(name) for name in zin.namelist()}

    # Modifier
    if "3D/3dmodel.model" in buffer:
        buffer["3D/3dmodel.model"] = ensure_cura_drop_to_buildplate(
            buffer["3D/3dmodel.model"]
        )

    # √âcrire dans un fichier temporaire
    with zipfile.ZipFile(tmp, 'w', zipfile.ZIP_DEFLATED) as zout:
        for name, data in buffer.items():
            zout.writestr(name, data)

    # Remplacer l‚Äôoriginal
    shutil.move(tmp, path)


# Recentre les sommets en XY et calcule le decal_z pour placement correct
def recenter_vertices(model_data):
    """
    Recentre automatiquement les vertex :
    - centre XY autour de (0,0)
    - pose Zmin √† 0
    Retourne : (donn√©es XML modifi√©es, decal_z)
    """
    if DEBUG:
        print(' Recenter_vertices : recentrage automatique XY + correction Zmin')

    try:
        ET.register_namespace('', "http://schemas.microsoft.com/3dmanufacturing/core/2015/02")
        root = ET.fromstring(model_data.decode("utf-8"))
        ns = {"ns": "http://schemas.microsoft.com/3dmanufacturing/core/2015/02"}
        verts = root.findall(".//ns:vertex", ns)

        if not verts:
            show_message(tr("warn_title"), tr("warn_no_geom_vertices"))
            return model_data, 0.0

        # --- 1) Calcul des bornes ---
        xs = []
        ys = []
        zs = []

        for v in verts:
            xs.append(float(v.attrib["x"]))
            ys.append(float(v.attrib["y"]))
            zs.append(float(v.attrib["z"]))

        xmin, xmax = min(xs), max(xs)
        ymin, ymax = min(ys), max(ys)
        zmin = min(zs)

        # Centre XY
        cx = (xmin + xmax) / 2.0
        cy = (ymin + ymax) / 2.0

        # D√©calage Z
        decal_z = -zmin

        if DEBUG:
            print(f"  xmin={xmin}, xmax={xmax}, cx={cx}")
            print(f"  ymin={ymin}, ymax={ymax}, cy={cy}")
            print(f"  zmin={zmin}, decal_z={decal_z}")

        # --- 2) Recentrage effectif ---
        for v in verts:
            x = float(v.attrib["x"]) - cx
            y = float(v.attrib["y"]) - cy
            z = float(v.attrib["z"]) + decal_z

            v.attrib["x"] = f"{x:.6f}"
            v.attrib["y"] = f"{y:.6f}"
            v.attrib["z"] = f"{z:.6f}"

        return ET.tostring(root, encoding="utf-8", xml_declaration=False), decal_z

    except Exception as e:
        if DEBUG:
            print("‚ö†Ô∏è Erreur dans recenter_vertices :", e)
        return model_data, 0.0



def apply_common_transform_to_3dmodel(model_xml_bytes, geom_data_centered, ignore_transform):
    if not ignore_transform:
        return model_xml_bytes

    text = model_xml_bytes.decode("utf-8", errors="replace")

    import re

    # 1) cibler uniquement le transform du <item ...>
    item_pattern = r'(<item[^>]*transform=")([^"]*)(")'

    m = re.search(item_pattern, text)
    if not m:
        return model_xml_bytes

    old_transform = m.group(2)
    if DEBUG: print("apply_common_transform_to_3dmodel CALLED, ignore_transform=", ignore_transform)
    if DEBUG: print("old_transform=", old_transform)
    if DEBUG: print("new_transform=", base_transform)

    # 2) recentrage XY
    Xc = PLATEAU_X / 2
    Yc = PLATEAU_Y / 2
    base_transform = f"1 0 0 0 1 0 0 0 1 {Xc} {Yc} 0"

    # 3) correction Z
    corrected_transform = correct_item_transform_z(geom_data_centered, base_transform)

    # 4) remplacement via fonction (√©vite les \1, \3)
    def repl(match):
        return match.group(1) + corrected_transform + match.group(3)

    updated = re.sub(item_pattern, repl, text, count=1)

    return updated.encode("utf-8")

def apply_common_transform_to_3mf_in_place(fc_3mf):
    if DEBUG: print(
        "<<d√©but apply_common_transform_to_3mf_in_place = pr√©paration appel de apply_common_transform_to_3dmodel>>")
    # Lire tout le 3MF
    with zipfile.ZipFile(fc_3mf, 'r') as zin:
        buffer = {name: zin.read(name) for name in zin.namelist()}

    # V√©rifier la pr√©sence du 3dmodel.model
    if "3D/3dmodel.model" not in buffer:
        if DEBUG: print("‚ö†Ô∏è Pas de 3D/3dmodel.model dans le 3MF")
        return False

    # Appliquer le transform commun
    new_xml = apply_common_transform_to_3dmodel(
        buffer["3D/3dmodel.model"],
        buffer["3D/3dmodel.model"],
        True
    )
    buffer["3D/3dmodel.model"] = new_xml

    # R√©√©criture du 3MF
    with zipfile.ZipFile(fc_3mf, 'w', zipfile.ZIP_DEFLATED) as zout:
        for name, data in buffer.items():
            zout.writestr(name, data)

    return True



def inject_geometry_into_qidislicer_3mf(old_3mf_path, new_3mf_path, new_model_xml_bytes,
                                        decal_z, ignore_transform):
    """
    Version propre et compl√®te (B2A) :
    - conserve ton recentrage FreeCAD (d√©j√† appliqu√© avant l'appel)
    - aligne ensuite le mesh FreeCAD recentr√© sur le mesh Qidi
    - remplace le mesh dans 3D/3dmodel.model
    - corrige le Metadata Slic3r_PE_model.config
    """

    if DEBUG:
        print('D√©but inject_geometry_into_qidislicer_3mf')

    if not os.path.exists(old_3mf_path):
        if DEBUG:
            print('‚ö†Ô∏è Fichier Qidi introuvable :', old_3mf_path)
        return

    corrected_metadata = None
    meta_name = "Metadata/Slic3r_PE_model.config"

    with zipfile.ZipFile(old_3mf_path, "r") as zin, \
         zipfile.ZipFile(new_3mf_path, "w", compression=zipfile.ZIP_DEFLATED) as zout:

        for info in zin.infolist():
            name = info.filename
            data = zin.read(name)

            # ------------------------------------------------------------
            # 1) Remplacement du mesh + alignement FreeCAD ‚Üí Qidi
            # ------------------------------------------------------------
            if name == "3D/3dmodel.model":

                # --- 1) Extraire vertices Qidi ---
                qidi_vertices = extract_vertices_from_model_xml(data)

                # --- 2) Extraire vertices FreeCAD (d√©j√† recentr√©s) ---
                freecad_vertices, freecad_triangles = extract_vertices_and_triangles_from_model_xml(
                    new_model_xml_bytes
                )

                # --- 3) Calcul translation FreeCAD ‚Üí Qidi ---
                translation = compute_translation_to_match_centers(
                    freecad_vertices, qidi_vertices
                )

                if DEBUG:
                    print("Translation FreeCAD ‚Üí Qidi =", translation)

                # --- 4) Appliquer translation ---
                freecad_vertices_corrected = apply_translation(
                    freecad_vertices, translation
                )

                # --- 5) Reconstruire XML FreeCAD align√© ---
                aligned_model_xml = build_model_xml(
                    freecad_vertices_corrected, freecad_triangles
                )

                # --- 6) Remplacer le mesh dans le XML Qidi ---
                merged = replace_mesh_in_model_xml(data, aligned_model_xml)

                # ------------------------------------------------------------
                # 7) Correction Metadata QidiSlicer
                # ------------------------------------------------------------
                try:
                    root = ET.fromstring(merged)
                    new_root = ET.fromstring(aligned_model_xml)

                    # Namespace dynamique
                    if "}" in new_root.tag:
                        ns_uri = new_root.tag.split("}")[0].strip("{")
                        ns_tri = {"m": ns_uri}
                        tris = new_root.findall(".//m:triangle", ns_tri)
                    else:
                        tris = new_root.findall(".//triangle")

                    # S√©curit√© : fallback brut
                    if not tris:
                        tris = [t for t in new_root.iter() if t.tag.endswith("triangle")]

                    lastid = len(tris) - 1
                    if DEBUG:
                        print(">>> Qidi Metadata fix ‚Üí lastid =", lastid)

                    # Charger et corriger le Metadata
                    if meta_name in zin.namelist():
                        meta_data = zin.read(meta_name)
                        meta_root = ET.fromstring(meta_data)

                        volume = meta_root.find(".//volume")
                        if volume is not None:
                            volume.set("firstid", "0")
                            volume.set("lastid", str(lastid))

                        corrected_metadata = ET.tostring(meta_root, encoding="utf-8")

                    # Reconvertir le mod√®le Qidi avec le mesh remplac√©
                    merged = ET.tostring(root, encoding="utf-8")

                except Exception as e:
                    if DEBUG:
                        print("‚ö†Ô∏è Erreur correction Metadata QidiSlicer :", e)

                # √âcriture du fichier 3D/3dmodel.model corrig√©
                zout.writestr(name, merged)
                continue

            # ------------------------------------------------------------
            # 2) √âcriture du Metadata corrig√©
            # ------------------------------------------------------------
            if name == meta_name:
                if corrected_metadata is not None:
                    zout.writestr(name, corrected_metadata)
                else:
                    zout.writestr(name, data)
                continue

            # ------------------------------------------------------------
            # 3) Recopie du reste
            # ------------------------------------------------------------
            zout.writestr(name, data)


def inject_geometry_if_possible(base_name, fc_3mf, old_3mf_backup, fc_3mf_existed_at_start,
                                slicer_path, ignore_transform):
    """
    Injection g√©om√©trique dans un fichier 3MF existant.
    """
    if DEBUG: print('inject_geometry_if_possible')

    # ------------------------------------------------------------
    # 1) V√©rifier si injection possible
    # ------------------------------------------------------------
    is_slicer_file = os.path.exists(old_3mf_backup) and zip_contains_real_mesh(old_3mf_backup)
    inject_possible = fc_3mf_existed_at_start and is_slicer_file

    if not inject_possible:
        if DEBUG: print("‚úÖ Inject not possible. File generated exclusively by FreeCAD :", fc_3mf)
        return ""

    # ------------------------------------------------------------
    # 2) D√©tection du slicer source
    # ------------------------------------------------------------
    slicer_source = nameSlicer(old_3mf_backup)
    if DEBUG: print('slicer_source', slicer_source)

    # ------------------------------------------------------------
    # 3) D√©tection du slicer cible
    # ------------------------------------------------------------
    slicer_target = detect_slicer_target_from_path(slicer_path) if slicer_path else None

    # ------------------------------------------------------------
    # 4) Gestion des incompatibilit√©s
    # ------------------------------------------------------------
    if slicer_target not in (None, "unknown") and slicer_source not in ("none", "unknown", "freecad") \
            and slicer_source != slicer_target:

        action = ask_incompatible_slicer_dialog(slicer_source, slicer_target)
        if DEBUG: print("action =", action)

        if action == "cancel":
            if os.path.exists(fc_3mf):
                os.remove(fc_3mf)
            if fc_3mf_existed_at_start and os.path.exists(old_3mf_backup):
                shutil.move(old_3mf_backup, fc_3mf)
            return "cancel"

        if action == "delete":
            if DEBUG: print("üóëÔ∏è Suppression de l‚Äôancien 3MF incompatible.")
            try:
                os.remove(old_3mf_backup)
            except Exception as e:
                if DEBUG: print("‚ö†Ô∏è Impossible de supprimer :", e)
            inject_possible = False

    if not inject_possible:
        if DEBUG: print("‚ö†Ô∏è Injection impossible, export FreeCAD seul.")
        return ""

    # ------------------------------------------------------------
    # 5) Nettoyage du 3MF selon le slicer source
    # ------------------------------------------------------------
    cleaned_old_3mf = base_name + ".cleaned.3mf"
    keep_model = None
    keep_object_id = None

    if slicer_source in ("qidistudio", "qidislicer", "slic3r"):
        keep_object_id, keep_model = clean_multi_object_style(
            old_3mf_backup, cleaned_old_3mf
        )
    else:
        shutil.copy(old_3mf_backup, cleaned_old_3mf)
        keep_model = "3D/Objects/object_1.model"

    # üî• V√©rification critique : le fichier cleaned_old_3mf existe-t-il ?
    if slicer_source == "qidistudio" and (
            keep_object_id is None or not os.path.exists(cleaned_old_3mf)
    ):
        if DEBUG: print("‚ö†Ô∏è Nettoyage QidiStudio √©chou√© ‚Üí utilisation du 3MF d'origine")
        old_3mf = old_3mf_backup
    else:
        old_3mf = cleaned_old_3mf

    # ------------------------------------------------------------
    # 6) Extraction g√©om√©trie FreeCAD
    # ------------------------------------------------------------
    geom_entry = find_geom_file_in_3mf(fc_3mf)
    if not geom_entry:
        show_message(tr("error_title"), tr("error_no_geom"))
        return ""

    with zipfile.ZipFile(fc_3mf, 'r') as fc_zip:
        geom_data = fc_zip.read(geom_entry)

    # Cible QidiStudio : pas de recentrage ici, il sera g√©r√© dans le pipeline QidiStudio
    if slicer_target == "qidistudio":
        geom_data_centered = geom_data
        decal_z = 0
    else:
        # Tous les autres slicers gardent l'ancien recentrage
        geom_data_centered, decal_z = recenter_vertices(geom_data)

    # ------------------------------------------------------------
    # 6 bis) Recentrage final pour QidiSlicer (pipeline d√©di√©)
    # ------------------------------------------------------------
    if slicer_source == "qidislicer":
        geom_data_centered_final, decal_z_final = recenter_vertices(geom_data)
    else:
        geom_data_centered_final = geom_data
        decal_z_final = 0

    # ------------------------------------------------------------
    # 7) Reconstruction du 3MF final
    # ------------------------------------------------------------
    tmp_new = base_name + ".new.3mf"

    # ------------------------------------------------------------
    # CAS QIDISLICER (mono-objet)
    # ------------------------------------------------------------
    if slicer_source == "qidislicer":
        inject_geometry_into_qidislicer_3mf(
            old_3mf,
            tmp_new,
            geom_data_centered_final,
            decal_z_final,
            ignore_transform
        )

        # Remplacement final
        gc.collect()
        time.sleep(0.05)
        if os.path.exists(fc_3mf):
            os.remove(fc_3mf)
        shutil.move(tmp_new, fc_3mf)
        if os.path.exists(old_3mf):
            os.remove(old_3mf)
        if DEBUG: print("‚úÖ Injection faite dans :", os.path.basename(fc_3mf))
        return ""

    # ------------------------------------------------------------
    # CAS QIDISTUDIO (multi-objets)
    # ------------------------------------------------------------
    if slicer_source == "qidistudio":

        with zipfile.ZipFile(old_3mf, 'r') as old_zip, \
                zipfile.ZipFile(tmp_new, 'w', compression=zipfile.ZIP_DEFLATED) as new_zip:

            for info in old_zip.infolist():
                name = info.filename
                data = old_zip.read(name)

                # 1) Remplacement du mesh dans object_1.model
                if name == keep_model:
                    merged = replace_mesh_in_model_xml(data, geom_data_centered)

                    if ignore_transform:
                        merged = apply_common_transform_to_3dmodel(
                            merged, geom_data_centered, ignore_transform
                        )
                        merged = force_zmax_in_transform(merged, decal_z)

                    new_zip.writestr(name, merged)
                    continue

                # 2) Transform global dans 3dmodel.model
                if DEBUG: print("DEBUG FILENAME:", repr(name))

                if name.endswith("3dmodel.model"):

                    if ignore_transform:
                        merged = apply_common_transform_to_3dmodel(
                            data, geom_data_centered, ignore_transform
                        )
                        merged = force_zmax_in_transform(merged, decal_z)
                        new_zip.writestr(name, merged)
                        continue

                    # Case NON coch√©e ‚Üí transform d‚Äôorigine
                    new_zip.writestr(name, data)
                    continue

                # 3) Suppression des autres objets
                if name.startswith("3D/Objects/") and name.endswith(".model"):
                    continue

                # 4) Recopie du reste
                new_zip.writestr(name, data)

        # Remplacement final
        gc.collect()
        time.sleep(0.05)
        if os.path.exists(fc_3mf):
            os.remove(fc_3mf)
        shutil.move(tmp_new, fc_3mf)
        if os.path.exists(old_3mf):
            os.remove(old_3mf)
        if DEBUG: print("‚úÖ Injection faite dans :", os.path.basename(fc_3mf))
        return ""

    # ------------------------------------------------------------
    # CAS SLIC3R / CURA / FREECAD
    # ------------------------------------------------------------
    if slicer_source in ("slic3r", "cura", "freecad"):

        with zipfile.ZipFile(old_3mf, 'r') as old_zip, \
                zipfile.ZipFile(tmp_new, 'w', compression=zipfile.ZIP_DEFLATED) as new_zip:

            for info in old_zip.infolist():
                name = info.filename
                data = old_zip.read(name)

                if name.endswith("3dmodel.model"):
                    merged = replace_mesh_in_model_xml(data, geom_data_centered)
                    merged = force_zmax_in_transform(merged, decal_z)
                    new_zip.writestr(name, merged)
                    continue

                new_zip.writestr(name, data)

        # Remplacement final
        gc.collect()
        time.sleep(0.05)
        if os.path.exists(fc_3mf):
            os.remove(fc_3mf)
        shutil.move(tmp_new, fc_3mf)
        if os.path.exists(old_3mf):
            os.remove(old_3mf)
        if DEBUG: print("‚úÖ Injection faite dans :", os.path.basename(fc_3mf))
        return ""




def recenter_model_in_3mf(fc_3mf, model_path, center_x=0, center_y=0):
    """
    Recentre un fichier .model dans un 3MF, quel que soit son chemin.
    """
    import zipfile, shutil, os

    if not os.path.exists(fc_3mf):
        if DEBUG: print("‚ùå Fichier introuvable :", fc_3mf)
        return False

    # Lire le contenu du 3MF
    with zipfile.ZipFile(fc_3mf, 'r') as zin:
        buffer = {name: zin.read(name) for name in zin.namelist()}

    if model_path not in buffer:
        if DEBUG: print(f"‚ùå {model_path} introuvable dans le 3MF")
        return False

    # Recentrage g√©om√©trique
    new_model_data, decal_z = recenter_vertices(
        buffer[model_path],
        center_x=center_x,
        center_y=center_y
    )

    # Remplacement
    buffer[model_path] = new_model_data

    # R√©√©criture du 3MF
    tmp = fc_3mf + ".tmp"
    with zipfile.ZipFile(tmp, 'w') as zout:
        for name, data in buffer.items():
            zout.writestr(name, data)

    shutil.move(tmp, fc_3mf)
    return True


def recenter_model_in_3d_3dmodel(fc_3mf, center_x=0, center_y=0):
    return recenter_model_in_3mf(fc_3mf, "3D/3dmodel.model", center_x, center_y)


def fix_qidistudio_transforms(path):
    """
    Neutralise tx et ty dans le transform du <item> pour QidiStudio,
    en modifiant le XML en texte brut, sans ElementTree.
    """
    import zipfile
    import re
    import os

    tmp_path = path + ".tmp"

    # Expression r√©guli√®re pour capturer transform="a b c d e f g h i tx ty tz"
    # On capture les 9 premiers nombres, puis tx, ty, tz s√©par√©ment.
    transform_re = re.compile(
        r'transform="([0-9eE\.\-\s]+)"'
    )

    with zipfile.ZipFile(path, "r") as zin, \
         zipfile.ZipFile(tmp_path, "w", compression=zipfile.ZIP_DEFLATED) as zout:

        for info in zin.infolist():
            data = zin.read(info.filename)

            if info.filename == "3D/3dmodel.model":
                text = data.decode("utf-8")

                def repl(match):
                    full = match.group(1).strip()
                    parts = full.split()

                    if len(parts) != 12:
                        return match.group(0)  # on ne touche pas

                    # Neutralisation uniquement de tx et ty
                    parts[9] = "0"
                    parts[10] = "0"
                    # tz = parts[11] conserv√©

                    new_transform = " ".join(parts)
                    return f'transform="{new_transform}"'

                text = transform_re.sub(repl, text)
                data = text.encode("utf-8")

            zout.writestr(info, data)

    os.replace(tmp_path, path)





def get_first_item_xyz_from_3mf(path, PLATEAU_X, PLATEAU_Y):
    """
    Lit un fichier 3MF et renvoie (x, y, z) du premier <item>.
    Si le fichier n'existe pas ou est invalide, renvoie le centre du plateau.
    Compatible avec tous les slicers.
    """
    import os
    import zipfile
    import re

    # Valeurs par d√©faut = centre du plateau
    default_x = PLATEAU_X / 2
    default_y = PLATEAU_Y / 2
    default_z = 0

    # Si le fichier n'existe pas ‚Üí retour direct
    if not os.path.isfile(path):
        return default_x, default_y, default_z

    # Regex pour capturer objectid="X" et transform="12 nombres"
    item_re = re.compile(
        r'<item[^>]*objectid="(\d+)"[^>]*transform="([0-9eE\.\-\s]+)"',
        re.IGNORECASE
    )

    try:
        with zipfile.ZipFile(path, "r") as z:
            if "3D/3dmodel.model" not in z.namelist():
                return default_x, default_y, default_z

            text = z.read("3D/3dmodel.model").decode("utf-8")

    except Exception:
        # ZIP corrompu ou illisible
        return default_x, default_y, default_z

    # On r√©cup√®re le premier item trouv√©
    match = item_re.search(text)
    if not match:
        return default_x, default_y, default_z

    objectid, transform_str = match.groups()
    parts = transform_str.split()
    if len(parts) != 12:
        return default_x, default_y, default_z

    try:
        tx = float(parts[9])
        ty = float(parts[10])
        tz = float(parts[11])
    except Exception:
        return default_x, default_y, default_z

    return tx, ty, tz





def place_object_at_z0_in_3mf(path, cancel_rotation=False, center=True, x0=0, y0=0):
    """
    Centre globalement la sc√®ne en XY si center=True et pose tous les objets du 3MF
    exactement sur le plateau (Z = 0), tout en respectant leurs positions relatives.

    Compatible Cura, Qidi Studio, PrusaSlicer, et √©tendu aux 3MF avec composants
    (Orca/Bambu) via la r√©solution p:path + objectid dans <components>.

    La fonction lit chaque <item> du <build>, extrait sa matrice de transformation
    (3√ó3 en colonnes + translation), applique cette transformation compl√®te
    (rotation + translation) √† tous les vertices de l‚Äôobjet correspondant, puis
    calcule le Z minimal global obtenu dans le rep√®re du slicer.

    Ce Z minimal global (Zmin_global) repr√©sente la hauteur r√©elle du point le plus
    bas de la sc√®ne apr√®s rotation. La translation Z de chaque transform est alors
    corrig√©e selon :

        Tz_correct = Tz - Zmin_global

    afin que le point le plus bas de la sc√®ne soit exactement √† Z = 0, m√™me si les
    objets sont inclin√©s (cas n√©cessaire pour Cura, qui applique la translation
    avant la rotation).

    Seule la composante de translation (les trois derni√®res valeurs du transform)
    est modifi√©e pour chaque item ; les rotations et les positions relatives sont
    pr√©serv√©es.
    """

    import os, re, zipfile, shutil, tempfile, traceback
    if not center:
        x0 = 0
        y0 = 0

    print("DEBUG:", cancel_rotation, center, x0, y0)

    temp_dir = tempfile.mkdtemp()

    try:
        # --- Extraction du .3mf ---
        with zipfile.ZipFile(path, 'r') as z:
            z.extractall(temp_dir)

        model_path = os.path.join(temp_dir, "3D", "3dmodel.model")

        with open(model_path, "r", encoding="utf-8") as f:
            content = f.read()

        # --- Trouver tous les items ---
        items = re.findall(
            r'<item[^>]*objectid="(\d+)"[^>]*transform="([^"]+)"',
            content
        )

        if not items:
            print("‚ùå Aucun <item> trouv√© dans <build>")
            return

        # --- Liste unique des objectid ---
        object_ids = sorted(set(int(objid) for objid, _ in items))

        # --- Stockage des vertices transform√©s pour calcul global ---
        all_vertices_rotated = []

        # --- Stockage des transforms par objectid ---
        transforms_by_id = {}

        # --- Lecture des transforms ---
        for objectid, transform_str in items:
            values = list(map(float, transform_str.split()))
            if len(values) != 12:
                print(f"‚ùå Transform invalide pour objectid={objectid}")
                continue

            # Matrice 3√ó3 en colonnes
            R = [
                [values[0], values[3], values[6]],
                [values[1], values[4], values[7]],
                [values[2], values[5], values[8]],
            ]
            if cancel_rotation:
                R = [
                    [1, 0, 0],
                    [0, 1, 0],
                    [0, 0, 1],
                ]

            transforms_by_id[int(objectid)] = R

        # --- Pour chaque objectid : lire les vertices ---
        transforms_by_id_full = {}
        for objectid, transform_str in items:
            vals = list(map(float, transform_str.split()))
            transforms_by_id_full[int(objectid)] = (vals[9], vals[10], vals[11])

        for oid in object_ids:

            # 1) Chercher inline dans 3dmodel.model
            obj_match = re.search(
                rf'<object[^>]*id="{oid}"[^>]*>(.*?)</object>',
                content,
                flags=re.S
            )

            vertices = []

            if obj_match:
                vertices = [
                    (float(x), float(y), float(z))
                    for x, y, z in re.findall(
                        r'<vertex[^>]*x="([^"]+)"[^>]*y="([^"]+)"[^>]*z="([^"]+)"',
                        obj_match.group(1)
                    )
                ]

            # 2) Sinon chercher dans 3D/Objects/object_X.model (Qidi / Prusa-like)
            if not vertices:
                obj_file = os.path.join(
                    temp_dir, "3D", "Objects", f"object_{oid}.model"
                )
                if os.path.exists(obj_file):
                    with open(obj_file, "r", encoding="utf-8") as f:
                        data = f.read()
                    vertices = [
                        (float(x), float(y), float(z))
                        for x, y, z in re.findall(
                            r'<vertex[^>]*x="([^"]+)"[^>]*y="([^"]+)"[^>]*z="([^"]+)"',
                            data
                        )
                    ]

            # 3) Cas Orca/Bambu : objectid parent sans mesh, mais <component> avec p:path + objectid enfant
            if not vertices:
                # On r√©cup√®re le bloc <object id="oid">...</object>
                obj_block = re.search(
                    rf'<object[^>]*id="{oid}"[^>]*>(.*?)</object>',
                    content,
                    flags=re.S
                )
                if obj_block:
                    block = obj_block.group(1)

                    # On cherche un composant, ordre des attributs indiff√©rent
                    comp = re.search(
                        r'<component[^>]*objectid="(\d+)"[^>]*p:path="([^"]+)"',
                        block
                    ) or re.search(
                        r'<component[^>]*p:path="([^"]+)"[^>]*objectid="(\d+)"',
                        block
                    )

                    if comp:
                        # Normalisation des captures selon le match utilis√©
                        if comp.group(1).isdigit():
                            child_id = int(comp.group(1))
                            rel_path = comp.group(2)
                        else:
                            rel_path = comp.group(1)
                            child_id = int(comp.group(2))

                        rel_path = rel_path.lstrip('/')  # ex: "3D/Objects/Object_1_1.model"
                        comp_file = os.path.join(temp_dir, rel_path)

                        if os.path.exists(comp_file):
                            with open(comp_file, "r", encoding="utf-8") as f:
                                data = f.read()

                            # On cherche l'objet enfant par son id dans ce fichier
                            child_obj = re.search(
                                rf'<object[^>]*id="{child_id}"[^>]*>(.*?)</object>',
                                data,
                                flags=re.S
                            )
                            if child_obj:
                                vertices = [
                                    (float(x), float(y), float(z))
                                    for x, y, z in re.findall(
                                        r'<vertex[^>]*x="([^"]+)"[^>]*y="([^"]+)"[^>]*z="([^"]+)"',
                                        child_obj.group(1)
                                    )
                                ]

            if not vertices:
                print(f"‚ùå Aucun vertex trouv√© pour objectid={oid}")
                continue

            # --- Appliquer la rotation R ---
            R = transforms_by_id[oid]

            # On r√©cup√®re Tx, Ty, Tz du transform de cet objectid
            Tx, Ty, Tz = transforms_by_id_full[oid]

            for (x, y, z) in vertices:
                xr = R[0][0] * x + R[0][1] * y + R[0][2] * z + Tx
                yr = R[1][0] * x + R[1][1] * y + R[1][2] * z + Ty
                zr = R[2][0] * x + R[2][1] * y + R[2][2] * z + Tz
                all_vertices_rotated.append((xr, yr, zr))

        if not all_vertices_rotated:
            print("‚ùå Aucun vertex global trouv√©")
            return

        # --- Calcul global ---
        Xs = [v[0] for v in all_vertices_rotated]
        Ys = [v[1] for v in all_vertices_rotated]
        Zs = [v[2] for v in all_vertices_rotated]

        Zmin_global = min(Zs)

        if center:
            Cx_global = (min(Xs) + max(Xs)) / 2
            Cy_global = (min(Ys) + max(Ys)) / 2
        else:
            Cx_global = 0
            Cy_global = 0

        # --- Mise √† jour des transforms ---
        new_content = content

        for objectid, transform_str in items:
            vals = list(map(float, transform_str.split()))

            Tx, Ty, Tz = vals[9], vals[10], vals[11]

            # centrage XY autour de (x0, y0)
            if center:
                Tx = x0 + (Tx - Cx_global)
                Ty = y0 + (Ty - Cy_global)

            if cancel_rotation:
                vals[0:9] = [1, 0, 0, 0, 1, 0, 0, 0, 1]

            # correction Z dans le rep√®re du slicer
            Tz = Tz - Zmin_global
            vals[9], vals[10], vals[11] = Tx, Ty, Tz

            new_transform = " ".join(str(v) for v in vals)

            pattern = rf'(<item\b[^>]*\bobjectid="{objectid}"[^>]*\btransform=")([^"]+)"'

            def repl(m):
                return m.group(1) + new_transform + '"'

            new_content = re.sub(pattern, repl, new_content)

        # --- R√©√©criture du fichier ---
        with open(model_path, "w", encoding="utf-8") as f:
            f.write(new_content)

        # Reconstruction du .3mf
        temp_output = path + ".tmp"

        with zipfile.ZipFile(temp_output, 'w', zipfile.ZIP_DEFLATED) as z:
            for root, dirs, files in os.walk(temp_dir):
                for file in files:
                    full_path = os.path.join(root, file)
                    rel_path = os.path.relpath(full_path, temp_dir)
                    z.write(full_path, rel_path)

        shutil.move(temp_output, path)

        print("‚úî Sc√®ne pos√©e sur Z=0 et centr√©e globalement (Cura + Qidi + Prusa + Orca/Bambu)")

    except Exception:
        print("‚ùå ERREUR dans place_object_at_z0_in_3mf :")
        traceback.print_exc()

    finally:
        shutil.rmtree(temp_dir)





def launch_slicer_if_needed(slicer_path, launch_slicer, fc_3mf):
    """
    Lance le slicer si demand√© par l‚Äôutilisateur.
    - V√©rifie l‚Äôexistence du chemin
    - Ouvre le slicer avec le fichier 3MF
    - Sinon affiche un message de fin

    Ne retourne rien.
    """
    if DEBUG: print('Lancement du slicer', os.path.basename(slicer_path))
    # Lancement demand√© ?
    if launch_slicer and slicer_path and os.path.exists(slicer_path):
        try:
            time.sleep(0.2)  # petit d√©lai pour √©viter les conflits disque
            subprocess.Popen(f'"{slicer_path}" "{fc_3mf}"', shell=True)
        except Exception as e:
            show_message(tr("error_title"), f"{tr('error_launch_slicer')} {e}")
        return

    # Si l‚Äôutilisateur n‚Äôa pas demand√© le lancement
    if not launch_slicer:
        show_message(tr("info_title"), tr("info_done"))


def run_extra_commands(extra_cmds):
    """
    Ex√©cute les commandes externes d√©finies par l‚Äôutilisateur.
    Chaque entr√©e est un tuple : (checked, cmd, delay)

    - checked : bool ‚Üí ex√©cuter ou non
    - cmd : commande syst√®me
    - delay : d√©lai en secondes avant ex√©cution

    Ne retourne rien.
    """
    if DEBUG: print('Lancement commandes utilisateur')
    for checked, cmd, delay in extra_cmds:
        if not checked:
            continue

        try:
            if delay > 0:
                time.sleep(delay)

            subprocess.Popen(cmd)

        except Exception as e:
            show_message(tr("error_title"), f"{tr('error_external_cmd')} {e}")






# -----------------------------------------------------------------------------
# Routine principale : exporte la s√©lection en 3MF/STL, injecte g√©om√©trie,
# lance slicer et commandes externes
# ----------------------------------------------------------------------------





def export_replace_geometry():
    if DEBUG: print('\n\n>>> MACRO 3D_printer_3mf_workflow <<<')

    # ------------------------------------------------------------
    # V√©rifications initiales
    # ------------------------------------------------------------

    env = prepare_environment()
    if env is None:
        return
    (cfg, doc, base_name, fc_3mf, old_3mf_backup, fc_3mf_existed_at_start) = env

    # V√©rification de la s√©lection
    selection = get_valid_selection(fc_3mf, old_3mf_backup, fc_3mf_existed_at_start)
    if selection is None:
        return

    # ------------------------------------------------------------
    # Pr√©f√©rences + bo√Æte de dialogue
    # ------------------------------------------------------------

    opts = get_user_options(cfg)

    if opts is None:
        return

    (generate_stl,
     slicer_path, base3mf_path, launch_slicer,
     linear_value, angular_value, reset_all, ignore_transform, extra_cmds) = opts

    # Si l'utilisateur veut repartir de z√©ro
    if reset_all:
        if fc_3mf and os.path.exists(fc_3mf):
            if DEBUG: print('Suppression', os.path.basename(fc_3mf))
            os.remove(fc_3mf)

        show_message(
            tr("reset_title"),
            tr("reset_message")
        )

        # Relancer la macro proprement
        macro_path = __file__
        exec(open(macro_path, "r", encoding="utf-8").read())
        return

    # ------------------------------------------------------------
    # Remplacer le 3MF de travail par celui choisi par l'utilisateur
    # (seulement si le fichier existe)
    # ------------------------------------------------------------
    if base3mf_path and os.path.exists(base3mf_path):
        try:
            # Ne rien faire si c'est le m√™me fichier
            if os.path.exists(fc_3mf) and os.path.samefile(base3mf_path, fc_3mf):
                if DEBUG: print("Le fichier 3MF de base est identique au fichier de travail, aucune copie n√©cessaire.")
            else:
                shutil.copy(base3mf_path, fc_3mf)
                if DEBUG: print("Copie du fichier 3MF de base :", os.path.basename(base3mf_path),
                                "vers", os.path.basename(fc_3mf))
        except Exception as e:
            if DEBUG: print("Erreur lors de la copie du 3MF de base :", e)

    # ------------------------------------------------------------
    # r√©cup√©ration de slice source et cible
    # --------------------------------------------------------------
    slicer_source = nameSlicer(fc_3mf)
    slicer_target = detect_slicer_target_from_path(slicer_path) if slicer_path else None
    if DEBUG: print('Slicer source par analyse du contenu de (fc_3mf)', os.path.basename(fc_3mf), slicer_source)
    if DEBUG: print('Slicer cible par analyse du nom de l\'exe ', os.path.basename(slicer_path), slicer_target)
    print("DEBUG base3mf_path =", base3mf_path)
    print("DEBUG fc_3mf =", fc_3mf)
    ###################################-----------------------------------------------------#####TESTE FONCTION
    x, y, z = get_first_item_xyz_from_3mf(fc_3mf, PLATEAU_X, PLATEAU_Y)
    print("---------------------------------------------X =", x, "Y =", y, "Z =", z)




    # ------------------------------------------------------------
    # Actions si plateau vide du fc_3mf : si vide propose de copier le old en fc_3mf (False)
    # ou de sortir (True) si (annul√© ou retore car plateau vide)
    # ------------------------------------------------------------
    if not handle_empty_plate(fc_3mf_existed_at_start, old_3mf_backup, fc_3mf):
        return

    # ------------------------------------------------------------
    # rotation des sauvegardes du 3mf
    # --------------------------------------------------------------
    rotate_old_backups(base_name, MAX_OLD_BACKUPS)

    # ------------------------------------------------------------
    # pr√©paration de l'environnement suite apr√®s boite de dialogue
    # --------------------------------------------------------------
    # copie du 3mf en old = Sauvegarde de l'ancien 3MF (seulement si le .3mf existait au d√©part)
    # Suite √† √ßa l e3mf n'existe plus.

    if fc_3mf_existed_at_start:
        shutil.copy(fc_3mf, old_3mf_backup)
        if DEBUG: print('Copie de fc_3mf', os.path.basename(fc_3mf), 'vers old_3mf_backup',
                        os.path.basename(old_3mf_backup))

    # ------------------------------------------------------------
    # 3) Export FreeCAD ‚Üí 3MF
    # ------------------------------------------------------------
    if not export_freecad_files(selection, base_name, fc_3mf, generate_stl,
                                linear_value, angular_value,
                                fc_3mf_existed_at_start, old_3mf_backup):
        return

    # ------------------------------------------------------------
    # Injection g√©om√©trie si ancien 3MF
    # ------------------------------------------------------------
    if DEBUG: print("Dans export_replace_geometry : >>> Avant inject_geometry, fichier =", fc_3mf)

    if inject_geometry_if_possible(
            base_name, fc_3mf, old_3mf_backup, fc_3mf_existed_at_start,
            slicer_path, ignore_transform
    ) == 'cancel':
        return

    # ------------------------------------------------------------
    # Recentrage des vertices
    # ------------------------------------------------------------
    # --- QIDISTUDIO ---
    #if slicer_target == "qidistudio":
    #    recenter_model_in_3d_objects(fc_3mf)


    # --- QIDISLICER ---
    if ignore_transform and slicer_target == "qidislicer":
        apply_common_transform_to_3mf_in_place(fc_3mf)

    # --- PRUSA ---
    if slicer_target == 'slic3r' and ignore_transform:
        recenter_model_in_3d_3dmodel(fc_3mf, 0, 0)
        apply_common_transform_to_3mf_in_place(fc_3mf)

    # --- CURA ---


    if slicer_target == 'cura' and (slicer_source != 'cura' or ignore_transform):
        if DEBUG: print("Recentrage transform pour Cura via apply_common_transform_to_3mf_in_place")
        # test de remplacement de cette fonction
        # apply_common_transform_to_3mf_in_place(fc_3mf)
        # par
        place_object_at_z0_in_3mf(fc_3mf, True, True, PLATEAU_X / 2, PLATEAU_Y / 2)

    if slicer_target in ['cura']:  # √† modifier pour pas appeler deux fois la fonction
        # Ajout d'une directive pour que cura plaque l'objet sur le plateau.
        # Et du coup on doit pouvoir retirer le calcul du d√©calage en z
        patch_drop_to_buildplate_in_place(fc_3mf)
        # ajuste le z pour que l'objet soit bien pos√© sur le plateau
        # place_object_at_z0_in_3mf(fc_3mf, True, 100, 100)
        # false car pas de centrage et false car pas d'annulation de rotation. Juste un z recalcul√©
        place_object_at_z0_in_3mf(fc_3mf, False, False)

    """
    A tester : 
    if slicer_target == 'cura':

        # Toujours activer le comportement "coller au plateau" dans Cura
        patch_drop_to_buildplate_in_place(fc_3mf)

        if slicer_source != 'cura' or ignore_transform:
            # centrage + annulation rotation + placement Z
            place_object_at_z0_in_3mf(fc_3mf, center=True, cancel_rotation=True,
                                      x0=PLATEAU_X/2, y0=PLATEAU_Y/2)
        else:
            # juste recalcul Z, sans centrage ni annulation rotation
            place_object_at_z0_in_3mf(fc_3mf, center=False, cancel_rotation=False)

    """



    #if slicer_target == 'qidistudio':
    #    fix_qidistudio_transforms(fc_3mf)

    ####################################################################"""A RETIRER
    place_object_at_z0_in_3mf(fc_3mf, False, True, 125, 125)

    # ------------------------------------------------------------
    # Lancement du slicer
    # ------------------------------------------------------------
    launch_slicer_if_needed(slicer_path, launch_slicer, fc_3mf)

    # ------------------------------------------------------------
    # Commandes externes
    # ------------------------------------------------------------
    run_extra_commands(extra_cmds)


export_replace_geometry()



















import inspect

def _debug_list_functions():
    print("\n=== LISTE DES FONCTIONS DANS LA MACRO ===")
    for name, obj in globals().items():
        if inspect.isfunction(obj):
            print(name)
    print("=== FIN DE LISTE ===\n")

_debug_list_functions()



import ast
import inspect

def _debug_find_unused_functions(path):
    with open(path, "r", encoding="utf-8") as f:
        tree = ast.parse(f.read())

    # 1) R√©cup√©rer toutes les fonctions d√©finies dans le fichier
    defined_funcs = set()
    for node in tree.body:
        if isinstance(node, ast.FunctionDef):
            defined_funcs.add(node.name)

    # 2) R√©cup√©rer tous les appels de fonctions dans le fichier
    called_funcs = set()
    class CallVisitor(ast.NodeVisitor):
        def visit_Call(self, node):
            if isinstance(node.func, ast.Name):
                called_funcs.add(node.func.id)
            self.generic_visit(node)

    CallVisitor().visit(tree)

    # 3) Fonctions d√©finies mais jamais appel√©es
    unused = sorted(defined_funcs - called_funcs)

    print("\n=== FONCTIONS D√âFINIES MAIS JAMAIS APPEL√âES ===")
    for name in unused:
        print("  -", name)
    print("=== FIN ===\n")

# Lancer l‚Äôanalyse
_debug_find_unused_functions(__file__)

